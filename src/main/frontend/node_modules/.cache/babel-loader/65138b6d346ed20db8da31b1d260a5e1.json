{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/format/TopoJSON\n */\n\n\nimport Feature from '../Feature.js';\nimport { transformGeometryWithOptions } from './Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * @typedef {import(\"topojson-specification\").Topology} TopoJSONTopology\n * @typedef {import(\"topojson-specification\").GeometryCollection} TopoJSONGeometryCollection\n * @typedef {import(\"topojson-specification\").GeometryObject} TopoJSONGeometry\n * @typedef {import(\"topojson-specification\").Point} TopoJSONPoint\n * @typedef {import(\"topojson-specification\").MultiPoint} TopoJSONMultiPoint\n * @typedef {import(\"topojson-specification\").LineString} TopoJSONLineString\n * @typedef {import(\"topojson-specification\").MultiLineString} TopoJSONMultiLineString\n * @typedef {import(\"topojson-specification\").Polygon} TopoJSONPolygon\n * @typedef {import(\"topojson-specification\").MultiPolygon} TopoJSONMultiPolygon\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {string} [layerName] Set the name of the TopoJSON topology\n * `objects`'s children as feature property with the specified name. This means\n * that when set to `'layer'`, a topology like\n * ```\n * {\n *   \"type\": \"Topology\",\n *   \"objects\": {\n *     \"example\": {\n *       \"type\": \"GeometryCollection\",\n *       \"geometries\": []\n *     }\n *   }\n * }\n * ```\n * will result in features that have a property `'layer'` set to `'example'`.\n * When not set, no property will be added to features.\n * @property {Array<string>} [layers] Names of the TopoJSON topology's\n * `objects`'s children to read features from.  If not provided, features will\n * be read from all children.\n */\n\n/**\n * @classdesc\n * Feature format for reading data in the TopoJSON format.\n *\n * @api\n */\n\nvar TopoJSON =\n/** @class */\nfunction (_super) {\n  __extends(TopoJSON, _super);\n  /**\n   * @param {Options=} opt_options Options.\n   */\n\n\n  function TopoJSON(opt_options) {\n    var _this = _super.call(this) || this;\n\n    var options = opt_options ? opt_options : {};\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n\n    _this.layerName_ = options.layerName;\n    /**\n     * @private\n     * @type {?Array<string>}\n     */\n\n    _this.layers_ = options.layers ? options.layers : null;\n    /**\n     * @inheritDoc\n     */\n\n    _this.dataProjection = getProjection(options.dataProjection ? options.dataProjection : 'EPSG:4326');\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  TopoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {\n    if (object.type == 'Topology') {\n      var topoJSONTopology =\n      /** @type {TopoJSONTopology} */\n      object;\n      var transform = void 0,\n          scale = null,\n          translate = null;\n\n      if (topoJSONTopology['transform']) {\n        transform = topoJSONTopology['transform'];\n        scale = transform['scale'];\n        translate = transform['translate'];\n      }\n\n      var arcs = topoJSONTopology['arcs'];\n\n      if (transform) {\n        transformArcs(arcs, scale, translate);\n      }\n      /** @type {Array<Feature>} */\n\n\n      var features = [];\n      var topoJSONFeatures = topoJSONTopology['objects'];\n      var property = this.layerName_;\n      var feature = void 0;\n\n      for (var objectName in topoJSONFeatures) {\n        if (this.layers_ && this.layers_.indexOf(objectName) == -1) {\n          continue;\n        }\n\n        if (topoJSONFeatures[objectName].type === 'GeometryCollection') {\n          feature =\n          /** @type {TopoJSONGeometryCollection} */\n          topoJSONFeatures[objectName];\n          features.push.apply(features, readFeaturesFromGeometryCollection(feature, arcs, scale, translate, property, objectName, opt_options));\n        } else {\n          feature =\n          /** @type {TopoJSONGeometry} */\n          topoJSONFeatures[objectName];\n          features.push(readFeatureFromGeometry(feature, arcs, scale, translate, property, objectName, opt_options));\n        }\n      }\n\n      return features;\n    } else {\n      return [];\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  TopoJSON.prototype.readProjectionFromObject = function (object) {\n    return this.dataProjection;\n  };\n\n  return TopoJSON;\n}(JSONFeature);\n/**\n * @const\n * @type {Object<string, function(TopoJSONGeometry, Array, ...Array=): import(\"../geom/Geometry.js\").default>}\n */\n\n\nvar GEOMETRY_READERS = {\n  'Point': readPointGeometry,\n  'LineString': readLineStringGeometry,\n  'Polygon': readPolygonGeometry,\n  'MultiPoint': readMultiPointGeometry,\n  'MultiLineString': readMultiLineStringGeometry,\n  'MultiPolygon': readMultiPolygonGeometry\n};\n/**\n * Concatenate arcs into a coordinate array.\n * @param {Array<number>} indices Indices of arcs to concatenate.  Negative\n *     values indicate arcs need to be reversed.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs (already\n *     transformed).\n * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates array.\n */\n\nfunction concatenateArcs(indices, arcs) {\n  /** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n  var coordinates = [];\n  var index, arc;\n\n  for (var i = 0, ii = indices.length; i < ii; ++i) {\n    index = indices[i];\n\n    if (i > 0) {\n      // splicing together arcs, discard last point\n      coordinates.pop();\n    }\n\n    if (index >= 0) {\n      // forward arc\n      arc = arcs[index];\n    } else {\n      // reverse arc\n      arc = arcs[~index].slice().reverse();\n    }\n\n    coordinates.push.apply(coordinates, arc);\n  } // provide fresh copies of coordinate arrays\n\n\n  for (var j = 0, jj = coordinates.length; j < jj; ++j) {\n    coordinates[j] = coordinates[j].slice();\n  }\n\n  return coordinates;\n}\n/**\n * Create a point from a TopoJSON geometry object.\n *\n * @param {TopoJSONPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {Point} Geometry.\n */\n\n\nfunction readPointGeometry(object, scale, translate) {\n  var coordinates = object['coordinates'];\n\n  if (scale && translate) {\n    transformVertex(coordinates, scale, translate);\n  }\n\n  return new Point(coordinates);\n}\n/**\n * Create a multi-point from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {MultiPoint} Geometry.\n */\n\n\nfunction readMultiPointGeometry(object, scale, translate) {\n  var coordinates = object['coordinates'];\n\n  if (scale && translate) {\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n      transformVertex(coordinates[i], scale, translate);\n    }\n  }\n\n  return new MultiPoint(coordinates);\n}\n/**\n * Create a linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {LineString} Geometry.\n */\n\n\nfunction readLineStringGeometry(object, arcs) {\n  var coordinates = concatenateArcs(object['arcs'], arcs);\n  return new LineString(coordinates);\n}\n/**\n * Create a multi-linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiLineString} Geometry.\n */\n\n\nfunction readMultiLineStringGeometry(object, arcs) {\n  var coordinates = [];\n\n  for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n\n  return new MultiLineString(coordinates);\n}\n/**\n * Create a polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {Polygon} Geometry.\n */\n\n\nfunction readPolygonGeometry(object, arcs) {\n  var coordinates = [];\n\n  for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n\n  return new Polygon(coordinates);\n}\n/**\n * Create a multi-polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiPolygon} Geometry.\n */\n\n\nfunction readMultiPolygonGeometry(object, arcs) {\n  var coordinates = [];\n\n  for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    // for each polygon\n    var polyArray = object['arcs'][i];\n    var ringCoords = [];\n\n    for (var j = 0, jj = polyArray.length; j < jj; ++j) {\n      // for each ring\n      ringCoords[j] = concatenateArcs(polyArray[j], arcs);\n    }\n\n    coordinates[i] = ringCoords;\n  }\n\n  return new MultiPolygon(coordinates);\n}\n/**\n * Create features from a TopoJSON GeometryCollection object.\n *\n * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry\n *     object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\n * @return {Array<Feature>} Array of features.\n */\n\n\nfunction readFeaturesFromGeometryCollection(collection, arcs, scale, translate, property, name, opt_options) {\n  var geometries = collection['geometries'];\n  var features = [];\n\n  for (var i = 0, ii = geometries.length; i < ii; ++i) {\n    features[i] = readFeatureFromGeometry(geometries[i], arcs, scale, translate, property, name, opt_options);\n  }\n\n  return features;\n}\n/**\n * Create a feature from a TopoJSON geometry object.\n *\n * @param {TopoJSONGeometry} object TopoJSON geometry object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\n * @return {Feature} Feature.\n */\n\n\nfunction readFeatureFromGeometry(object, arcs, scale, translate, property, name, opt_options) {\n  var geometry;\n  var type = object.type;\n  var geometryReader = GEOMETRY_READERS[type];\n\n  if (type === 'Point' || type === 'MultiPoint') {\n    geometry = geometryReader(object, scale, translate);\n  } else {\n    geometry = geometryReader(object, arcs);\n  }\n\n  var feature = new Feature();\n  feature.setGeometry(transformGeometryWithOptions(geometry, false, opt_options));\n\n  if (object.id !== undefined) {\n    feature.setId(object.id);\n  }\n\n  var properties = object.properties;\n\n  if (property) {\n    if (!properties) {\n      properties = {};\n    }\n\n    properties[property] = name;\n  }\n\n  if (properties) {\n    feature.setProperties(properties, true);\n  }\n\n  return feature;\n}\n/**\n * Apply a linear transform to array of arcs.  The provided array of arcs is\n * modified in place.\n *\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\n\n\nfunction transformArcs(arcs, scale, translate) {\n  for (var i = 0, ii = arcs.length; i < ii; ++i) {\n    transformArc(arcs[i], scale, translate);\n  }\n}\n/**\n * Apply a linear transform to an arc.  The provided arc is modified in place.\n *\n * @param {Array<import(\"../coordinate.js\").Coordinate>} arc Arc.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\n\n\nfunction transformArc(arc, scale, translate) {\n  var x = 0;\n  var y = 0;\n\n  for (var i = 0, ii = arc.length; i < ii; ++i) {\n    var vertex = arc[i];\n    x += vertex[0];\n    y += vertex[1];\n    vertex[0] = x;\n    vertex[1] = y;\n    transformVertex(vertex, scale, translate);\n  }\n}\n/**\n * Apply a linear transform to a vertex.  The provided vertex is modified in\n * place.\n *\n * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\n\n\nfunction transformVertex(vertex, scale, translate) {\n  vertex[0] = vertex[0] * scale[0] + translate[0];\n  vertex[1] = vertex[1] * scale[1] + translate[1];\n}\n\nexport default TopoJSON;","map":{"version":3,"sources":["../src/format/TopoJSON.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/TopoJSON\n */\nimport Feature from '../Feature.js';\nimport { transformGeometryWithOptions } from './Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * @typedef {import(\"topojson-specification\").Topology} TopoJSONTopology\n * @typedef {import(\"topojson-specification\").GeometryCollection} TopoJSONGeometryCollection\n * @typedef {import(\"topojson-specification\").GeometryObject} TopoJSONGeometry\n * @typedef {import(\"topojson-specification\").Point} TopoJSONPoint\n * @typedef {import(\"topojson-specification\").MultiPoint} TopoJSONMultiPoint\n * @typedef {import(\"topojson-specification\").LineString} TopoJSONLineString\n * @typedef {import(\"topojson-specification\").MultiLineString} TopoJSONMultiLineString\n * @typedef {import(\"topojson-specification\").Polygon} TopoJSONPolygon\n * @typedef {import(\"topojson-specification\").MultiPolygon} TopoJSONMultiPolygon\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {string} [layerName] Set the name of the TopoJSON topology\n * `objects`'s children as feature property with the specified name. This means\n * that when set to `'layer'`, a topology like\n * ```\n * {\n *   \"type\": \"Topology\",\n *   \"objects\": {\n *     \"example\": {\n *       \"type\": \"GeometryCollection\",\n *       \"geometries\": []\n *     }\n *   }\n * }\n * ```\n * will result in features that have a property `'layer'` set to `'example'`.\n * When not set, no property will be added to features.\n * @property {Array<string>} [layers] Names of the TopoJSON topology's\n * `objects`'s children to read features from.  If not provided, features will\n * be read from all children.\n */\n/**\n * @classdesc\n * Feature format for reading data in the TopoJSON format.\n *\n * @api\n */\nvar TopoJSON = /** @class */ (function (_super) {\n    __extends(TopoJSON, _super);\n    /**\n     * @param {Options=} opt_options Options.\n     */\n    function TopoJSON(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * @private\n         * @type {string|undefined}\n         */\n        _this.layerName_ = options.layerName;\n        /**\n         * @private\n         * @type {?Array<string>}\n         */\n        _this.layers_ = options.layers ? options.layers : null;\n        /**\n         * @inheritDoc\n         */\n        _this.dataProjection = getProjection(options.dataProjection ?\n            options.dataProjection : 'EPSG:4326');\n        return _this;\n    }\n    /**\n     * @inheritDoc\n     */\n    TopoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {\n        if (object.type == 'Topology') {\n            var topoJSONTopology = /** @type {TopoJSONTopology} */ (object);\n            var transform = void 0, scale = null, translate = null;\n            if (topoJSONTopology['transform']) {\n                transform = topoJSONTopology['transform'];\n                scale = transform['scale'];\n                translate = transform['translate'];\n            }\n            var arcs = topoJSONTopology['arcs'];\n            if (transform) {\n                transformArcs(arcs, scale, translate);\n            }\n            /** @type {Array<Feature>} */\n            var features = [];\n            var topoJSONFeatures = topoJSONTopology['objects'];\n            var property = this.layerName_;\n            var feature = void 0;\n            for (var objectName in topoJSONFeatures) {\n                if (this.layers_ && this.layers_.indexOf(objectName) == -1) {\n                    continue;\n                }\n                if (topoJSONFeatures[objectName].type === 'GeometryCollection') {\n                    feature = /** @type {TopoJSONGeometryCollection} */ (topoJSONFeatures[objectName]);\n                    features.push.apply(features, readFeaturesFromGeometryCollection(feature, arcs, scale, translate, property, objectName, opt_options));\n                }\n                else {\n                    feature = /** @type {TopoJSONGeometry} */ (topoJSONFeatures[objectName]);\n                    features.push(readFeatureFromGeometry(feature, arcs, scale, translate, property, objectName, opt_options));\n                }\n            }\n            return features;\n        }\n        else {\n            return [];\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    TopoJSON.prototype.readProjectionFromObject = function (object) {\n        return this.dataProjection;\n    };\n    return TopoJSON;\n}(JSONFeature));\n/**\n * @const\n * @type {Object<string, function(TopoJSONGeometry, Array, ...Array=): import(\"../geom/Geometry.js\").default>}\n */\nvar GEOMETRY_READERS = {\n    'Point': readPointGeometry,\n    'LineString': readLineStringGeometry,\n    'Polygon': readPolygonGeometry,\n    'MultiPoint': readMultiPointGeometry,\n    'MultiLineString': readMultiLineStringGeometry,\n    'MultiPolygon': readMultiPolygonGeometry\n};\n/**\n * Concatenate arcs into a coordinate array.\n * @param {Array<number>} indices Indices of arcs to concatenate.  Negative\n *     values indicate arcs need to be reversed.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs (already\n *     transformed).\n * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates array.\n */\nfunction concatenateArcs(indices, arcs) {\n    /** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n    var coordinates = [];\n    var index, arc;\n    for (var i = 0, ii = indices.length; i < ii; ++i) {\n        index = indices[i];\n        if (i > 0) {\n            // splicing together arcs, discard last point\n            coordinates.pop();\n        }\n        if (index >= 0) {\n            // forward arc\n            arc = arcs[index];\n        }\n        else {\n            // reverse arc\n            arc = arcs[~index].slice().reverse();\n        }\n        coordinates.push.apply(coordinates, arc);\n    }\n    // provide fresh copies of coordinate arrays\n    for (var j = 0, jj = coordinates.length; j < jj; ++j) {\n        coordinates[j] = coordinates[j].slice();\n    }\n    return coordinates;\n}\n/**\n * Create a point from a TopoJSON geometry object.\n *\n * @param {TopoJSONPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {Point} Geometry.\n */\nfunction readPointGeometry(object, scale, translate) {\n    var coordinates = object['coordinates'];\n    if (scale && translate) {\n        transformVertex(coordinates, scale, translate);\n    }\n    return new Point(coordinates);\n}\n/**\n * Create a multi-point from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {MultiPoint} Geometry.\n */\nfunction readMultiPointGeometry(object, scale, translate) {\n    var coordinates = object['coordinates'];\n    if (scale && translate) {\n        for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n            transformVertex(coordinates[i], scale, translate);\n        }\n    }\n    return new MultiPoint(coordinates);\n}\n/**\n * Create a linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {LineString} Geometry.\n */\nfunction readLineStringGeometry(object, arcs) {\n    var coordinates = concatenateArcs(object['arcs'], arcs);\n    return new LineString(coordinates);\n}\n/**\n * Create a multi-linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiLineString} Geometry.\n */\nfunction readMultiLineStringGeometry(object, arcs) {\n    var coordinates = [];\n    for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n        coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n    }\n    return new MultiLineString(coordinates);\n}\n/**\n * Create a polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {Polygon} Geometry.\n */\nfunction readPolygonGeometry(object, arcs) {\n    var coordinates = [];\n    for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n        coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n    }\n    return new Polygon(coordinates);\n}\n/**\n * Create a multi-polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiPolygon} Geometry.\n */\nfunction readMultiPolygonGeometry(object, arcs) {\n    var coordinates = [];\n    for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n        // for each polygon\n        var polyArray = object['arcs'][i];\n        var ringCoords = [];\n        for (var j = 0, jj = polyArray.length; j < jj; ++j) {\n            // for each ring\n            ringCoords[j] = concatenateArcs(polyArray[j], arcs);\n        }\n        coordinates[i] = ringCoords;\n    }\n    return new MultiPolygon(coordinates);\n}\n/**\n * Create features from a TopoJSON GeometryCollection object.\n *\n * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry\n *     object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\n * @return {Array<Feature>} Array of features.\n */\nfunction readFeaturesFromGeometryCollection(collection, arcs, scale, translate, property, name, opt_options) {\n    var geometries = collection['geometries'];\n    var features = [];\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n        features[i] = readFeatureFromGeometry(geometries[i], arcs, scale, translate, property, name, opt_options);\n    }\n    return features;\n}\n/**\n * Create a feature from a TopoJSON geometry object.\n *\n * @param {TopoJSONGeometry} object TopoJSON geometry object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\n * @return {Feature} Feature.\n */\nfunction readFeatureFromGeometry(object, arcs, scale, translate, property, name, opt_options) {\n    var geometry;\n    var type = object.type;\n    var geometryReader = GEOMETRY_READERS[type];\n    if ((type === 'Point') || (type === 'MultiPoint')) {\n        geometry = geometryReader(object, scale, translate);\n    }\n    else {\n        geometry = geometryReader(object, arcs);\n    }\n    var feature = new Feature();\n    feature.setGeometry(transformGeometryWithOptions(geometry, false, opt_options));\n    if (object.id !== undefined) {\n        feature.setId(object.id);\n    }\n    var properties = object.properties;\n    if (property) {\n        if (!properties) {\n            properties = {};\n        }\n        properties[property] = name;\n    }\n    if (properties) {\n        feature.setProperties(properties, true);\n    }\n    return feature;\n}\n/**\n * Apply a linear transform to array of arcs.  The provided array of arcs is\n * modified in place.\n *\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArcs(arcs, scale, translate) {\n    for (var i = 0, ii = arcs.length; i < ii; ++i) {\n        transformArc(arcs[i], scale, translate);\n    }\n}\n/**\n * Apply a linear transform to an arc.  The provided arc is modified in place.\n *\n * @param {Array<import(\"../coordinate.js\").Coordinate>} arc Arc.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArc(arc, scale, translate) {\n    var x = 0;\n    var y = 0;\n    for (var i = 0, ii = arc.length; i < ii; ++i) {\n        var vertex = arc[i];\n        x += vertex[0];\n        y += vertex[1];\n        vertex[0] = x;\n        vertex[1] = y;\n        transformVertex(vertex, scale, translate);\n    }\n}\n/**\n * Apply a linear transform to a vertex.  The provided vertex is modified in\n * place.\n *\n * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformVertex(vertex, scale, translate) {\n    vertex[0] = vertex[0] * scale[0] + translate[0];\n    vertex[1] = vertex[1] * scale[1] + translate[1];\n}\nexport default TopoJSON;\n//# sourceMappingURL=TopoJSON.js.map"]},"metadata":{},"sourceType":"module"}