{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/render/canvas/Builder\n */\n\n\nimport { equals, reverseSubArray } from '../../array.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, coordinateRelationship } from '../../extent.js';\nimport Relationship from '../../extent/Relationship.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray } from '../../geom/flat/inflate.js';\nimport VectorContext from '../VectorContext.js';\nimport { defaultFillStyle, defaultStrokeStyle, defaultMiterLimit, defaultLineWidth, defaultLineJoin, defaultLineDashOffset, defaultLineDash, defaultLineCap } from '../canvas.js';\nimport CanvasInstruction from './Instruction.js';\n/**\n * @typedef {Object} SerializableInstructions\n * @property {Array<*>} instructions The rendering instructions.\n * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.\n * @property {Array<number>} coordinates The array of all coordinates.\n * @property {!Object<string, import(\"../canvas.js\").TextState>} [textStates] The text states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").FillState>} [fillStates] The fill states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").StrokeState>} [strokeStates] The stroke states (decluttering).\n */\n\nvar CanvasBuilder =\n/** @class */\nfunction (_super) {\n  __extends(CanvasBuilder, _super);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n\n\n  function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    var _this = _super.call(this) || this;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n\n    _this.tolerance = tolerance;\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    _this.maxExtent = maxExtent;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    _this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    _this.maxLineWidth = 0;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n\n    _this.resolution = resolution;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n\n    _this.beginGeometryInstruction1_ = null;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n\n    _this.beginGeometryInstruction2_ = null;\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    _this.bufferedMaxExtent_ = null;\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    _this.instructions = [];\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n\n    _this.coordinates = [];\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n\n    _this.tmpCoordinate_ = [];\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    _this.hitDetectionInstructions = [];\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n\n    _this.state =\n    /** @type {import(\"../canvas.js\").FillStrokeState} */\n    {};\n    return _this;\n  }\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n\n\n  CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {\n    var pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n      return dash * pixelRatio;\n    });\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n\n\n  CanvasBuilder.prototype.appendFlatCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {\n    var myEnd = this.coordinates.length;\n    var extent = this.getBufferedMaxExtent();\n\n    if (skipFirst) {\n      offset += stride;\n    }\n\n    var lastXCoord = flatCoordinates[offset];\n    var lastYCoord = flatCoordinates[offset + 1];\n    var nextCoord = this.tmpCoordinate_;\n    var skipped = true;\n    var i, lastRel, nextRel;\n\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          this.coordinates[myEnd++] = lastXCoord;\n          this.coordinates[myEnd++] = lastYCoord;\n        }\n\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else if (nextRel === Relationship.INTERSECTING) {\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n\n      lastXCoord = nextCoord[0];\n      lastYCoord = nextCoord[1];\n      lastRel = nextRel;\n    } // Last coordinate equals first or only one point to append:\n\n\n    if (closed && skipped || i === offset + stride) {\n      this.coordinates[myEnd++] = lastXCoord;\n      this.coordinates[myEnd++] = lastYCoord;\n    }\n\n    return myEnd;\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} builderEnds Builder ends.\n   * @return {number} Offset.\n   */\n\n\n  CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var builderEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n      builderEnds.push(builderEnd);\n      offset = end;\n    }\n\n    return offset;\n  };\n  /**\n   * @inheritDoc.\n   */\n\n\n  CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer) {\n    this.beginGeometry(geometry, feature);\n    var type = geometry.getType();\n    var stride = geometry.getStride();\n    var builderBegin = this.coordinates.length;\n    var flatCoordinates, builderEnd, builderEnds, builderEndss;\n    var offset;\n\n    if (type == GeometryType.MULTI_POLYGON) {\n      geometry =\n      /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n      geometry;\n      flatCoordinates = geometry.getOrientedFlatCoordinates();\n      builderEndss = [];\n      var endss = geometry.getEndss();\n      offset = 0;\n\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var myEnds = [];\n        offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n        builderEndss.push(myEnds);\n      }\n\n      this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n    } else if (type == GeometryType.POLYGON || type == GeometryType.MULTI_LINE_STRING) {\n      builderEnds = [];\n      flatCoordinates = type == GeometryType.POLYGON ?\n      /** @type {import(\"../../geom/Polygon.js\").default} */\n      geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n      offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n      /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */\n      geometry.getEnds(), stride, builderEnds);\n      this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, renderer, inflateCoordinatesArray]);\n    } else if (type == GeometryType.LINE_STRING || type == GeometryType.MULTI_POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      builderEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n      this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n    } else if (type == GeometryType.POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n      builderEnd = this.coordinates.length;\n      this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer]);\n    }\n\n    this.endGeometry(feature);\n  };\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {\n    var extent = geometry.getExtent();\n    this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, extent];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, extent];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  };\n  /**\n   * @return {SerializableInstructions} the serializable instructions.\n   */\n\n\n  CanvasBuilder.prototype.finish = function () {\n    return {\n      instructions: this.instructions,\n      hitDetectionInstructions: this.hitDetectionInstructions,\n      coordinates: this.coordinates\n    };\n  };\n  /**\n   * Reverse the hit detection instructions.\n   */\n\n\n  CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {\n    var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array\n\n    hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks\n\n    var i;\n    var n = hitDetectionInstructions.length;\n    var instruction;\n    var type;\n    var begin = -1;\n\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type =\n      /** @type {CanvasInstruction} */\n      instruction[0];\n\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {\n    var state = this.state;\n\n    if (fillStyle) {\n      var fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n    } else {\n      state.fillStyle = undefined;\n    }\n\n    if (strokeStyle) {\n      var strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;\n      var strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache\n\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Fill instruction.\n   */\n\n\n  CanvasBuilder.prototype.createFill = function (state) {\n    var fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n\n    var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n\n    return fillInstruction;\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n\n\n  CanvasBuilder.prototype.applyStroke = function (state) {\n    this.instructions.push(this.createStroke(state));\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n\n\n  CanvasBuilder.prototype.createStroke = function (state) {\n    return [CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n   */\n\n\n  CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {\n    var fillStyle = state.fillStyle;\n\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state));\n      }\n\n      state.currentFillStyle = fillStyle;\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n   */\n\n\n  CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {\n    var strokeStyle = state.strokeStyle;\n    var lineCap = state.lineCap;\n    var lineDash = state.lineDash;\n    var lineDashOffset = state.lineDashOffset;\n    var lineJoin = state.lineJoin;\n    var lineWidth = state.lineWidth;\n    var miterLimit = state.miterLimit;\n\n    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  };\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  CanvasBuilder.prototype.endGeometry = function (feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  };\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n\n\n  CanvasBuilder.prototype.getBufferedMaxExtent = function () {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n\n      if (this.maxLineWidth > 0) {\n        var width = this.resolution * (this.maxLineWidth + 1) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n\n    return this.bufferedMaxExtent_;\n  };\n\n  return CanvasBuilder;\n}(VectorContext);\n\nexport default CanvasBuilder;","map":{"version":3,"sources":["../../src/render/canvas/Builder.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/render/canvas/Builder\n */\nimport { equals, reverseSubArray } from '../../array.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, coordinateRelationship } from '../../extent.js';\nimport Relationship from '../../extent/Relationship.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray } from '../../geom/flat/inflate.js';\nimport VectorContext from '../VectorContext.js';\nimport { defaultFillStyle, defaultStrokeStyle, defaultMiterLimit, defaultLineWidth, defaultLineJoin, defaultLineDashOffset, defaultLineDash, defaultLineCap } from '../canvas.js';\nimport CanvasInstruction from './Instruction.js';\n/**\n * @typedef {Object} SerializableInstructions\n * @property {Array<*>} instructions The rendering instructions.\n * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.\n * @property {Array<number>} coordinates The array of all coordinates.\n * @property {!Object<string, import(\"../canvas.js\").TextState>} [textStates] The text states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").FillState>} [fillStates] The fill states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").StrokeState>} [strokeStates] The stroke states (decluttering).\n */\nvar CanvasBuilder = /** @class */ (function (_super) {\n    __extends(CanvasBuilder, _super);\n    /**\n     * @param {number} tolerance Tolerance.\n     * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     */\n    function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n        var _this = _super.call(this) || this;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.tolerance = tolerance;\n        /**\n         * @protected\n         * @const\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        _this.maxExtent = maxExtent;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.pixelRatio = pixelRatio;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.maxLineWidth = 0;\n        /**\n         * @protected\n         * @const\n         * @type {number}\n         */\n        _this.resolution = resolution;\n        /**\n         * @private\n         * @type {Array<*>}\n         */\n        _this.beginGeometryInstruction1_ = null;\n        /**\n         * @private\n         * @type {Array<*>}\n         */\n        _this.beginGeometryInstruction2_ = null;\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        _this.bufferedMaxExtent_ = null;\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        _this.instructions = [];\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n        _this.coordinates = [];\n        /**\n         * @private\n         * @type {import(\"../../coordinate.js\").Coordinate}\n         */\n        _this.tmpCoordinate_ = [];\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        _this.hitDetectionInstructions = [];\n        /**\n         * @protected\n         * @type {import(\"../canvas.js\").FillStrokeState}\n         */\n        _this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */ ({});\n        return _this;\n    }\n    /**\n     * @protected\n     * @param {Array<number>} dashArray Dash array.\n     * @return {Array<number>} Dash array with pixel ratio applied\n     */\n    CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {\n        var pixelRatio = this.pixelRatio;\n        return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n            return dash * pixelRatio;\n        });\n    };\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {boolean} closed Last input coordinate equals first.\n     * @param {boolean} skipFirst Skip first coordinate.\n     * @protected\n     * @return {number} My end.\n     */\n    CanvasBuilder.prototype.appendFlatCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {\n        var myEnd = this.coordinates.length;\n        var extent = this.getBufferedMaxExtent();\n        if (skipFirst) {\n            offset += stride;\n        }\n        var lastXCoord = flatCoordinates[offset];\n        var lastYCoord = flatCoordinates[offset + 1];\n        var nextCoord = this.tmpCoordinate_;\n        var skipped = true;\n        var i, lastRel, nextRel;\n        for (i = offset + stride; i < end; i += stride) {\n            nextCoord[0] = flatCoordinates[i];\n            nextCoord[1] = flatCoordinates[i + 1];\n            nextRel = coordinateRelationship(extent, nextCoord);\n            if (nextRel !== lastRel) {\n                if (skipped) {\n                    this.coordinates[myEnd++] = lastXCoord;\n                    this.coordinates[myEnd++] = lastYCoord;\n                }\n                this.coordinates[myEnd++] = nextCoord[0];\n                this.coordinates[myEnd++] = nextCoord[1];\n                skipped = false;\n            }\n            else if (nextRel === Relationship.INTERSECTING) {\n                this.coordinates[myEnd++] = nextCoord[0];\n                this.coordinates[myEnd++] = nextCoord[1];\n                skipped = false;\n            }\n            else {\n                skipped = true;\n            }\n            lastXCoord = nextCoord[0];\n            lastYCoord = nextCoord[1];\n            lastRel = nextRel;\n        }\n        // Last coordinate equals first or only one point to append:\n        if ((closed && skipped) || i === offset + stride) {\n            this.coordinates[myEnd++] = lastXCoord;\n            this.coordinates[myEnd++] = lastYCoord;\n        }\n        return myEnd;\n    };\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {Array<number>} builderEnds Builder ends.\n     * @return {number} Offset.\n     */\n    CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var builderEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n            builderEnds.push(builderEnd);\n            offset = end;\n        }\n        return offset;\n    };\n    /**\n     * @inheritDoc.\n     */\n    CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer) {\n        this.beginGeometry(geometry, feature);\n        var type = geometry.getType();\n        var stride = geometry.getStride();\n        var builderBegin = this.coordinates.length;\n        var flatCoordinates, builderEnd, builderEnds, builderEndss;\n        var offset;\n        if (type == GeometryType.MULTI_POLYGON) {\n            geometry = /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (geometry);\n            flatCoordinates = geometry.getOrientedFlatCoordinates();\n            builderEndss = [];\n            var endss = geometry.getEndss();\n            offset = 0;\n            for (var i = 0, ii = endss.length; i < ii; ++i) {\n                var myEnds = [];\n                offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n                builderEndss.push(myEnds);\n            }\n            this.instructions.push([CanvasInstruction.CUSTOM,\n                builderBegin, builderEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n        }\n        else if (type == GeometryType.POLYGON || type == GeometryType.MULTI_LINE_STRING) {\n            builderEnds = [];\n            flatCoordinates = (type == GeometryType.POLYGON) ?\n                /** @type {import(\"../../geom/Polygon.js\").default} */ (geometry).getOrientedFlatCoordinates() :\n                geometry.getFlatCoordinates();\n            offset = this.drawCustomCoordinates_(flatCoordinates, 0, \n            /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */ (geometry).getEnds(), stride, builderEnds);\n            this.instructions.push([CanvasInstruction.CUSTOM,\n                builderBegin, builderEnds, geometry, renderer, inflateCoordinatesArray]);\n        }\n        else if (type == GeometryType.LINE_STRING || type == GeometryType.MULTI_POINT) {\n            flatCoordinates = geometry.getFlatCoordinates();\n            builderEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n            this.instructions.push([CanvasInstruction.CUSTOM,\n                builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n        }\n        else if (type == GeometryType.POINT) {\n            flatCoordinates = geometry.getFlatCoordinates();\n            this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n            builderEnd = this.coordinates.length;\n            this.instructions.push([CanvasInstruction.CUSTOM,\n                builderBegin, builderEnd, geometry, renderer]);\n        }\n        this.endGeometry(feature);\n    };\n    /**\n     * @protected\n     * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n    CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {\n        var extent = geometry.getExtent();\n        this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, extent];\n        this.instructions.push(this.beginGeometryInstruction1_);\n        this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, extent];\n        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n    };\n    /**\n     * @return {SerializableInstructions} the serializable instructions.\n     */\n    CanvasBuilder.prototype.finish = function () {\n        return {\n            instructions: this.instructions,\n            hitDetectionInstructions: this.hitDetectionInstructions,\n            coordinates: this.coordinates\n        };\n    };\n    /**\n     * Reverse the hit detection instructions.\n     */\n    CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {\n        var hitDetectionInstructions = this.hitDetectionInstructions;\n        // step 1 - reverse array\n        hitDetectionInstructions.reverse();\n        // step 2 - reverse instructions within geometry blocks\n        var i;\n        var n = hitDetectionInstructions.length;\n        var instruction;\n        var type;\n        var begin = -1;\n        for (i = 0; i < n; ++i) {\n            instruction = hitDetectionInstructions[i];\n            type = /** @type {CanvasInstruction} */ (instruction[0]);\n            if (type == CanvasInstruction.END_GEOMETRY) {\n                begin = i;\n            }\n            else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n                instruction[2] = i;\n                reverseSubArray(this.hitDetectionInstructions, begin, i);\n                begin = -1;\n            }\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {\n        var state = this.state;\n        if (fillStyle) {\n            var fillStyleColor = fillStyle.getColor();\n            state.fillStyle = asColorLike(fillStyleColor ?\n                fillStyleColor : defaultFillStyle);\n        }\n        else {\n            state.fillStyle = undefined;\n        }\n        if (strokeStyle) {\n            var strokeStyleColor = strokeStyle.getColor();\n            state.strokeStyle = asColorLike(strokeStyleColor ?\n                strokeStyleColor : defaultStrokeStyle);\n            var strokeStyleLineCap = strokeStyle.getLineCap();\n            state.lineCap = strokeStyleLineCap !== undefined ?\n                strokeStyleLineCap : defaultLineCap;\n            var strokeStyleLineDash = strokeStyle.getLineDash();\n            state.lineDash = strokeStyleLineDash ?\n                strokeStyleLineDash.slice() : defaultLineDash;\n            var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n            state.lineDashOffset = strokeStyleLineDashOffset ?\n                strokeStyleLineDashOffset : defaultLineDashOffset;\n            var strokeStyleLineJoin = strokeStyle.getLineJoin();\n            state.lineJoin = strokeStyleLineJoin !== undefined ?\n                strokeStyleLineJoin : defaultLineJoin;\n            var strokeStyleWidth = strokeStyle.getWidth();\n            state.lineWidth = strokeStyleWidth !== undefined ?\n                strokeStyleWidth : defaultLineWidth;\n            var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n            state.miterLimit = strokeStyleMiterLimit !== undefined ?\n                strokeStyleMiterLimit : defaultMiterLimit;\n            if (state.lineWidth > this.maxLineWidth) {\n                this.maxLineWidth = state.lineWidth;\n                // invalidate the buffered max extent cache\n                this.bufferedMaxExtent_ = null;\n            }\n        }\n        else {\n            state.strokeStyle = undefined;\n            state.lineCap = undefined;\n            state.lineDash = null;\n            state.lineDashOffset = undefined;\n            state.lineJoin = undefined;\n            state.lineWidth = undefined;\n            state.miterLimit = undefined;\n        }\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @return {Array<*>} Fill instruction.\n     */\n    CanvasBuilder.prototype.createFill = function (state) {\n        var fillStyle = state.fillStyle;\n        /** @type {Array<*>} */\n        var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n        if (typeof fillStyle !== 'string') {\n            // Fill is a pattern or gradient - align it!\n            fillInstruction.push(true);\n        }\n        return fillInstruction;\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     */\n    CanvasBuilder.prototype.applyStroke = function (state) {\n        this.instructions.push(this.createStroke(state));\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @return {Array<*>} Stroke instruction.\n     */\n    CanvasBuilder.prototype.createStroke = function (state) {\n        return [\n            CanvasInstruction.SET_STROKE_STYLE,\n            state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap,\n            state.lineJoin, state.miterLimit,\n            this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio\n        ];\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n     */\n    CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {\n        var fillStyle = state.fillStyle;\n        if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n            if (fillStyle !== undefined) {\n                this.instructions.push(createFill.call(this, state));\n            }\n            state.currentFillStyle = fillStyle;\n        }\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n     */\n    CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {\n        var strokeStyle = state.strokeStyle;\n        var lineCap = state.lineCap;\n        var lineDash = state.lineDash;\n        var lineDashOffset = state.lineDashOffset;\n        var lineJoin = state.lineJoin;\n        var lineWidth = state.lineWidth;\n        var miterLimit = state.miterLimit;\n        if (state.currentStrokeStyle != strokeStyle ||\n            state.currentLineCap != lineCap ||\n            (lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash)) ||\n            state.currentLineDashOffset != lineDashOffset ||\n            state.currentLineJoin != lineJoin ||\n            state.currentLineWidth != lineWidth ||\n            state.currentMiterLimit != miterLimit) {\n            if (strokeStyle !== undefined) {\n                applyStroke.call(this, state);\n            }\n            state.currentStrokeStyle = strokeStyle;\n            state.currentLineCap = lineCap;\n            state.currentLineDash = lineDash;\n            state.currentLineDashOffset = lineDashOffset;\n            state.currentLineJoin = lineJoin;\n            state.currentLineWidth = lineWidth;\n            state.currentMiterLimit = miterLimit;\n        }\n    };\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n    CanvasBuilder.prototype.endGeometry = function (feature) {\n        this.beginGeometryInstruction1_[2] = this.instructions.length;\n        this.beginGeometryInstruction1_ = null;\n        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n        this.beginGeometryInstruction2_ = null;\n        var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n        this.instructions.push(endGeometryInstruction);\n        this.hitDetectionInstructions.push(endGeometryInstruction);\n    };\n    /**\n     * Get the buffered rendering extent.  Rendering will be clipped to the extent\n     * provided to the constructor.  To account for symbolizers that may intersect\n     * this extent, we calculate a buffered extent (e.g. based on stroke width).\n     * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n     * @protected\n     */\n    CanvasBuilder.prototype.getBufferedMaxExtent = function () {\n        if (!this.bufferedMaxExtent_) {\n            this.bufferedMaxExtent_ = clone(this.maxExtent);\n            if (this.maxLineWidth > 0) {\n                var width = this.resolution * (this.maxLineWidth + 1) / 2;\n                buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n            }\n        }\n        return this.bufferedMaxExtent_;\n    };\n    return CanvasBuilder;\n}(VectorContext));\nexport default CanvasBuilder;\n//# sourceMappingURL=Builder.js.map"]},"metadata":{},"sourceType":"module"}