{"ast":null,"code":"/**\n * @module ol/geom/flat/interpolate\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Destination.\n */\n\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n  var pointX = NaN;\n  var pointY = NaN;\n  var n = (end - offset) / stride;\n\n  if (n === 1) {\n    pointX = flatCoordinates[offset];\n    pointY = flatCoordinates[offset + 1];\n  } else if (n == 2) {\n    pointX = (1 - fraction) * flatCoordinates[offset] + fraction * flatCoordinates[offset + stride];\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] + fraction * flatCoordinates[offset + stride + 1];\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length_1 = 0;\n    var cumulativeLengths = [0];\n\n    for (var i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length_1);\n      x1 = x2;\n      y1 = y2;\n    }\n\n    var target = fraction * length_1;\n    var index = binarySearch(cumulativeLengths, target);\n\n    if (index < 0) {\n      var t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      var o = offset + (-index - 2) * stride;\n      pointX = lerp(flatCoordinates[o], flatCoordinates[o + stride], t);\n      pointY = lerp(flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n    } else {\n      pointX = flatCoordinates[offset + index * stride];\n      pointY = flatCoordinates[offset + index * stride + 1];\n    }\n  }\n\n  if (opt_dest) {\n    opt_dest[0] = pointX;\n    opt_dest[1] = pointY;\n    return opt_dest;\n  } else {\n    return [pointX, pointY];\n  }\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\n\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n\n  var coordinate;\n\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } // FIXME use O(1) search\n\n\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n\n  var lo = offset / stride;\n  var hi = end / stride;\n\n  while (lo < hi) {\n    var mid = lo + hi >> 1;\n\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n\n  var m0 = flatCoordinates[lo * stride - 1];\n\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n\n  for (var i = 0; i < stride - 1; ++i) {\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n  }\n\n  coordinate.push(m);\n  return coordinate;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\n\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n\n  var coordinate;\n\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n\n    if (offset == end) {\n      continue;\n    }\n\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n    }\n\n    offset = end;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../../src/geom/flat/interpolate.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/geom/flat/interpolate\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n    var pointX = NaN;\n    var pointY = NaN;\n    var n = (end - offset) / stride;\n    if (n === 1) {\n        pointX = flatCoordinates[offset];\n        pointY = flatCoordinates[offset + 1];\n    }\n    else if (n == 2) {\n        pointX = (1 - fraction) * flatCoordinates[offset] +\n            fraction * flatCoordinates[offset + stride];\n        pointY = (1 - fraction) * flatCoordinates[offset + 1] +\n            fraction * flatCoordinates[offset + stride + 1];\n    }\n    else if (n !== 0) {\n        var x1 = flatCoordinates[offset];\n        var y1 = flatCoordinates[offset + 1];\n        var length_1 = 0;\n        var cumulativeLengths = [0];\n        for (var i = offset + stride; i < end; i += stride) {\n            var x2 = flatCoordinates[i];\n            var y2 = flatCoordinates[i + 1];\n            length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n            cumulativeLengths.push(length_1);\n            x1 = x2;\n            y1 = y2;\n        }\n        var target = fraction * length_1;\n        var index = binarySearch(cumulativeLengths, target);\n        if (index < 0) {\n            var t = (target - cumulativeLengths[-index - 2]) /\n                (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n            var o = offset + (-index - 2) * stride;\n            pointX = lerp(flatCoordinates[o], flatCoordinates[o + stride], t);\n            pointY = lerp(flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n        }\n        else {\n            pointX = flatCoordinates[offset + index * stride];\n            pointY = flatCoordinates[offset + index * stride + 1];\n        }\n    }\n    if (opt_dest) {\n        opt_dest[0] = pointX;\n        opt_dest[1] = pointY;\n        return opt_dest;\n    }\n    else {\n        return [pointX, pointY];\n    }\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n    if (end == offset) {\n        return null;\n    }\n    var coordinate;\n    if (m < flatCoordinates[offset + stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(offset, offset + stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    else if (flatCoordinates[end - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(end - stride, end);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    // FIXME use O(1) search\n    if (m == flatCoordinates[offset + stride - 1]) {\n        return flatCoordinates.slice(offset, offset + stride);\n    }\n    var lo = offset / stride;\n    var hi = end / stride;\n    while (lo < hi) {\n        var mid = (lo + hi) >> 1;\n        if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n            hi = mid;\n        }\n        else {\n            lo = mid + 1;\n        }\n    }\n    var m0 = flatCoordinates[lo * stride - 1];\n    if (m == m0) {\n        return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n    }\n    var m1 = flatCoordinates[(lo + 1) * stride - 1];\n    var t = (m - m0) / (m1 - m0);\n    coordinate = [];\n    for (var i = 0; i < stride - 1; ++i) {\n        coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n    }\n    coordinate.push(m);\n    return coordinate;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n    if (interpolate) {\n        return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n    }\n    var coordinate;\n    if (m < flatCoordinates[stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(0, stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    if (flatCoordinates[flatCoordinates.length - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        if (offset == end) {\n            continue;\n        }\n        if (m < flatCoordinates[offset + stride - 1]) {\n            return null;\n        }\n        else if (m <= flatCoordinates[end - 1]) {\n            return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n        }\n        offset = end;\n    }\n    return null;\n}\n//# sourceMappingURL=interpolate.js.map"]},"metadata":{},"sourceType":"module"}