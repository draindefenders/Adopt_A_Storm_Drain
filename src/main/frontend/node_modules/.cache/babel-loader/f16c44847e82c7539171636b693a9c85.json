{"ast":null,"code":"/**\n * @module ol/resolutionconstraint\n */\nimport { linearFindNearest } from './array.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { clamp } from './math.js';\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent=} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\n\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n  var xResolution = getWidth(maxExtent) / viewportSize[0];\n  var yResolution = getHeight(maxExtent) / viewportSize[1];\n\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\n\n\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  var result = Math.min(resolution, maxResolution);\n  var ratio = 50;\n  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;\n\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;\n  }\n\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent=} opt_maxExtent Maximum allowed extent.\n * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\n\n\nexport function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        var maxResolution = resolutions[0];\n        var minResolution = resolutions[resolutions.length - 1];\n        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution; // during interacting or animating, allow intermediary values\n\n        if (opt_isMoving) {\n          var smooth = opt_smooth !== undefined ? opt_smooth : true;\n\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n\n        var capped = Math.min(cappedMaxRes, resolution);\n        var z = Math.floor(linearFindNearest(resolutions, capped, direction));\n\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n\n        return resolutions[z];\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number=} opt_minResolution Minimum resolution.\n * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent=} opt_maxExtent Maximum allowed extent.\n * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\n\nexport function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n        var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0; // during interacting or animating, allow intermediary values\n\n        if (opt_isMoving) {\n          var smooth = opt_smooth !== undefined ? opt_smooth : true;\n\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n\n        var tolerance = 1e-9;\n        var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n        var offset = -direction * (0.5 - tolerance) + 0.5;\n        var capped = Math.min(cappedMaxRes, resolution);\n        var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n        var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        var newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent=} opt_maxExtent Maximum allowed extent.\n * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\n\nexport function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n        var smooth = opt_smooth !== undefined ? opt_smooth : true;\n\n        if (!smooth || !opt_isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n\n        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}","map":{"version":3,"sources":["src/resolutionconstraint.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/resolutionconstraint\n */\nimport { linearFindNearest } from './array.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { clamp } from './math.js';\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent=} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n    var xResolution = getWidth(maxExtent) / viewportSize[0];\n    var yResolution = getHeight(maxExtent) / viewportSize[1];\n    if (showFullExtent) {\n        return Math.min(resolution, Math.max(xResolution, yResolution));\n    }\n    return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n    var result = Math.min(resolution, maxResolution);\n    var ratio = 50;\n    result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;\n    if (minResolution) {\n        result = Math.max(result, minResolution);\n        result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;\n    }\n    return clamp(result, minResolution / 2, maxResolution * 2);\n}\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent=} opt_maxExtent Maximum allowed extent.\n * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var maxResolution = resolutions[0];\n            var minResolution = resolutions[resolutions.length - 1];\n            var cappedMaxRes = opt_maxExtent ?\n                getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) :\n                maxResolution;\n            // during interacting or animating, allow intermediary values\n            if (opt_isMoving) {\n                var smooth = opt_smooth !== undefined ? opt_smooth : true;\n                if (!smooth) {\n                    return clamp(resolution, minResolution, cappedMaxRes);\n                }\n                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n            }\n            var capped = Math.min(cappedMaxRes, resolution);\n            var z = Math.floor(linearFindNearest(resolutions, capped, direction));\n            if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n                return resolutions[z + 1];\n            }\n            return resolutions[z];\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number=} opt_minResolution Minimum resolution.\n * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent=} opt_maxExtent Maximum allowed extent.\n * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var cappedMaxRes = opt_maxExtent ?\n                getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) :\n                maxResolution;\n            var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;\n            // during interacting or animating, allow intermediary values\n            if (opt_isMoving) {\n                var smooth = opt_smooth !== undefined ? opt_smooth : true;\n                if (!smooth) {\n                    return clamp(resolution, minResolution, cappedMaxRes);\n                }\n                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n            }\n            var tolerance = 1e-9;\n            var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n            var offset = -direction * (0.5 - tolerance) + 0.5;\n            var capped = Math.min(cappedMaxRes, resolution);\n            var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n            var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n            var newResolution = maxResolution / Math.pow(power, zoomLevel);\n            return clamp(newResolution, minResolution, cappedMaxRes);\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent=} opt_maxExtent Maximum allowed extent.\n * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var cappedMaxRes = opt_maxExtent ?\n                getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) :\n                maxResolution;\n            var smooth = opt_smooth !== undefined ? opt_smooth : true;\n            if (!smooth || !opt_isMoving) {\n                return clamp(resolution, minResolution, cappedMaxRes);\n            }\n            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n//# sourceMappingURL=resolutionconstraint.js.map"]},"metadata":{},"sourceType":"module"}