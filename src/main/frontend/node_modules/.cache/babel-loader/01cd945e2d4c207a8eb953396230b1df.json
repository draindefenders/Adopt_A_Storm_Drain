{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/ImageLayer\n */\n\n\nimport { ENABLE_RASTER_REPROJECTION } from '../../reproj/common.js';\nimport ViewHint from '../../ViewHint.js';\nimport { containsExtent, intersects } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getIntersection, isEmpty } from '../../extent.js';\nimport CanvasLayerRenderer from './Layer.js';\nimport { compose as composeTransform, makeInverse } from '../../transform.js';\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\n\nvar CanvasImageLayerRenderer =\n/** @class */\nfunction (_super) {\n  __extends(CanvasImageLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n\n\n  function CanvasImageLayerRenderer(imageLayer) {\n    var _this = _super.call(this, imageLayer) || this;\n    /**\n     * @protected\n     * @type {?import(\"../../ImageBase.js\").default}\n     */\n\n\n    _this.image_ = null;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasImageLayerRenderer.prototype.getImage = function () {\n    return !this.image_ ? null : this.image_.getImage();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasImageLayerRenderer.prototype.prepareFrame = function (frameState) {\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var viewResolution = viewState.resolution;\n    var imageSource = this.getLayer().getSource();\n    var hints = frameState.viewHints;\n    var renderedExtent = frameState.extent;\n\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));\n    }\n\n    if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !isEmpty(renderedExtent)) {\n      var projection = viewState.projection;\n\n      if (!ENABLE_RASTER_REPROJECTION) {\n        var sourceProjection = imageSource.getProjection();\n\n        if (sourceProjection) {\n          projection = sourceProjection;\n        }\n      }\n\n      var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);\n\n      if (image && this.loadImage(image)) {\n        this.image_ = image;\n      }\n    }\n\n    return !!this.image_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasImageLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var image = this.image_;\n    var imageExtent = image.getExtent();\n    var imageResolution = image.getResolution();\n    var imagePixelRatio = image.getPixelRatio();\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var viewCenter = viewState.center;\n    var viewResolution = viewState.resolution;\n    var size = frameState.size;\n    var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);\n    var width = Math.round(size[0] * pixelRatio);\n    var height = Math.round(size[1] * pixelRatio);\n    var rotation = viewState.rotation;\n\n    if (rotation) {\n      var size_1 = Math.round(Math.sqrt(width * width + height * height));\n      width = size_1;\n      height = size_1;\n    } // set forward and inverse pixel transforms\n\n\n    composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n    var canvasTransform = this.createTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, layerState.opacity);\n    var context = this.context;\n    var canvas = context.canvas;\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    } // clipped rendering if layer extent is set\n\n\n    var clipped = false;\n\n    if (layerState.extent) {\n      var layerExtent = fromUserExtent(layerState.extent, viewState.projection);\n      clipped = !containsExtent(layerExtent, frameState.extent) && intersects(layerExtent, frameState.extent);\n\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    var img = image.getImage();\n    var transform = composeTransform(this.tempTransform_, width / 2, height / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);\n    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;\n    var dx = transform[4];\n    var dy = transform[5];\n    var dw = img.width * transform[0];\n    var dh = img.height * transform[3];\n    this.preRender(context, frameState);\n\n    if (dw >= 0.5 && dh >= 0.5) {\n      var opacity = layerState.opacity;\n      var previousAlpha = void 0;\n\n      if (opacity !== 1) {\n        previousAlpha = this.context.globalAlpha;\n        this.context.globalAlpha = opacity;\n      }\n\n      this.context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n\n      if (opacity !== 1) {\n        this.context.globalAlpha = previousAlpha;\n      }\n    }\n\n    this.postRender(context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  };\n\n  return CanvasImageLayerRenderer;\n}(CanvasLayerRenderer);\n\nexport default CanvasImageLayerRenderer;","map":{"version":3,"sources":["../../src/renderer/canvas/ImageLayer.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAGA,SAAQ,0BAAR,QAAyC,wBAAzC;AACA,OAAO,QAAP,MAAqB,mBAArB;AACA,SAAQ,cAAR,EAAwB,UAAxB,QAAyC,iBAAzC;AACA,SAAQ,cAAR,QAA6B,eAA7B;AACA,SAAQ,eAAR,EAAyB,OAAzB,QAAuC,iBAAvC;AACA,OAAO,mBAAP,MAAgC,YAAhC;AACA,SAAQ,OAAO,IAAI,gBAAnB,EAAqC,WAArC,QAAuD,oBAAvD;AAEA;;;;;;AAKA,IAAA,wBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAuC,EAAA,SAAA,CAAA,wBAAA,EAAA,MAAA,CAAA;AAErC;;;;;AAGA,WAAA,wBAAA,CAAY,UAAZ,EAAsB;AAAtB,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,UAAN,KAAiB,IADnB;AAGE;;;;;;AAIA,IAAA,KAAI,CAAC,MAAL,GAAc,IAAd;;AACD;AAED;;;;;AAGA,EAAA,wBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,WAAO,CAAC,KAAK,MAAN,GAAe,IAAf,GAAsB,KAAK,MAAL,CAAY,QAAZ,EAA7B;AACD,GAFD;AAIA;;;;;AAGA,EAAA,wBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,UAAb,EAAuB;AACrB,QAAM,UAAU,GAAG,UAAU,CAAC,gBAAX,CAA4B,UAAU,CAAC,UAAvC,CAAnB;AACA,QAAM,UAAU,GAAG,UAAU,CAAC,UAA9B;AACA,QAAM,SAAS,GAAG,UAAU,CAAC,SAA7B;AACA,QAAM,cAAc,GAAG,SAAS,CAAC,UAAjC;AAEA,QAAM,WAAW,GAAG,KAAK,QAAL,GAAgB,SAAhB,EAApB;AAEA,QAAM,KAAK,GAAG,UAAU,CAAC,SAAzB;AAEA,QAAI,cAAc,GAAG,UAAU,CAAC,MAAhC;;AACA,QAAI,UAAU,CAAC,MAAX,KAAsB,SAA1B,EAAqC;AACnC,MAAA,cAAc,GAAG,eAAe,CAAC,cAAD,EAAiB,cAAc,CAAC,UAAU,CAAC,MAAZ,EAAoB,SAAS,CAAC,UAA9B,CAA/B,CAAhC;AACD;;AAED,QAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,SAAV,CAAN,IAA8B,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAV,CAApC,IAA8D,CAAC,OAAO,CAAC,cAAD,CAA1E,EAA4F;AAC1F,UAAI,UAAU,GAAG,SAAS,CAAC,UAA3B;;AACA,UAAI,CAAC,0BAAL,EAAiC;AAC/B,YAAM,gBAAgB,GAAG,WAAW,CAAC,aAAZ,EAAzB;;AACA,YAAI,gBAAJ,EAAsB;AACpB,UAAA,UAAU,GAAG,gBAAb;AACD;AACF;;AACD,UAAM,KAAK,GAAG,WAAW,CAAC,QAAZ,CAAqB,cAArB,EAAqC,cAArC,EAAqD,UAArD,EAAiE,UAAjE,CAAd;;AACA,UAAI,KAAK,IAAI,KAAK,SAAL,CAAe,KAAf,CAAb,EAAoC;AAClC,aAAK,MAAL,GAAc,KAAd;AACD;AACF;;AAED,WAAO,CAAC,CAAC,KAAK,MAAd;AACD,GA9BD;AAgCA;;;;;AAGA,EAAA,wBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,UAAZ,EAAwB,MAAxB,EAA8B;AAC5B,QAAM,KAAK,GAAG,KAAK,MAAnB;AACA,QAAM,WAAW,GAAG,KAAK,CAAC,SAAN,EAApB;AACA,QAAM,eAAe,GAAG,KAAK,CAAC,aAAN,EAAxB;AACA,QAAM,eAAe,GAAG,KAAK,CAAC,aAAN,EAAxB;AACA,QAAM,UAAU,GAAG,UAAU,CAAC,gBAAX,CAA4B,UAAU,CAAC,UAAvC,CAAnB;AACA,QAAM,UAAU,GAAG,UAAU,CAAC,UAA9B;AACA,QAAM,SAAS,GAAG,UAAU,CAAC,SAA7B;AACA,QAAM,UAAU,GAAG,SAAS,CAAC,MAA7B;AACA,QAAM,cAAc,GAAG,SAAS,CAAC,UAAjC;AACA,QAAM,IAAI,GAAG,UAAU,CAAC,IAAxB;AACA,QAAM,KAAK,GAAG,UAAU,GAAG,eAAb,IAAgC,cAAc,GAAG,eAAjD,CAAd;AAEA,QAAI,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,CAAD,CAAJ,GAAU,UAArB,CAAZ;AACA,QAAI,MAAM,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,CAAD,CAAJ,GAAU,UAArB,CAAb;AACA,QAAM,QAAQ,GAAG,SAAS,CAAC,QAA3B;;AACA,QAAI,QAAJ,EAAc;AACZ,UAAM,MAAI,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,IAAL,CAAU,KAAK,GAAG,KAAR,GAAgB,MAAM,GAAG,MAAnC,CAAX,CAAb;AACA,MAAA,KAAK,GAAG,MAAR;AACA,MAAA,MAAM,GAAG,MAAT;AACD,KApB2B,CAsB5B;;;AACA,IAAA,gBAAgB,CAAC,KAAK,cAAN,EACd,UAAU,CAAC,IAAX,CAAgB,CAAhB,IAAqB,CADP,EACU,UAAU,CAAC,IAAX,CAAgB,CAAhB,IAAqB,CAD/B,EAEd,IAAI,UAFU,EAEE,IAAI,UAFN,EAGd,QAHc,EAId,CAAC,KAAD,GAAS,CAJK,EAIF,CAAC,MAAD,GAAU,CAJR,CAAhB;AAMA,IAAA,WAAW,CAAC,KAAK,qBAAN,EAA6B,KAAK,cAAlC,CAAX;AAEA,QAAM,eAAe,GAAG,KAAK,qBAAL,CAA2B,KAAK,cAAhC,CAAxB;AAEA,SAAK,YAAL,CAAkB,MAAlB,EAA0B,eAA1B,EAA2C,UAAU,CAAC,OAAtD;AAEA,QAAM,OAAO,GAAG,KAAK,OAArB;AACA,QAAM,MAAM,GAAG,OAAO,CAAC,MAAvB;;AAEA,QAAI,MAAM,CAAC,KAAP,IAAgB,KAAhB,IAAyB,MAAM,CAAC,MAAP,IAAiB,MAA9C,EAAsD;AACpD,MAAA,MAAM,CAAC,KAAP,GAAe,KAAf;AACA,MAAA,MAAM,CAAC,MAAP,GAAgB,MAAhB;AACD,KAHD,MAGO,IAAI,CAAC,KAAK,eAAV,EAA2B;AAChC,MAAA,OAAO,CAAC,SAAR,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,KAAxB,EAA+B,MAA/B;AACD,KA3C2B,CA6C5B;;;AACA,QAAI,OAAO,GAAG,KAAd;;AACA,QAAI,UAAU,CAAC,MAAf,EAAuB;AACrB,UAAM,WAAW,GAAG,cAAc,CAAC,UAAU,CAAC,MAAZ,EAAoB,SAAS,CAAC,UAA9B,CAAlC;AACA,MAAA,OAAO,GAAG,CAAC,cAAc,CAAC,WAAD,EAAc,UAAU,CAAC,MAAzB,CAAf,IAAmD,UAAU,CAAC,WAAD,EAAc,UAAU,CAAC,MAAzB,CAAvE;;AACA,UAAI,OAAJ,EAAa;AACX,aAAK,aAAL,CAAmB,OAAnB,EAA4B,UAA5B,EAAwC,WAAxC;AACD;AACF;;AAED,QAAM,GAAG,GAAG,KAAK,CAAC,QAAN,EAAZ;AAEA,QAAM,SAAS,GAAG,gBAAgB,CAAC,KAAK,cAAN,EAChC,KAAK,GAAG,CADwB,EACrB,MAAM,GAAG,CADY,EAEhC,KAFgC,EAEzB,KAFyB,EAGhC,CAHgC,EAIhC,eAAe,IAAI,WAAW,CAAC,CAAD,CAAX,GAAiB,UAAU,CAAC,CAAD,CAA/B,CAAf,GAAqD,eAJrB,EAKhC,eAAe,IAAI,UAAU,CAAC,CAAD,CAAV,GAAgB,WAAW,CAAC,CAAD,CAA/B,CAAf,GAAqD,eALrB,CAAlC;AAOA,SAAK,kBAAL,GAA0B,eAAe,GAAG,UAAlB,GAA+B,eAAzD;AAEA,QAAM,EAAE,GAAG,SAAS,CAAC,CAAD,CAApB;AACA,QAAM,EAAE,GAAG,SAAS,CAAC,CAAD,CAApB;AACA,QAAM,EAAE,GAAG,GAAG,CAAC,KAAJ,GAAY,SAAS,CAAC,CAAD,CAAhC;AACA,QAAM,EAAE,GAAG,GAAG,CAAC,MAAJ,GAAa,SAAS,CAAC,CAAD,CAAjC;AAEA,SAAK,SAAL,CAAe,OAAf,EAAwB,UAAxB;;AACA,QAAI,EAAE,IAAI,GAAN,IAAa,EAAE,IAAI,GAAvB,EAA4B;AAC1B,UAAM,OAAO,GAAG,UAAU,CAAC,OAA3B;AACA,UAAI,aAAa,GAAA,KAAA,CAAjB;;AACA,UAAI,OAAO,KAAK,CAAhB,EAAmB;AACjB,QAAA,aAAa,GAAG,KAAK,OAAL,CAAa,WAA7B;AACA,aAAK,OAAL,CAAa,WAAb,GAA2B,OAA3B;AACD;;AACD,WAAK,OAAL,CAAa,SAAb,CAAuB,GAAvB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAC,GAAG,CAAC,KAAvC,EAA8C,CAAC,GAAG,CAAC,MAAnD,EACE,IAAI,CAAC,KAAL,CAAW,EAAX,CADF,EACkB,IAAI,CAAC,KAAL,CAAW,EAAX,CADlB,EACkC,IAAI,CAAC,KAAL,CAAW,EAAX,CADlC,EACkD,IAAI,CAAC,KAAL,CAAW,EAAX,CADlD;;AAEA,UAAI,OAAO,KAAK,CAAhB,EAAmB;AACjB,aAAK,OAAL,CAAa,WAAb,GAA2B,aAA3B;AACD;AACF;;AACD,SAAK,UAAL,CAAgB,OAAhB,EAAyB,UAAzB;;AAEA,QAAI,OAAJ,EAAa;AACX,MAAA,OAAO,CAAC,OAAR;AACD;;AAED,QAAI,eAAe,KAAK,MAAM,CAAC,KAAP,CAAa,SAArC,EAAgD;AAC9C,MAAA,MAAM,CAAC,KAAP,CAAa,SAAb,GAAyB,eAAzB;AACD;;AAED,WAAO,KAAK,SAAZ;AAED,GAjGD;;AAmGF,SAAA,wBAAA;AAAC,CA/JD,CAAuC,mBAAvC,CAAA;;AAkKA,eAAe,wBAAf","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport { ENABLE_RASTER_REPROJECTION } from '../../reproj/common.js';\nimport ViewHint from '../../ViewHint.js';\nimport { containsExtent, intersects } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getIntersection, isEmpty } from '../../extent.js';\nimport CanvasLayerRenderer from './Layer.js';\nimport { compose as composeTransform, makeInverse } from '../../transform.js';\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nvar CanvasImageLayerRenderer = /** @class */ (function (_super) {\n    __extends(CanvasImageLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n     */\n    function CanvasImageLayerRenderer(imageLayer) {\n        var _this = _super.call(this, imageLayer) || this;\n        /**\n         * @protected\n         * @type {?import(\"../../ImageBase.js\").default}\n         */\n        _this.image_ = null;\n        return _this;\n    }\n    /**\n     * @inheritDoc\n     */\n    CanvasImageLayerRenderer.prototype.getImage = function () {\n        return !this.image_ ? null : this.image_.getImage();\n    };\n    /**\n     * @inheritDoc\n     */\n    CanvasImageLayerRenderer.prototype.prepareFrame = function (frameState) {\n        var layerState = frameState.layerStatesArray[frameState.layerIndex];\n        var pixelRatio = frameState.pixelRatio;\n        var viewState = frameState.viewState;\n        var viewResolution = viewState.resolution;\n        var imageSource = this.getLayer().getSource();\n        var hints = frameState.viewHints;\n        var renderedExtent = frameState.extent;\n        if (layerState.extent !== undefined) {\n            renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));\n        }\n        if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !isEmpty(renderedExtent)) {\n            var projection = viewState.projection;\n            if (!ENABLE_RASTER_REPROJECTION) {\n                var sourceProjection = imageSource.getProjection();\n                if (sourceProjection) {\n                    projection = sourceProjection;\n                }\n            }\n            var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);\n            if (image && this.loadImage(image)) {\n                this.image_ = image;\n            }\n        }\n        return !!this.image_;\n    };\n    /**\n     * @inheritDoc\n     */\n    CanvasImageLayerRenderer.prototype.renderFrame = function (frameState, target) {\n        var image = this.image_;\n        var imageExtent = image.getExtent();\n        var imageResolution = image.getResolution();\n        var imagePixelRatio = image.getPixelRatio();\n        var layerState = frameState.layerStatesArray[frameState.layerIndex];\n        var pixelRatio = frameState.pixelRatio;\n        var viewState = frameState.viewState;\n        var viewCenter = viewState.center;\n        var viewResolution = viewState.resolution;\n        var size = frameState.size;\n        var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);\n        var width = Math.round(size[0] * pixelRatio);\n        var height = Math.round(size[1] * pixelRatio);\n        var rotation = viewState.rotation;\n        if (rotation) {\n            var size_1 = Math.round(Math.sqrt(width * width + height * height));\n            width = size_1;\n            height = size_1;\n        }\n        // set forward and inverse pixel transforms\n        composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n        makeInverse(this.inversePixelTransform, this.pixelTransform);\n        var canvasTransform = this.createTransformString(this.pixelTransform);\n        this.useContainer(target, canvasTransform, layerState.opacity);\n        var context = this.context;\n        var canvas = context.canvas;\n        if (canvas.width != width || canvas.height != height) {\n            canvas.width = width;\n            canvas.height = height;\n        }\n        else if (!this.containerReused) {\n            context.clearRect(0, 0, width, height);\n        }\n        // clipped rendering if layer extent is set\n        var clipped = false;\n        if (layerState.extent) {\n            var layerExtent = fromUserExtent(layerState.extent, viewState.projection);\n            clipped = !containsExtent(layerExtent, frameState.extent) && intersects(layerExtent, frameState.extent);\n            if (clipped) {\n                this.clipUnrotated(context, frameState, layerExtent);\n            }\n        }\n        var img = image.getImage();\n        var transform = composeTransform(this.tempTransform_, width / 2, height / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);\n        this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;\n        var dx = transform[4];\n        var dy = transform[5];\n        var dw = img.width * transform[0];\n        var dh = img.height * transform[3];\n        this.preRender(context, frameState);\n        if (dw >= 0.5 && dh >= 0.5) {\n            var opacity = layerState.opacity;\n            var previousAlpha = void 0;\n            if (opacity !== 1) {\n                previousAlpha = this.context.globalAlpha;\n                this.context.globalAlpha = opacity;\n            }\n            this.context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n            if (opacity !== 1) {\n                this.context.globalAlpha = previousAlpha;\n            }\n        }\n        this.postRender(context, frameState);\n        if (clipped) {\n            context.restore();\n        }\n        if (canvasTransform !== canvas.style.transform) {\n            canvas.style.transform = canvasTransform;\n        }\n        return this.container;\n    };\n    return CanvasImageLayerRenderer;\n}(CanvasLayerRenderer));\nexport default CanvasImageLayerRenderer;\n//# sourceMappingURL=ImageLayer.js.map"]},"metadata":{},"sourceType":"module"}