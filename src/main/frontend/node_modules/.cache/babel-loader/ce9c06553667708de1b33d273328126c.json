{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/format/WKT\n */\n\n\nimport Feature from '../Feature.js';\nimport { transformGeometryWithOptions } from './Feature.js';\nimport TextFeature from './TextFeature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\n/**\n * Geometry constructors\n * @enum {function (new:import(\"../geom/Geometry.js\").default, Array, GeometryLayout)}\n */\n\nvar GeometryConstructor = {\n  'POINT': Point,\n  'LINESTRING': LineString,\n  'POLYGON': Polygon,\n  'MULTIPOINT': MultiPoint,\n  'MULTILINESTRING': MultiLineString,\n  'MULTIPOLYGON': MultiPolygon\n};\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n\n/**\n * @typedef {Object} Token\n * @property {number} type\n * @property {number|string} [value]\n * @property {number} position\n */\n\n/**\n * @const\n * @type {string}\n */\n\nvar EMPTY = 'EMPTY';\n/**\n * @const\n * @type {string}\n */\n\nvar Z = 'Z';\n/**\n * @const\n * @type {string}\n */\n\nvar M = 'M';\n/**\n * @const\n * @type {string}\n */\n\nvar ZM = 'ZM';\n/**\n * @const\n * @enum {number}\n */\n\nvar TokenType = {\n  TEXT: 1,\n  LEFT_PAREN: 2,\n  RIGHT_PAREN: 3,\n  NUMBER: 4,\n  COMMA: 5,\n  EOF: 6\n};\n/**\n * @const\n * @type {Object<string, string>}\n */\n\nvar WKTGeometryType = {};\n\nfor (var type in GeometryType) {\n  WKTGeometryType[type] = GeometryType[type].toUpperCase();\n}\n/**\n * Class to tokenize a WKT string.\n */\n\n\nvar Lexer =\n/** @class */\nfunction () {\n  /**\n   * @param {string} wkt WKT string.\n   */\n  function Lexer(wkt) {\n    /**\n     * @type {string}\n     */\n    this.wkt = wkt;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.index_ = -1;\n  }\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is alphabetic.\n   * @private\n   */\n\n\n  Lexer.prototype.isAlpha_ = function (c) {\n    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';\n  };\n  /**\n   * @param {string} c Character.\n   * @param {boolean=} opt_decimal Whether the string number\n   *     contains a dot, i.e. is a decimal number.\n   * @return {boolean} Whether the character is numeric.\n   * @private\n   */\n\n\n  Lexer.prototype.isNumeric_ = function (c, opt_decimal) {\n    var decimal = opt_decimal !== undefined ? opt_decimal : false;\n    return c >= '0' && c <= '9' || c == '.' && !decimal;\n  };\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is whitespace.\n   * @private\n   */\n\n\n  Lexer.prototype.isWhiteSpace_ = function (c) {\n    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n  };\n  /**\n   * @return {string} Next string character.\n   * @private\n   */\n\n\n  Lexer.prototype.nextChar_ = function () {\n    return this.wkt.charAt(++this.index_);\n  };\n  /**\n   * Fetch and return the next token.\n   * @return {!Token} Next string token.\n   */\n\n\n  Lexer.prototype.nextToken = function () {\n    var c = this.nextChar_();\n    var position = this.index_;\n    /** @type {number|string} */\n\n    var value = c;\n    var type;\n\n    if (c == '(') {\n      type = TokenType.LEFT_PAREN;\n    } else if (c == ',') {\n      type = TokenType.COMMA;\n    } else if (c == ')') {\n      type = TokenType.RIGHT_PAREN;\n    } else if (this.isNumeric_(c) || c == '-') {\n      type = TokenType.NUMBER;\n      value = this.readNumber_();\n    } else if (this.isAlpha_(c)) {\n      type = TokenType.TEXT;\n      value = this.readText_();\n    } else if (this.isWhiteSpace_(c)) {\n      return this.nextToken();\n    } else if (c === '') {\n      type = TokenType.EOF;\n    } else {\n      throw new Error('Unexpected character: ' + c);\n    }\n\n    return {\n      position: position,\n      value: value,\n      type: type\n    };\n  };\n  /**\n   * @return {number} Numeric token value.\n   * @private\n   */\n\n\n  Lexer.prototype.readNumber_ = function () {\n    var c;\n    var index = this.index_;\n    var decimal = false;\n    var scientificNotation = false;\n\n    do {\n      if (c == '.') {\n        decimal = true;\n      } else if (c == 'e' || c == 'E') {\n        scientificNotation = true;\n      }\n\n      c = this.nextChar_();\n    } while (this.isNumeric_(c, decimal) || // if we haven't detected a scientific number before, 'e' or 'E'\n    // hint that we should continue to read\n    !scientificNotation && (c == 'e' || c == 'E') || // once we know that we have a scientific number, both '-' and '+'\n    // are allowed\n    scientificNotation && (c == '-' || c == '+'));\n\n    return parseFloat(this.wkt.substring(index, this.index_--));\n  };\n  /**\n   * @return {string} String token value.\n   * @private\n   */\n\n\n  Lexer.prototype.readText_ = function () {\n    var c;\n    var index = this.index_;\n\n    do {\n      c = this.nextChar_();\n    } while (this.isAlpha_(c));\n\n    return this.wkt.substring(index, this.index_--).toUpperCase();\n  };\n\n  return Lexer;\n}();\n/**\n * Class to parse the tokens from the WKT string.\n */\n\n\nvar Parser =\n/** @class */\nfunction () {\n  /**\n   * @param {Lexer} lexer The lexer.\n   */\n  function Parser(lexer) {\n    /**\n     * @type {Lexer}\n     * @private\n     */\n    this.lexer_ = lexer;\n    /**\n     * @type {Token}\n     * @private\n     */\n\n    this.token_;\n    /**\n     * @type {GeometryLayout}\n     * @private\n     */\n\n    this.layout_ = GeometryLayout.XY;\n  }\n  /**\n   * Fetch the next token form the lexer and replace the active token.\n   * @private\n   */\n\n\n  Parser.prototype.consume_ = function () {\n    this.token_ = this.lexer_.nextToken();\n  };\n  /**\n   * Tests if the given type matches the type of the current token.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n\n\n  Parser.prototype.isTokenType = function (type) {\n    var isMatch = this.token_.type == type;\n    return isMatch;\n  };\n  /**\n   * If the given type matches the current token, consume it.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n\n\n  Parser.prototype.match = function (type) {\n    var isMatch = this.isTokenType(type);\n\n    if (isMatch) {\n      this.consume_();\n    }\n\n    return isMatch;\n  };\n  /**\n   * Try to parse the tokens provided by the lexer.\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   */\n\n\n  Parser.prototype.parse = function () {\n    this.consume_();\n    var geometry = this.parseGeometry_();\n    return geometry;\n  };\n  /**\n   * Try to parse the dimensional info.\n   * @return {GeometryLayout} The layout.\n   * @private\n   */\n\n\n  Parser.prototype.parseGeometryLayout_ = function () {\n    var layout = GeometryLayout.XY;\n    var dimToken = this.token_;\n\n    if (this.isTokenType(TokenType.TEXT)) {\n      var dimInfo = dimToken.value;\n\n      if (dimInfo === Z) {\n        layout = GeometryLayout.XYZ;\n      } else if (dimInfo === M) {\n        layout = GeometryLayout.XYM;\n      } else if (dimInfo === ZM) {\n        layout = GeometryLayout.XYZM;\n      }\n\n      if (layout !== GeometryLayout.XY) {\n        this.consume_();\n      }\n    }\n\n    return layout;\n  };\n  /**\n   * @return {!Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n   * @private\n   */\n\n\n  Parser.prototype.parseGeometryCollectionText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var geometries = [];\n\n      do {\n        geometries.push(this.parseGeometry_());\n      } while (this.match(TokenType.COMMA));\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return geometries;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return [];\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {Array<number>} All values in a point.\n   * @private\n   */\n\n\n  Parser.prototype.parsePointText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates = this.parsePoint_();\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return null;\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {!Array<!Array<number>>} All points in a linestring.\n   * @private\n   */\n\n\n  Parser.prototype.parseLineStringText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates = this.parsePointList_();\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return [];\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {!Array<!Array<!Array<number>>>} All points in a polygon.\n   * @private\n   */\n\n\n  Parser.prototype.parsePolygonText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates = this.parseLineStringTextList_();\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return [];\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {!Array<!Array<number>>} All points in a multipoint.\n   * @private\n   */\n\n\n  Parser.prototype.parseMultiPointText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates = void 0;\n\n      if (this.token_.type == TokenType.LEFT_PAREN) {\n        coordinates = this.parsePointTextList_();\n      } else {\n        coordinates = this.parsePointList_();\n      }\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return [];\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {!Array<!Array<!Array<number>>>} All linestring points\n   *                                          in a multilinestring.\n   * @private\n   */\n\n\n  Parser.prototype.parseMultiLineStringText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates = this.parseLineStringTextList_();\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return [];\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {!Array<!Array<!Array<!Array<number>>>>} All polygon points in a multipolygon.\n   * @private\n   */\n\n\n  Parser.prototype.parseMultiPolygonText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates = this.parsePolygonTextList_();\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return [];\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {!Array<number>} A point.\n   * @private\n   */\n\n\n  Parser.prototype.parsePoint_ = function () {\n    var coordinates = [];\n    var dimensions = this.layout_.length;\n\n    for (var i = 0; i < dimensions; ++i) {\n      var token = this.token_;\n\n      if (this.match(TokenType.NUMBER)) {\n        coordinates.push(\n        /** @type {number} */\n        token.value);\n      } else {\n        break;\n      }\n    }\n\n    if (coordinates.length == dimensions) {\n      return coordinates;\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {!Array<!Array<number>>} An array of points.\n   * @private\n   */\n\n\n  Parser.prototype.parsePointList_ = function () {\n    var coordinates = [this.parsePoint_()];\n\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePoint_());\n    }\n\n    return coordinates;\n  };\n  /**\n   * @return {!Array<!Array<number>>} An array of points.\n   * @private\n   */\n\n\n  Parser.prototype.parsePointTextList_ = function () {\n    var coordinates = [this.parsePointText_()];\n\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePointText_());\n    }\n\n    return coordinates;\n  };\n  /**\n   * @return {!Array<!Array<!Array<number>>>} An array of points.\n   * @private\n   */\n\n\n  Parser.prototype.parseLineStringTextList_ = function () {\n    var coordinates = [this.parseLineStringText_()];\n\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parseLineStringText_());\n    }\n\n    return coordinates;\n  };\n  /**\n   * @return {!Array<!Array<!Array<!Array<number>>>>} An array of points.\n   * @private\n   */\n\n\n  Parser.prototype.parsePolygonTextList_ = function () {\n    var coordinates = [this.parsePolygonText_()];\n\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePolygonText_());\n    }\n\n    return coordinates;\n  };\n  /**\n   * @return {boolean} Whether the token implies an empty geometry.\n   * @private\n   */\n\n\n  Parser.prototype.isEmptyGeometry_ = function () {\n    var isEmpty = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\n\n    if (isEmpty) {\n      this.consume_();\n    }\n\n    return isEmpty;\n  };\n  /**\n   * Create an error message for an unexpected token error.\n   * @return {string} Error message.\n   * @private\n   */\n\n\n  Parser.prototype.formatErrorMessage_ = function () {\n    return 'Unexpected `' + this.token_.value + '` at position ' + this.token_.position + ' in `' + this.lexer_.wkt + '`';\n  };\n  /**\n   * @return {!import(\"../geom/Geometry.js\").default} The geometry.\n   * @private\n   */\n\n\n  Parser.prototype.parseGeometry_ = function () {\n    var token = this.token_;\n\n    if (this.match(TokenType.TEXT)) {\n      var geomType = token.value;\n      this.layout_ = this.parseGeometryLayout_();\n\n      if (geomType == 'GEOMETRYCOLLECTION') {\n        var geometries = this.parseGeometryCollectionText_();\n        return new GeometryCollection(geometries);\n      } else {\n        var ctor = GeometryConstructor[geomType];\n\n        if (!ctor) {\n          throw new Error('Invalid geometry type: ' + geomType);\n        }\n\n        var coordinates = void 0;\n\n        switch (geomType) {\n          case 'POINT':\n            {\n              coordinates = this.parsePointText_();\n              break;\n            }\n\n          case 'LINESTRING':\n            {\n              coordinates = this.parseLineStringText_();\n              break;\n            }\n\n          case 'POLYGON':\n            {\n              coordinates = this.parsePolygonText_();\n              break;\n            }\n\n          case 'MULTIPOINT':\n            {\n              coordinates = this.parseMultiPointText_();\n              break;\n            }\n\n          case 'MULTILINESTRING':\n            {\n              coordinates = this.parseMultiLineStringText_();\n              break;\n            }\n\n          case 'MULTIPOLYGON':\n            {\n              coordinates = this.parseMultiPolygonText_();\n              break;\n            }\n\n          default:\n            {\n              throw new Error('Invalid geometry type: ' + geomType);\n            }\n        }\n\n        if (!coordinates) {\n          if (ctor === GeometryConstructor['POINT']) {\n            coordinates = [NaN, NaN];\n          } else {\n            coordinates = [];\n          }\n        }\n\n        return new ctor(coordinates, this.layout_);\n      }\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n\n  return Parser;\n}();\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `WellKnownText` (WKT)\n * format.\n *\n * @api\n */\n\n\nvar WKT =\n/** @class */\nfunction (_super) {\n  __extends(WKT, _super);\n  /**\n   * @param {Options=} opt_options Options.\n   */\n\n\n  function WKT(opt_options) {\n    var _this = _super.call(this) || this;\n\n    var options = opt_options ? opt_options : {};\n    /**\n     * Split GeometryCollection into multiple features.\n     * @type {boolean}\n     * @private\n     */\n\n    _this.splitCollection_ = options.splitCollection !== undefined ? options.splitCollection : false;\n    return _this;\n  }\n  /**\n   * Parse a WKT string.\n   * @param {string} wkt WKT string.\n   * @return {import(\"../geom/Geometry.js\").default|undefined}\n   *     The geometry created.\n   * @private\n   */\n\n\n  WKT.prototype.parse_ = function (wkt) {\n    var lexer = new Lexer(wkt);\n    var parser = new Parser(lexer);\n    return parser.parse();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WKT.prototype.readFeatureFromText = function (text, opt_options) {\n    var geom = this.readGeometryFromText(text, opt_options);\n\n    if (geom) {\n      var feature = new Feature();\n      feature.setGeometry(geom);\n      return feature;\n    }\n\n    return null;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WKT.prototype.readFeaturesFromText = function (text, opt_options) {\n    var geometries = [];\n    var geometry = this.readGeometryFromText(text, opt_options);\n\n    if (this.splitCollection_ && geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\n      geometries =\n      /** @type {GeometryCollection} */\n      geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n\n    var features = [];\n\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      var feature = new Feature();\n      feature.setGeometry(geometries[i]);\n      features.push(feature);\n    }\n\n    return features;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WKT.prototype.readGeometryFromText = function (text, opt_options) {\n    var geometry = this.parse_(text);\n\n    if (geometry) {\n      return transformGeometryWithOptions(geometry, false, opt_options);\n    } else {\n      return null;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WKT.prototype.writeFeatureText = function (feature, opt_options) {\n    var geometry = feature.getGeometry();\n\n    if (geometry) {\n      return this.writeGeometryText(geometry, opt_options);\n    }\n\n    return '';\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WKT.prototype.writeFeaturesText = function (features, opt_options) {\n    if (features.length == 1) {\n      return this.writeFeatureText(features[0], opt_options);\n    }\n\n    var geometries = [];\n\n    for (var i = 0, ii = features.length; i < ii; ++i) {\n      geometries.push(features[i].getGeometry());\n    }\n\n    var collection = new GeometryCollection(geometries);\n    return this.writeGeometryText(collection, opt_options);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WKT.prototype.writeGeometryText = function (geometry, opt_options) {\n    return encode(transformGeometryWithOptions(geometry, true, opt_options));\n  };\n\n  return WKT;\n}(TextFeature);\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\n\n\nfunction encodePointGeometry(geom) {\n  var coordinates = geom.getCoordinates();\n\n  if (coordinates.length === 0) {\n    return '';\n  }\n\n  return coordinates.join(' ');\n}\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\n\n\nfunction encodeMultiPointGeometry(geom) {\n  var array = [];\n  var components = geom.getPoints();\n\n  for (var i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePointGeometry(components[i]) + ')');\n  }\n\n  return array.join(',');\n}\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\n\n\nfunction encodeGeometryCollectionGeometry(geom) {\n  var array = [];\n  var geoms = geom.getGeometries();\n\n  for (var i = 0, ii = geoms.length; i < ii; ++i) {\n    array.push(encode(geoms[i]));\n  }\n\n  return array.join(',');\n}\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\n\n\nfunction encodeLineStringGeometry(geom) {\n  var coordinates = geom.getCoordinates();\n  var array = [];\n\n  for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n    array.push(coordinates[i].join(' '));\n  }\n\n  return array.join(',');\n}\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\n\n\nfunction encodeMultiLineStringGeometry(geom) {\n  var array = [];\n  var components = geom.getLineStrings();\n\n  for (var i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(components[i]) + ')');\n  }\n\n  return array.join(',');\n}\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\n\n\nfunction encodePolygonGeometry(geom) {\n  var array = [];\n  var rings = geom.getLinearRings();\n\n  for (var i = 0, ii = rings.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(rings[i]) + ')');\n  }\n\n  return array.join(',');\n}\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\n\n\nfunction encodeMultiPolygonGeometry(geom) {\n  var array = [];\n  var components = geom.getPolygons();\n\n  for (var i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePolygonGeometry(components[i]) + ')');\n  }\n\n  return array.join(',');\n}\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geom SimpleGeometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\n\n\nfunction encodeGeometryLayout(geom) {\n  var layout = geom.getLayout();\n  var dimInfo = '';\n\n  if (layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM) {\n    dimInfo += Z;\n  }\n\n  if (layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM) {\n    dimInfo += M;\n  }\n\n  return dimInfo;\n}\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\n\n\nvar GeometryEncoder = {\n  'Point': encodePointGeometry,\n  'LineString': encodeLineStringGeometry,\n  'Polygon': encodePolygonGeometry,\n  'MultiPoint': encodeMultiPointGeometry,\n  'MultiLineString': encodeMultiLineStringGeometry,\n  'MultiPolygon': encodeMultiPolygonGeometry,\n  'GeometryCollection': encodeGeometryCollectionGeometry\n};\n/**\n * Encode a geometry as WKT.\n * @param {!import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\n\nfunction encode(geom) {\n  var type = geom.getType();\n  var geometryEncoder = GeometryEncoder[type];\n  var enc = geometryEncoder(geom);\n  type = type.toUpperCase();\n\n  if (typeof\n  /** @type {?} */\n  geom.getFlatCoordinates === 'function') {\n    var dimInfo = encodeGeometryLayout(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */\n    geom);\n\n    if (dimInfo.length > 0) {\n      type += ' ' + dimInfo;\n    }\n  }\n\n  if (enc.length === 0) {\n    return type + ' ' + EMPTY;\n  }\n\n  return type + '(' + enc + ')';\n}\n\nexport default WKT;","map":{"version":3,"sources":["../src/format/WKT.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/WKT\n */\nimport Feature from '../Feature.js';\nimport { transformGeometryWithOptions } from './Feature.js';\nimport TextFeature from './TextFeature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\n/**\n * Geometry constructors\n * @enum {function (new:import(\"../geom/Geometry.js\").default, Array, GeometryLayout)}\n */\nvar GeometryConstructor = {\n    'POINT': Point,\n    'LINESTRING': LineString,\n    'POLYGON': Polygon,\n    'MULTIPOINT': MultiPoint,\n    'MULTILINESTRING': MultiLineString,\n    'MULTIPOLYGON': MultiPolygon\n};\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n/**\n * @typedef {Object} Token\n * @property {number} type\n * @property {number|string} [value]\n * @property {number} position\n */\n/**\n * @const\n * @type {string}\n */\nvar EMPTY = 'EMPTY';\n/**\n * @const\n * @type {string}\n */\nvar Z = 'Z';\n/**\n * @const\n * @type {string}\n */\nvar M = 'M';\n/**\n * @const\n * @type {string}\n */\nvar ZM = 'ZM';\n/**\n * @const\n * @enum {number}\n */\nvar TokenType = {\n    TEXT: 1,\n    LEFT_PAREN: 2,\n    RIGHT_PAREN: 3,\n    NUMBER: 4,\n    COMMA: 5,\n    EOF: 6\n};\n/**\n * @const\n * @type {Object<string, string>}\n */\nvar WKTGeometryType = {};\nfor (var type in GeometryType) {\n    WKTGeometryType[type] = GeometryType[type].toUpperCase();\n}\n/**\n * Class to tokenize a WKT string.\n */\nvar Lexer = /** @class */ (function () {\n    /**\n     * @param {string} wkt WKT string.\n     */\n    function Lexer(wkt) {\n        /**\n         * @type {string}\n         */\n        this.wkt = wkt;\n        /**\n         * @type {number}\n         * @private\n         */\n        this.index_ = -1;\n    }\n    /**\n     * @param {string} c Character.\n     * @return {boolean} Whether the character is alphabetic.\n     * @private\n     */\n    Lexer.prototype.isAlpha_ = function (c) {\n        return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';\n    };\n    /**\n     * @param {string} c Character.\n     * @param {boolean=} opt_decimal Whether the string number\n     *     contains a dot, i.e. is a decimal number.\n     * @return {boolean} Whether the character is numeric.\n     * @private\n     */\n    Lexer.prototype.isNumeric_ = function (c, opt_decimal) {\n        var decimal = opt_decimal !== undefined ? opt_decimal : false;\n        return c >= '0' && c <= '9' || c == '.' && !decimal;\n    };\n    /**\n     * @param {string} c Character.\n     * @return {boolean} Whether the character is whitespace.\n     * @private\n     */\n    Lexer.prototype.isWhiteSpace_ = function (c) {\n        return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n    };\n    /**\n     * @return {string} Next string character.\n     * @private\n     */\n    Lexer.prototype.nextChar_ = function () {\n        return this.wkt.charAt(++this.index_);\n    };\n    /**\n     * Fetch and return the next token.\n     * @return {!Token} Next string token.\n     */\n    Lexer.prototype.nextToken = function () {\n        var c = this.nextChar_();\n        var position = this.index_;\n        /** @type {number|string} */\n        var value = c;\n        var type;\n        if (c == '(') {\n            type = TokenType.LEFT_PAREN;\n        }\n        else if (c == ',') {\n            type = TokenType.COMMA;\n        }\n        else if (c == ')') {\n            type = TokenType.RIGHT_PAREN;\n        }\n        else if (this.isNumeric_(c) || c == '-') {\n            type = TokenType.NUMBER;\n            value = this.readNumber_();\n        }\n        else if (this.isAlpha_(c)) {\n            type = TokenType.TEXT;\n            value = this.readText_();\n        }\n        else if (this.isWhiteSpace_(c)) {\n            return this.nextToken();\n        }\n        else if (c === '') {\n            type = TokenType.EOF;\n        }\n        else {\n            throw new Error('Unexpected character: ' + c);\n        }\n        return { position: position, value: value, type: type };\n    };\n    /**\n     * @return {number} Numeric token value.\n     * @private\n     */\n    Lexer.prototype.readNumber_ = function () {\n        var c;\n        var index = this.index_;\n        var decimal = false;\n        var scientificNotation = false;\n        do {\n            if (c == '.') {\n                decimal = true;\n            }\n            else if (c == 'e' || c == 'E') {\n                scientificNotation = true;\n            }\n            c = this.nextChar_();\n        } while (this.isNumeric_(c, decimal) ||\n            // if we haven't detected a scientific number before, 'e' or 'E'\n            // hint that we should continue to read\n            !scientificNotation && (c == 'e' || c == 'E') ||\n            // once we know that we have a scientific number, both '-' and '+'\n            // are allowed\n            scientificNotation && (c == '-' || c == '+'));\n        return parseFloat(this.wkt.substring(index, this.index_--));\n    };\n    /**\n     * @return {string} String token value.\n     * @private\n     */\n    Lexer.prototype.readText_ = function () {\n        var c;\n        var index = this.index_;\n        do {\n            c = this.nextChar_();\n        } while (this.isAlpha_(c));\n        return this.wkt.substring(index, this.index_--).toUpperCase();\n    };\n    return Lexer;\n}());\n/**\n * Class to parse the tokens from the WKT string.\n */\nvar Parser = /** @class */ (function () {\n    /**\n     * @param {Lexer} lexer The lexer.\n     */\n    function Parser(lexer) {\n        /**\n         * @type {Lexer}\n         * @private\n         */\n        this.lexer_ = lexer;\n        /**\n         * @type {Token}\n         * @private\n         */\n        this.token_;\n        /**\n         * @type {GeometryLayout}\n         * @private\n         */\n        this.layout_ = GeometryLayout.XY;\n    }\n    /**\n     * Fetch the next token form the lexer and replace the active token.\n     * @private\n     */\n    Parser.prototype.consume_ = function () {\n        this.token_ = this.lexer_.nextToken();\n    };\n    /**\n     * Tests if the given type matches the type of the current token.\n     * @param {TokenType} type Token type.\n     * @return {boolean} Whether the token matches the given type.\n     */\n    Parser.prototype.isTokenType = function (type) {\n        var isMatch = this.token_.type == type;\n        return isMatch;\n    };\n    /**\n     * If the given type matches the current token, consume it.\n     * @param {TokenType} type Token type.\n     * @return {boolean} Whether the token matches the given type.\n     */\n    Parser.prototype.match = function (type) {\n        var isMatch = this.isTokenType(type);\n        if (isMatch) {\n            this.consume_();\n        }\n        return isMatch;\n    };\n    /**\n     * Try to parse the tokens provided by the lexer.\n     * @return {import(\"../geom/Geometry.js\").default} The geometry.\n     */\n    Parser.prototype.parse = function () {\n        this.consume_();\n        var geometry = this.parseGeometry_();\n        return geometry;\n    };\n    /**\n     * Try to parse the dimensional info.\n     * @return {GeometryLayout} The layout.\n     * @private\n     */\n    Parser.prototype.parseGeometryLayout_ = function () {\n        var layout = GeometryLayout.XY;\n        var dimToken = this.token_;\n        if (this.isTokenType(TokenType.TEXT)) {\n            var dimInfo = dimToken.value;\n            if (dimInfo === Z) {\n                layout = GeometryLayout.XYZ;\n            }\n            else if (dimInfo === M) {\n                layout = GeometryLayout.XYM;\n            }\n            else if (dimInfo === ZM) {\n                layout = GeometryLayout.XYZM;\n            }\n            if (layout !== GeometryLayout.XY) {\n                this.consume_();\n            }\n        }\n        return layout;\n    };\n    /**\n     * @return {!Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n     * @private\n     */\n    Parser.prototype.parseGeometryCollectionText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var geometries = [];\n            do {\n                geometries.push(this.parseGeometry_());\n            } while (this.match(TokenType.COMMA));\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return geometries;\n            }\n        }\n        else if (this.isEmptyGeometry_()) {\n            return [];\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {Array<number>} All values in a point.\n     * @private\n     */\n    Parser.prototype.parsePointText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var coordinates = this.parsePoint_();\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return coordinates;\n            }\n        }\n        else if (this.isEmptyGeometry_()) {\n            return null;\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {!Array<!Array<number>>} All points in a linestring.\n     * @private\n     */\n    Parser.prototype.parseLineStringText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var coordinates = this.parsePointList_();\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return coordinates;\n            }\n        }\n        else if (this.isEmptyGeometry_()) {\n            return [];\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {!Array<!Array<!Array<number>>>} All points in a polygon.\n     * @private\n     */\n    Parser.prototype.parsePolygonText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var coordinates = this.parseLineStringTextList_();\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return coordinates;\n            }\n        }\n        else if (this.isEmptyGeometry_()) {\n            return [];\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {!Array<!Array<number>>} All points in a multipoint.\n     * @private\n     */\n    Parser.prototype.parseMultiPointText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var coordinates = void 0;\n            if (this.token_.type == TokenType.LEFT_PAREN) {\n                coordinates = this.parsePointTextList_();\n            }\n            else {\n                coordinates = this.parsePointList_();\n            }\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return coordinates;\n            }\n        }\n        else if (this.isEmptyGeometry_()) {\n            return [];\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {!Array<!Array<!Array<number>>>} All linestring points\n     *                                          in a multilinestring.\n     * @private\n     */\n    Parser.prototype.parseMultiLineStringText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var coordinates = this.parseLineStringTextList_();\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return coordinates;\n            }\n        }\n        else if (this.isEmptyGeometry_()) {\n            return [];\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {!Array<!Array<!Array<!Array<number>>>>} All polygon points in a multipolygon.\n     * @private\n     */\n    Parser.prototype.parseMultiPolygonText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var coordinates = this.parsePolygonTextList_();\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return coordinates;\n            }\n        }\n        else if (this.isEmptyGeometry_()) {\n            return [];\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {!Array<number>} A point.\n     * @private\n     */\n    Parser.prototype.parsePoint_ = function () {\n        var coordinates = [];\n        var dimensions = this.layout_.length;\n        for (var i = 0; i < dimensions; ++i) {\n            var token = this.token_;\n            if (this.match(TokenType.NUMBER)) {\n                coordinates.push(/** @type {number} */ (token.value));\n            }\n            else {\n                break;\n            }\n        }\n        if (coordinates.length == dimensions) {\n            return coordinates;\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {!Array<!Array<number>>} An array of points.\n     * @private\n     */\n    Parser.prototype.parsePointList_ = function () {\n        var coordinates = [this.parsePoint_()];\n        while (this.match(TokenType.COMMA)) {\n            coordinates.push(this.parsePoint_());\n        }\n        return coordinates;\n    };\n    /**\n     * @return {!Array<!Array<number>>} An array of points.\n     * @private\n     */\n    Parser.prototype.parsePointTextList_ = function () {\n        var coordinates = [this.parsePointText_()];\n        while (this.match(TokenType.COMMA)) {\n            coordinates.push(this.parsePointText_());\n        }\n        return coordinates;\n    };\n    /**\n     * @return {!Array<!Array<!Array<number>>>} An array of points.\n     * @private\n     */\n    Parser.prototype.parseLineStringTextList_ = function () {\n        var coordinates = [this.parseLineStringText_()];\n        while (this.match(TokenType.COMMA)) {\n            coordinates.push(this.parseLineStringText_());\n        }\n        return coordinates;\n    };\n    /**\n     * @return {!Array<!Array<!Array<!Array<number>>>>} An array of points.\n     * @private\n     */\n    Parser.prototype.parsePolygonTextList_ = function () {\n        var coordinates = [this.parsePolygonText_()];\n        while (this.match(TokenType.COMMA)) {\n            coordinates.push(this.parsePolygonText_());\n        }\n        return coordinates;\n    };\n    /**\n     * @return {boolean} Whether the token implies an empty geometry.\n     * @private\n     */\n    Parser.prototype.isEmptyGeometry_ = function () {\n        var isEmpty = this.isTokenType(TokenType.TEXT) &&\n            this.token_.value == EMPTY;\n        if (isEmpty) {\n            this.consume_();\n        }\n        return isEmpty;\n    };\n    /**\n     * Create an error message for an unexpected token error.\n     * @return {string} Error message.\n     * @private\n     */\n    Parser.prototype.formatErrorMessage_ = function () {\n        return 'Unexpected `' + this.token_.value + '` at position ' +\n            this.token_.position + ' in `' + this.lexer_.wkt + '`';\n    };\n    /**\n     * @return {!import(\"../geom/Geometry.js\").default} The geometry.\n     * @private\n     */\n    Parser.prototype.parseGeometry_ = function () {\n        var token = this.token_;\n        if (this.match(TokenType.TEXT)) {\n            var geomType = token.value;\n            this.layout_ = this.parseGeometryLayout_();\n            if (geomType == 'GEOMETRYCOLLECTION') {\n                var geometries = this.parseGeometryCollectionText_();\n                return new GeometryCollection(geometries);\n            }\n            else {\n                var ctor = GeometryConstructor[geomType];\n                if (!ctor) {\n                    throw new Error('Invalid geometry type: ' + geomType);\n                }\n                var coordinates = void 0;\n                switch (geomType) {\n                    case 'POINT': {\n                        coordinates = this.parsePointText_();\n                        break;\n                    }\n                    case 'LINESTRING': {\n                        coordinates = this.parseLineStringText_();\n                        break;\n                    }\n                    case 'POLYGON': {\n                        coordinates = this.parsePolygonText_();\n                        break;\n                    }\n                    case 'MULTIPOINT': {\n                        coordinates = this.parseMultiPointText_();\n                        break;\n                    }\n                    case 'MULTILINESTRING': {\n                        coordinates = this.parseMultiLineStringText_();\n                        break;\n                    }\n                    case 'MULTIPOLYGON': {\n                        coordinates = this.parseMultiPolygonText_();\n                        break;\n                    }\n                    default: {\n                        throw new Error('Invalid geometry type: ' + geomType);\n                    }\n                }\n                if (!coordinates) {\n                    if (ctor === GeometryConstructor['POINT']) {\n                        coordinates = [NaN, NaN];\n                    }\n                    else {\n                        coordinates = [];\n                    }\n                }\n                return new ctor(coordinates, this.layout_);\n            }\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    return Parser;\n}());\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `WellKnownText` (WKT)\n * format.\n *\n * @api\n */\nvar WKT = /** @class */ (function (_super) {\n    __extends(WKT, _super);\n    /**\n     * @param {Options=} opt_options Options.\n     */\n    function WKT(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * Split GeometryCollection into multiple features.\n         * @type {boolean}\n         * @private\n         */\n        _this.splitCollection_ = options.splitCollection !== undefined ?\n            options.splitCollection : false;\n        return _this;\n    }\n    /**\n     * Parse a WKT string.\n     * @param {string} wkt WKT string.\n     * @return {import(\"../geom/Geometry.js\").default|undefined}\n     *     The geometry created.\n     * @private\n     */\n    WKT.prototype.parse_ = function (wkt) {\n        var lexer = new Lexer(wkt);\n        var parser = new Parser(lexer);\n        return parser.parse();\n    };\n    /**\n     * @inheritDoc\n     */\n    WKT.prototype.readFeatureFromText = function (text, opt_options) {\n        var geom = this.readGeometryFromText(text, opt_options);\n        if (geom) {\n            var feature = new Feature();\n            feature.setGeometry(geom);\n            return feature;\n        }\n        return null;\n    };\n    /**\n     * @inheritDoc\n     */\n    WKT.prototype.readFeaturesFromText = function (text, opt_options) {\n        var geometries = [];\n        var geometry = this.readGeometryFromText(text, opt_options);\n        if (this.splitCollection_ &&\n            geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\n            geometries = ( /** @type {GeometryCollection} */(geometry))\n                .getGeometriesArray();\n        }\n        else {\n            geometries = [geometry];\n        }\n        var features = [];\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            var feature = new Feature();\n            feature.setGeometry(geometries[i]);\n            features.push(feature);\n        }\n        return features;\n    };\n    /**\n     * @inheritDoc\n     */\n    WKT.prototype.readGeometryFromText = function (text, opt_options) {\n        var geometry = this.parse_(text);\n        if (geometry) {\n            return transformGeometryWithOptions(geometry, false, opt_options);\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    WKT.prototype.writeFeatureText = function (feature, opt_options) {\n        var geometry = feature.getGeometry();\n        if (geometry) {\n            return this.writeGeometryText(geometry, opt_options);\n        }\n        return '';\n    };\n    /**\n     * @inheritDoc\n     */\n    WKT.prototype.writeFeaturesText = function (features, opt_options) {\n        if (features.length == 1) {\n            return this.writeFeatureText(features[0], opt_options);\n        }\n        var geometries = [];\n        for (var i = 0, ii = features.length; i < ii; ++i) {\n            geometries.push(features[i].getGeometry());\n        }\n        var collection = new GeometryCollection(geometries);\n        return this.writeGeometryText(collection, opt_options);\n    };\n    /**\n     * @inheritDoc\n     */\n    WKT.prototype.writeGeometryText = function (geometry, opt_options) {\n        return encode(transformGeometryWithOptions(geometry, true, opt_options));\n    };\n    return WKT;\n}(TextFeature));\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\nfunction encodePointGeometry(geom) {\n    var coordinates = geom.getCoordinates();\n    if (coordinates.length === 0) {\n        return '';\n    }\n    return coordinates.join(' ');\n}\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\nfunction encodeMultiPointGeometry(geom) {\n    var array = [];\n    var components = geom.getPoints();\n    for (var i = 0, ii = components.length; i < ii; ++i) {\n        array.push('(' + encodePointGeometry(components[i]) + ')');\n    }\n    return array.join(',');\n}\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\nfunction encodeGeometryCollectionGeometry(geom) {\n    var array = [];\n    var geoms = geom.getGeometries();\n    for (var i = 0, ii = geoms.length; i < ii; ++i) {\n        array.push(encode(geoms[i]));\n    }\n    return array.join(',');\n}\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\nfunction encodeLineStringGeometry(geom) {\n    var coordinates = geom.getCoordinates();\n    var array = [];\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        array.push(coordinates[i].join(' '));\n    }\n    return array.join(',');\n}\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\nfunction encodeMultiLineStringGeometry(geom) {\n    var array = [];\n    var components = geom.getLineStrings();\n    for (var i = 0, ii = components.length; i < ii; ++i) {\n        array.push('(' + encodeLineStringGeometry(components[i]) + ')');\n    }\n    return array.join(',');\n}\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\nfunction encodePolygonGeometry(geom) {\n    var array = [];\n    var rings = geom.getLinearRings();\n    for (var i = 0, ii = rings.length; i < ii; ++i) {\n        array.push('(' + encodeLineStringGeometry(rings[i]) + ')');\n    }\n    return array.join(',');\n}\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\nfunction encodeMultiPolygonGeometry(geom) {\n    var array = [];\n    var components = geom.getPolygons();\n    for (var i = 0, ii = components.length; i < ii; ++i) {\n        array.push('(' + encodePolygonGeometry(components[i]) + ')');\n    }\n    return array.join(',');\n}\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geom SimpleGeometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\nfunction encodeGeometryLayout(geom) {\n    var layout = geom.getLayout();\n    var dimInfo = '';\n    if (layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM) {\n        dimInfo += Z;\n    }\n    if (layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM) {\n        dimInfo += M;\n    }\n    return dimInfo;\n}\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\nvar GeometryEncoder = {\n    'Point': encodePointGeometry,\n    'LineString': encodeLineStringGeometry,\n    'Polygon': encodePolygonGeometry,\n    'MultiPoint': encodeMultiPointGeometry,\n    'MultiLineString': encodeMultiLineStringGeometry,\n    'MultiPolygon': encodeMultiPolygonGeometry,\n    'GeometryCollection': encodeGeometryCollectionGeometry\n};\n/**\n * Encode a geometry as WKT.\n * @param {!import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\nfunction encode(geom) {\n    var type = geom.getType();\n    var geometryEncoder = GeometryEncoder[type];\n    var enc = geometryEncoder(geom);\n    type = type.toUpperCase();\n    if (typeof /** @type {?} */ (geom).getFlatCoordinates === 'function') {\n        var dimInfo = encodeGeometryLayout(/** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geom));\n        if (dimInfo.length > 0) {\n            type += ' ' + dimInfo;\n        }\n    }\n    if (enc.length === 0) {\n        return type + ' ' + EMPTY;\n    }\n    return type + '(' + enc + ')';\n}\nexport default WKT;\n//# sourceMappingURL=WKT.js.map"]},"metadata":{},"sourceType":"module"}