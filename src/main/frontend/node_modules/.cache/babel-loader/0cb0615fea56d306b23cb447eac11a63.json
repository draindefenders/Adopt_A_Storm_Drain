{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/format/IGC\n */\n\n\nimport Feature from '../Feature.js';\nimport { transformGeometryWithOptions } from './Feature.js';\nimport TextFeature from './TextFeature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * IGC altitude/z. One of 'barometric', 'gps', 'none'.\n * @enum {string}\n */\n\nvar IGCZ = {\n  BAROMETRIC: 'barometric',\n  GPS: 'gps',\n  NONE: 'none'\n};\n/**\n * @const\n * @type {RegExp}\n */\n\nvar B_RECORD_RE = /^B(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{5})([NS])(\\d{3})(\\d{5})([EW])([AV])(\\d{5})(\\d{5})/;\n/**\n * @const\n * @type {RegExp}\n */\n\nvar H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;\n/**\n * @const\n * @type {RegExp}\n */\n\nvar HFDTE_RECORD_RE = /^HFDTE(\\d{2})(\\d{2})(\\d{2})/;\n/**\n * A regular expression matching the newline characters `\\r\\n`, `\\r` and `\\n`.\n *\n * @const\n * @type {RegExp}\n */\n\nvar NEWLINE_RE = /\\r\\n|\\r|\\n/;\n/**\n * @typedef {Object} Options\n * @property {IGCZ|string} [altitudeMode='none'] Altitude mode. Possible\n * values are `'barometric'`, `'gps'`, and `'none'`.\n */\n\n/**\n * @classdesc\n * Feature format for `*.igc` flight recording files.\n *\n * As IGC sources contain a single feature,\n * {@link module:ol/format/IGC~IGC#readFeatures} will return the feature in an\n * array\n *\n * @api\n */\n\nvar IGC =\n/** @class */\nfunction (_super) {\n  __extends(IGC, _super);\n  /**\n   * @param {Options=} opt_options Options.\n   */\n\n\n  function IGC(opt_options) {\n    var _this = _super.call(this) || this;\n\n    var options = opt_options ? opt_options : {};\n    /**\n     * @inheritDoc\n     */\n\n    _this.dataProjection = getProjection('EPSG:4326');\n    /**\n     * @private\n     * @type {IGCZ}\n     */\n\n    _this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : IGCZ.NONE;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  IGC.prototype.readFeatureFromText = function (text, opt_options) {\n    var altitudeMode = this.altitudeMode_;\n    var lines = text.split(NEWLINE_RE);\n    /** @type {Object<string, string>} */\n\n    var properties = {};\n    var flatCoordinates = [];\n    var year = 2000;\n    var month = 0;\n    var day = 1;\n    var lastDateTime = -1;\n    var i, ii;\n\n    for (i = 0, ii = lines.length; i < ii; ++i) {\n      var line = lines[i];\n      var m = void 0;\n\n      if (line.charAt(0) == 'B') {\n        m = B_RECORD_RE.exec(line);\n\n        if (m) {\n          var hour = parseInt(m[1], 10);\n          var minute = parseInt(m[2], 10);\n          var second = parseInt(m[3], 10);\n          var y = parseInt(m[4], 10) + parseInt(m[5], 10) / 60000;\n\n          if (m[6] == 'S') {\n            y = -y;\n          }\n\n          var x = parseInt(m[7], 10) + parseInt(m[8], 10) / 60000;\n\n          if (m[9] == 'W') {\n            x = -x;\n          }\n\n          flatCoordinates.push(x, y);\n\n          if (altitudeMode != IGCZ.NONE) {\n            var z = void 0;\n\n            if (altitudeMode == IGCZ.GPS) {\n              z = parseInt(m[11], 10);\n            } else if (altitudeMode == IGCZ.BAROMETRIC) {\n              z = parseInt(m[12], 10);\n            } else {\n              z = 0;\n            }\n\n            flatCoordinates.push(z);\n          }\n\n          var dateTime = Date.UTC(year, month, day, hour, minute, second); // Detect UTC midnight wrap around.\n\n          if (dateTime < lastDateTime) {\n            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);\n          }\n\n          flatCoordinates.push(dateTime / 1000);\n          lastDateTime = dateTime;\n        }\n      } else if (line.charAt(0) == 'H') {\n        m = HFDTE_RECORD_RE.exec(line);\n\n        if (m) {\n          day = parseInt(m[1], 10);\n          month = parseInt(m[2], 10) - 1;\n          year = 2000 + parseInt(m[3], 10);\n        } else {\n          m = H_RECORD_RE.exec(line);\n\n          if (m) {\n            properties[m[1]] = m[2].trim();\n          }\n        }\n      }\n    }\n\n    if (flatCoordinates.length === 0) {\n      return null;\n    }\n\n    var layout = altitudeMode == IGCZ.NONE ? GeometryLayout.XYM : GeometryLayout.XYZM;\n    var lineString = new LineString(flatCoordinates, layout);\n    var feature = new Feature(transformGeometryWithOptions(lineString, false, opt_options));\n    feature.setProperties(properties, true);\n    return feature;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IGC.prototype.readFeaturesFromText = function (text, opt_options) {\n    var feature = this.readFeatureFromText(text, opt_options);\n\n    if (feature) {\n      return [feature];\n    } else {\n      return [];\n    }\n  };\n\n  return IGC;\n}(TextFeature);\n\nexport default IGC;","map":{"version":3,"sources":["../src/format/IGC.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/IGC\n */\nimport Feature from '../Feature.js';\nimport { transformGeometryWithOptions } from './Feature.js';\nimport TextFeature from './TextFeature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * IGC altitude/z. One of 'barometric', 'gps', 'none'.\n * @enum {string}\n */\nvar IGCZ = {\n    BAROMETRIC: 'barometric',\n    GPS: 'gps',\n    NONE: 'none'\n};\n/**\n * @const\n * @type {RegExp}\n */\nvar B_RECORD_RE = /^B(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{5})([NS])(\\d{3})(\\d{5})([EW])([AV])(\\d{5})(\\d{5})/;\n/**\n * @const\n * @type {RegExp}\n */\nvar H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;\n/**\n * @const\n * @type {RegExp}\n */\nvar HFDTE_RECORD_RE = /^HFDTE(\\d{2})(\\d{2})(\\d{2})/;\n/**\n * A regular expression matching the newline characters `\\r\\n`, `\\r` and `\\n`.\n *\n * @const\n * @type {RegExp}\n */\nvar NEWLINE_RE = /\\r\\n|\\r|\\n/;\n/**\n * @typedef {Object} Options\n * @property {IGCZ|string} [altitudeMode='none'] Altitude mode. Possible\n * values are `'barometric'`, `'gps'`, and `'none'`.\n */\n/**\n * @classdesc\n * Feature format for `*.igc` flight recording files.\n *\n * As IGC sources contain a single feature,\n * {@link module:ol/format/IGC~IGC#readFeatures} will return the feature in an\n * array\n *\n * @api\n */\nvar IGC = /** @class */ (function (_super) {\n    __extends(IGC, _super);\n    /**\n     * @param {Options=} opt_options Options.\n     */\n    function IGC(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * @inheritDoc\n         */\n        _this.dataProjection = getProjection('EPSG:4326');\n        /**\n         * @private\n         * @type {IGCZ}\n         */\n        _this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : IGCZ.NONE;\n        return _this;\n    }\n    /**\n     * @inheritDoc\n     */\n    IGC.prototype.readFeatureFromText = function (text, opt_options) {\n        var altitudeMode = this.altitudeMode_;\n        var lines = text.split(NEWLINE_RE);\n        /** @type {Object<string, string>} */\n        var properties = {};\n        var flatCoordinates = [];\n        var year = 2000;\n        var month = 0;\n        var day = 1;\n        var lastDateTime = -1;\n        var i, ii;\n        for (i = 0, ii = lines.length; i < ii; ++i) {\n            var line = lines[i];\n            var m = void 0;\n            if (line.charAt(0) == 'B') {\n                m = B_RECORD_RE.exec(line);\n                if (m) {\n                    var hour = parseInt(m[1], 10);\n                    var minute = parseInt(m[2], 10);\n                    var second = parseInt(m[3], 10);\n                    var y = parseInt(m[4], 10) + parseInt(m[5], 10) / 60000;\n                    if (m[6] == 'S') {\n                        y = -y;\n                    }\n                    var x = parseInt(m[7], 10) + parseInt(m[8], 10) / 60000;\n                    if (m[9] == 'W') {\n                        x = -x;\n                    }\n                    flatCoordinates.push(x, y);\n                    if (altitudeMode != IGCZ.NONE) {\n                        var z = void 0;\n                        if (altitudeMode == IGCZ.GPS) {\n                            z = parseInt(m[11], 10);\n                        }\n                        else if (altitudeMode == IGCZ.BAROMETRIC) {\n                            z = parseInt(m[12], 10);\n                        }\n                        else {\n                            z = 0;\n                        }\n                        flatCoordinates.push(z);\n                    }\n                    var dateTime = Date.UTC(year, month, day, hour, minute, second);\n                    // Detect UTC midnight wrap around.\n                    if (dateTime < lastDateTime) {\n                        dateTime = Date.UTC(year, month, day + 1, hour, minute, second);\n                    }\n                    flatCoordinates.push(dateTime / 1000);\n                    lastDateTime = dateTime;\n                }\n            }\n            else if (line.charAt(0) == 'H') {\n                m = HFDTE_RECORD_RE.exec(line);\n                if (m) {\n                    day = parseInt(m[1], 10);\n                    month = parseInt(m[2], 10) - 1;\n                    year = 2000 + parseInt(m[3], 10);\n                }\n                else {\n                    m = H_RECORD_RE.exec(line);\n                    if (m) {\n                        properties[m[1]] = m[2].trim();\n                    }\n                }\n            }\n        }\n        if (flatCoordinates.length === 0) {\n            return null;\n        }\n        var layout = altitudeMode == IGCZ.NONE ? GeometryLayout.XYM : GeometryLayout.XYZM;\n        var lineString = new LineString(flatCoordinates, layout);\n        var feature = new Feature(transformGeometryWithOptions(lineString, false, opt_options));\n        feature.setProperties(properties, true);\n        return feature;\n    };\n    /**\n     * @inheritDoc\n     */\n    IGC.prototype.readFeaturesFromText = function (text, opt_options) {\n        var feature = this.readFeatureFromText(text, opt_options);\n        if (feature) {\n            return [feature];\n        }\n        else {\n            return [];\n        }\n    };\n    return IGC;\n}(TextFeature));\nexport default IGC;\n//# sourceMappingURL=IGC.js.map"]},"metadata":{},"sourceType":"module"}