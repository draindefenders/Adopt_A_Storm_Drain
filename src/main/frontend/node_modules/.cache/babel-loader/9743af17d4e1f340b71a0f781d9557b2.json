{"ast":null,"code":"/**\n * @module ol/source/Cluster\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { getUid } from '../util.js';\nimport { assert } from '../asserts.js';\nimport Feature from '../Feature.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport { scale as scaleCoordinate, add as addCoordinate } from '../coordinate.js';\nimport EventType from '../events/EventType.js';\nimport { buffer, createEmpty, createOrUpdateFromCoordinate } from '../extent.js';\nimport Point from '../geom/Point.js';\nimport VectorSource from './Vector.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Minimum distance in pixels between clusters.\n * @property {function(Feature):Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature} as argument and returns an\n * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underyling source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {VectorSource} source Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n * @api\n */\n\nvar Cluster =\n/** @class */\nfunction (_super) {\n  __extends(Cluster, _super);\n  /**\n   * @param {Options} options Cluster options.\n   */\n\n\n  function Cluster(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      wrapX: options.wrapX\n    }) || this;\n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n\n\n    _this.resolution = undefined;\n    /**\n     * @type {number}\n     * @protected\n     */\n\n    _this.distance = options.distance !== undefined ? options.distance : 20;\n    /**\n     * @type {Array<Feature>}\n     * @protected\n     */\n\n    _this.features = [];\n    /**\n     * @param {Feature} feature Feature.\n     * @return {Point} Cluster calculation point.\n     * @protected\n     */\n\n    _this.geometryFunction = options.geometryFunction || function (feature) {\n      var geometry = feature.getGeometry();\n      assert(geometry.getType() == GeometryType.POINT, 10); // The default `geometryFunction` can only handle `Point` geometries\n\n      return geometry;\n    };\n    /**\n     * @type {VectorSource}\n     * @protected\n     */\n\n\n    _this.source = options.source;\n\n    _this.source.addEventListener(EventType.CHANGE, _this.refresh.bind(_this));\n\n    return _this;\n  }\n  /**\n   * Get the distance in pixels between clusters.\n   * @return {number} Distance.\n   * @api\n   */\n\n\n  Cluster.prototype.getDistance = function () {\n    return this.distance;\n  };\n  /**\n   * Get a reference to the wrapped source.\n   * @return {VectorSource} Source.\n   * @api\n   */\n\n\n  Cluster.prototype.getSource = function () {\n    return this.source;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Cluster.prototype.loadFeatures = function (extent, resolution, projection) {\n    this.source.loadFeatures(extent, resolution, projection);\n\n    if (resolution !== this.resolution) {\n      this.clear();\n      this.resolution = resolution;\n      this.cluster();\n      this.addFeatures(this.features);\n    }\n  };\n  /**\n   * Set the distance in pixels between clusters.\n   * @param {number} distance The distance in pixels.\n   * @api\n   */\n\n\n  Cluster.prototype.setDistance = function (distance) {\n    this.distance = distance;\n    this.refresh();\n  };\n  /**\n   * handle the source changing\n   * @override\n   */\n\n\n  Cluster.prototype.refresh = function () {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n  };\n  /**\n   * @protected\n   */\n\n\n  Cluster.prototype.cluster = function () {\n    if (this.resolution === undefined) {\n      return;\n    }\n\n    this.features.length = 0;\n    var extent = createEmpty();\n    var mapDistance = this.distance * this.resolution;\n    var features = this.source.getFeatures();\n    /**\n     * @type {!Object<string, boolean>}\n     */\n\n    var clustered = {};\n\n    for (var i = 0, ii = features.length; i < ii; i++) {\n      var feature = features[i];\n\n      if (!(getUid(feature) in clustered)) {\n        var geometry = this.geometryFunction(feature);\n\n        if (geometry) {\n          var coordinates = geometry.getCoordinates();\n          createOrUpdateFromCoordinate(coordinates, extent);\n          buffer(extent, mapDistance, extent);\n          var neighbors = this.source.getFeaturesInExtent(extent);\n          neighbors = neighbors.filter(function (neighbor) {\n            var uid = getUid(neighbor);\n\n            if (!(uid in clustered)) {\n              clustered[uid] = true;\n              return true;\n            } else {\n              return false;\n            }\n          });\n          this.features.push(this.createCluster(neighbors));\n        }\n      }\n    }\n  };\n  /**\n   * @param {Array<Feature>} features Features\n   * @return {Feature} The cluster feature.\n   * @protected\n   */\n\n\n  Cluster.prototype.createCluster = function (features) {\n    var centroid = [0, 0];\n\n    for (var i = features.length - 1; i >= 0; --i) {\n      var geometry = this.geometryFunction(features[i]);\n\n      if (geometry) {\n        addCoordinate(centroid, geometry.getCoordinates());\n      } else {\n        features.splice(i, 1);\n      }\n    }\n\n    scaleCoordinate(centroid, 1 / features.length);\n    var cluster = new Feature(new Point(centroid));\n    cluster.set('features', features);\n    return cluster;\n  };\n\n  return Cluster;\n}(VectorSource);\n\nexport default Cluster;","map":{"version":3,"sources":["../src/source/Cluster.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/source/Cluster\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getUid } from '../util.js';\nimport { assert } from '../asserts.js';\nimport Feature from '../Feature.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport { scale as scaleCoordinate, add as addCoordinate } from '../coordinate.js';\nimport EventType from '../events/EventType.js';\nimport { buffer, createEmpty, createOrUpdateFromCoordinate } from '../extent.js';\nimport Point from '../geom/Point.js';\nimport VectorSource from './Vector.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Minimum distance in pixels between clusters.\n * @property {function(Feature):Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature} as argument and returns an\n * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underyling source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {VectorSource} source Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n * @api\n */\nvar Cluster = /** @class */ (function (_super) {\n    __extends(Cluster, _super);\n    /**\n     * @param {Options} options Cluster options.\n     */\n    function Cluster(options) {\n        var _this = _super.call(this, {\n            attributions: options.attributions,\n            wrapX: options.wrapX\n        }) || this;\n        /**\n         * @type {number|undefined}\n         * @protected\n         */\n        _this.resolution = undefined;\n        /**\n         * @type {number}\n         * @protected\n         */\n        _this.distance = options.distance !== undefined ? options.distance : 20;\n        /**\n         * @type {Array<Feature>}\n         * @protected\n         */\n        _this.features = [];\n        /**\n         * @param {Feature} feature Feature.\n         * @return {Point} Cluster calculation point.\n         * @protected\n         */\n        _this.geometryFunction = options.geometryFunction || function (feature) {\n            var geometry = feature.getGeometry();\n            assert(geometry.getType() == GeometryType.POINT, 10); // The default `geometryFunction` can only handle `Point` geometries\n            return geometry;\n        };\n        /**\n         * @type {VectorSource}\n         * @protected\n         */\n        _this.source = options.source;\n        _this.source.addEventListener(EventType.CHANGE, _this.refresh.bind(_this));\n        return _this;\n    }\n    /**\n     * Get the distance in pixels between clusters.\n     * @return {number} Distance.\n     * @api\n     */\n    Cluster.prototype.getDistance = function () {\n        return this.distance;\n    };\n    /**\n     * Get a reference to the wrapped source.\n     * @return {VectorSource} Source.\n     * @api\n     */\n    Cluster.prototype.getSource = function () {\n        return this.source;\n    };\n    /**\n     * @inheritDoc\n     */\n    Cluster.prototype.loadFeatures = function (extent, resolution, projection) {\n        this.source.loadFeatures(extent, resolution, projection);\n        if (resolution !== this.resolution) {\n            this.clear();\n            this.resolution = resolution;\n            this.cluster();\n            this.addFeatures(this.features);\n        }\n    };\n    /**\n     * Set the distance in pixels between clusters.\n     * @param {number} distance The distance in pixels.\n     * @api\n     */\n    Cluster.prototype.setDistance = function (distance) {\n        this.distance = distance;\n        this.refresh();\n    };\n    /**\n     * handle the source changing\n     * @override\n     */\n    Cluster.prototype.refresh = function () {\n        this.clear();\n        this.cluster();\n        this.addFeatures(this.features);\n    };\n    /**\n     * @protected\n     */\n    Cluster.prototype.cluster = function () {\n        if (this.resolution === undefined) {\n            return;\n        }\n        this.features.length = 0;\n        var extent = createEmpty();\n        var mapDistance = this.distance * this.resolution;\n        var features = this.source.getFeatures();\n        /**\n         * @type {!Object<string, boolean>}\n         */\n        var clustered = {};\n        for (var i = 0, ii = features.length; i < ii; i++) {\n            var feature = features[i];\n            if (!(getUid(feature) in clustered)) {\n                var geometry = this.geometryFunction(feature);\n                if (geometry) {\n                    var coordinates = geometry.getCoordinates();\n                    createOrUpdateFromCoordinate(coordinates, extent);\n                    buffer(extent, mapDistance, extent);\n                    var neighbors = this.source.getFeaturesInExtent(extent);\n                    neighbors = neighbors.filter(function (neighbor) {\n                        var uid = getUid(neighbor);\n                        if (!(uid in clustered)) {\n                            clustered[uid] = true;\n                            return true;\n                        }\n                        else {\n                            return false;\n                        }\n                    });\n                    this.features.push(this.createCluster(neighbors));\n                }\n            }\n        }\n    };\n    /**\n     * @param {Array<Feature>} features Features\n     * @return {Feature} The cluster feature.\n     * @protected\n     */\n    Cluster.prototype.createCluster = function (features) {\n        var centroid = [0, 0];\n        for (var i = features.length - 1; i >= 0; --i) {\n            var geometry = this.geometryFunction(features[i]);\n            if (geometry) {\n                addCoordinate(centroid, geometry.getCoordinates());\n            }\n            else {\n                features.splice(i, 1);\n            }\n        }\n        scaleCoordinate(centroid, 1 / features.length);\n        var cluster = new Feature(new Point(centroid));\n        cluster.set('features', features);\n        return cluster;\n    };\n    return Cluster;\n}(VectorSource));\nexport default Cluster;\n//# sourceMappingURL=Cluster.js.map"]},"metadata":{},"sourceType":"module"}