{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.RBush = factory());\n})(this, function () {\n  'use strict';\n\n  function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);\n  }\n\n  function quickselectStep(arr, k, left, right, compare) {\n    while (right > left) {\n      if (right - left > 600) {\n        var n = right - left + 1;\n        var m = k - left + 1;\n        var z = Math.log(n);\n        var s = 0.5 * Math.exp(2 * z / 3);\n        var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n        var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n        var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n        quickselectStep(arr, k, newLeft, newRight, compare);\n      }\n\n      var t = arr[k];\n      var i = left;\n      var j = right;\n      swap(arr, left, k);\n\n      if (compare(arr[right], t) > 0) {\n        swap(arr, left, right);\n      }\n\n      while (i < j) {\n        swap(arr, i, j);\n        i++;\n        j--;\n\n        while (compare(arr[i], t) < 0) {\n          i++;\n        }\n\n        while (compare(arr[j], t) > 0) {\n          j--;\n        }\n      }\n\n      if (compare(arr[left], t) === 0) {\n        swap(arr, left, j);\n      } else {\n        j++;\n        swap(arr, j, right);\n      }\n\n      if (j <= k) {\n        left = j + 1;\n      }\n\n      if (k <= j) {\n        right = j - 1;\n      }\n    }\n  }\n\n  function swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n  function defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  var RBush = function RBush(maxEntries) {\n    if (maxEntries === void 0) maxEntries = 9; // max entries in a node is 9 by default; min node fill is 40% for best performance\n\n    this._maxEntries = Math.max(4, maxEntries);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n    this.clear();\n  };\n\n  RBush.prototype.all = function all() {\n    return this._all(this.data, []);\n  };\n\n  RBush.prototype.search = function search(bbox) {\n    var node = this.data;\n    var result = [];\n\n    if (!intersects(bbox, node)) {\n      return result;\n    }\n\n    var toBBox = this.toBBox;\n    var nodesToSearch = [];\n\n    while (node) {\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n        var childBBox = node.leaf ? toBBox(child) : child;\n\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf) {\n            result.push(child);\n          } else if (contains(bbox, childBBox)) {\n            this._all(child, result);\n          } else {\n            nodesToSearch.push(child);\n          }\n        }\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return result;\n  };\n\n  RBush.prototype.collides = function collides(bbox) {\n    var node = this.data;\n\n    if (!intersects(bbox, node)) {\n      return false;\n    }\n\n    var nodesToSearch = [];\n\n    while (node) {\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n        var childBBox = node.leaf ? this.toBBox(child) : child;\n\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf || contains(bbox, childBBox)) {\n            return true;\n          }\n\n          nodesToSearch.push(child);\n        }\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return false;\n  };\n\n  RBush.prototype.load = function load(data) {\n    if (!(data && data.length)) {\n      return this;\n    }\n\n    if (data.length < this._minEntries) {\n      for (var i = 0; i < data.length; i++) {\n        this.insert(data[i]);\n      }\n\n      return this;\n    } // recursively build the tree with the given data from scratch using OMT algorithm\n\n\n    var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n    if (!this.data.children.length) {\n      // save as is if tree is empty\n      this.data = node;\n    } else if (this.data.height === node.height) {\n      // split root if trees have the same height\n      this._splitRoot(this.data, node);\n    } else {\n      if (this.data.height < node.height) {\n        // swap trees if inserted one is bigger\n        var tmpNode = this.data;\n        this.data = node;\n        node = tmpNode;\n      } // insert the small tree into the large tree at appropriate level\n\n\n      this._insert(node, this.data.height - node.height - 1, true);\n    }\n\n    return this;\n  };\n\n  RBush.prototype.insert = function insert(item) {\n    if (item) {\n      this._insert(item, this.data.height - 1);\n    }\n\n    return this;\n  };\n\n  RBush.prototype.clear = function clear() {\n    this.data = createNode([]);\n    return this;\n  };\n\n  RBush.prototype.remove = function remove(item, equalsFn) {\n    if (!item) {\n      return this;\n    }\n\n    var node = this.data;\n    var bbox = this.toBBox(item);\n    var path = [];\n    var indexes = [];\n    var i, parent, goingUp; // depth-first iterative tree traversal\n\n    while (node || path.length) {\n      if (!node) {\n        // go up\n        node = path.pop();\n        parent = path[path.length - 1];\n        i = indexes.pop();\n        goingUp = true;\n      }\n\n      if (node.leaf) {\n        // check current node\n        var index = findItem(item, node.children, equalsFn);\n\n        if (index !== -1) {\n          // item found, remove the item and condense tree upwards\n          node.children.splice(index, 1);\n          path.push(node);\n\n          this._condense(path);\n\n          return this;\n        }\n      }\n\n      if (!goingUp && !node.leaf && contains(node, bbox)) {\n        // go down\n        path.push(node);\n        indexes.push(i);\n        i = 0;\n        parent = node;\n        node = node.children[0];\n      } else if (parent) {\n        // go right\n        i++;\n        node = parent.children[i];\n        goingUp = false;\n      } else {\n        node = null;\n      } // nothing found\n\n    }\n\n    return this;\n  };\n\n  RBush.prototype.toBBox = function toBBox(item) {\n    return item;\n  };\n\n  RBush.prototype.compareMinX = function compareMinX(a, b) {\n    return a.minX - b.minX;\n  };\n\n  RBush.prototype.compareMinY = function compareMinY(a, b) {\n    return a.minY - b.minY;\n  };\n\n  RBush.prototype.toJSON = function toJSON() {\n    return this.data;\n  };\n\n  RBush.prototype.fromJSON = function fromJSON(data) {\n    this.data = data;\n    return this;\n  };\n\n  RBush.prototype._all = function _all(node, result) {\n    var nodesToSearch = [];\n\n    while (node) {\n      if (node.leaf) {\n        result.push.apply(result, node.children);\n      } else {\n        nodesToSearch.push.apply(nodesToSearch, node.children);\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return result;\n  };\n\n  RBush.prototype._build = function _build(items, left, right, height) {\n    var N = right - left + 1;\n    var M = this._maxEntries;\n    var node;\n\n    if (N <= M) {\n      // reached leaf level; return leaf\n      node = createNode(items.slice(left, right + 1));\n      calcBBox(node, this.toBBox);\n      return node;\n    }\n\n    if (!height) {\n      // target height of the bulk-loaded tree\n      height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization\n\n      M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height; // split the items into M mostly square tiles\n\n    var N2 = Math.ceil(N / M);\n    var N1 = N2 * Math.ceil(Math.sqrt(M));\n    multiSelect(items, left, right, N1, this.compareMinX);\n\n    for (var i = left; i <= right; i += N1) {\n      var right2 = Math.min(i + N1 - 1, right);\n      multiSelect(items, i, right2, N2, this.compareMinY);\n\n      for (var j = i; j <= right2; j += N2) {\n        var right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively\n\n        node.children.push(this._build(items, j, right3, height - 1));\n      }\n    }\n\n    calcBBox(node, this.toBBox);\n    return node;\n  };\n\n  RBush.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path) {\n    while (true) {\n      path.push(node);\n\n      if (node.leaf || path.length - 1 === level) {\n        break;\n      }\n\n      var minArea = Infinity;\n      var minEnlargement = Infinity;\n      var targetNode = void 0;\n\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n        var area = bboxArea(child);\n        var enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement\n\n        if (enlargement < minEnlargement) {\n          minEnlargement = enlargement;\n          minArea = area < minArea ? area : minArea;\n          targetNode = child;\n        } else if (enlargement === minEnlargement) {\n          // otherwise choose one with the smallest area\n          if (area < minArea) {\n            minArea = area;\n            targetNode = child;\n          }\n        }\n      }\n\n      node = targetNode || node.children[0];\n    }\n\n    return node;\n  };\n\n  RBush.prototype._insert = function _insert(item, level, isNode) {\n    var bbox = isNode ? item : this.toBBox(item);\n    var insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too\n\n    var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node\n\n\n    node.children.push(item);\n    extend(node, bbox); // split on node overflow; propagate upwards if necessary\n\n    while (level >= 0) {\n      if (insertPath[level].children.length > this._maxEntries) {\n        this._split(insertPath, level);\n\n        level--;\n      } else {\n        break;\n      }\n    } // adjust bboxes along the insertion path\n\n\n    this._adjustParentBBoxes(bbox, insertPath, level);\n  }; // split overflowed node into two\n\n\n  RBush.prototype._split = function _split(insertPath, level) {\n    var node = insertPath[level];\n    var M = node.children.length;\n    var m = this._minEntries;\n\n    this._chooseSplitAxis(node, m, M);\n\n    var splitIndex = this._chooseSplitIndex(node, m, M);\n\n    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n\n    if (level) {\n      insertPath[level - 1].children.push(newNode);\n    } else {\n      this._splitRoot(node, newNode);\n    }\n  };\n\n  RBush.prototype._splitRoot = function _splitRoot(node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n  };\n\n  RBush.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m, M) {\n    var index;\n    var minOverlap = Infinity;\n    var minArea = Infinity;\n\n    for (var i = m; i <= M - m; i++) {\n      var bbox1 = distBBox(node, 0, i, this.toBBox);\n      var bbox2 = distBBox(node, i, M, this.toBBox);\n      var overlap = intersectionArea(bbox1, bbox2);\n      var area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap\n\n      if (overlap < minOverlap) {\n        minOverlap = overlap;\n        index = i;\n        minArea = area < minArea ? area : minArea;\n      } else if (overlap === minOverlap) {\n        // otherwise choose distribution with minimum area\n        if (area < minArea) {\n          minArea = area;\n          index = i;\n        }\n      }\n    }\n\n    return index || M - m;\n  }; // sorts node children by the best axis for split\n\n\n  RBush.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m, M) {\n    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n    var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n\n    var xMargin = this._allDistMargin(node, m, M, compareMinX);\n\n    var yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n\n\n    if (xMargin < yMargin) {\n      node.children.sort(compareMinX);\n    }\n  }; // total margin of all possible split distributions where each node is at least m full\n\n\n  RBush.prototype._allDistMargin = function _allDistMargin(node, m, M, compare) {\n    node.children.sort(compare);\n    var toBBox = this.toBBox;\n    var leftBBox = distBBox(node, 0, m, toBBox);\n    var rightBBox = distBBox(node, M - m, M, toBBox);\n    var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n    for (var i = m; i < M - m; i++) {\n      var child = node.children[i];\n      extend(leftBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(leftBBox);\n    }\n\n    for (var i$1 = M - m - 1; i$1 >= m; i$1--) {\n      var child$1 = node.children[i$1];\n      extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);\n      margin += bboxMargin(rightBBox);\n    }\n\n    return margin;\n  };\n\n  RBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (var i = level; i >= 0; i--) {\n      extend(path[i], bbox);\n    }\n  };\n\n  RBush.prototype._condense = function _condense(path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (var i = path.length - 1, siblings = void 0; i >= 0; i--) {\n      if (path[i].children.length === 0) {\n        if (i > 0) {\n          siblings = path[i - 1].children;\n          siblings.splice(siblings.indexOf(path[i]), 1);\n        } else {\n          this.clear();\n        }\n      } else {\n        calcBBox(path[i], this.toBBox);\n      }\n    }\n  };\n\n  function findItem(item, items, equalsFn) {\n    if (!equalsFn) {\n      return items.indexOf(item);\n    }\n\n    for (var i = 0; i < items.length; i++) {\n      if (equalsFn(item, items[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  } // calculate node's bbox from bboxes of its children\n\n\n  function calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n  } // min bounding rectangle of node children from k to p-1\n\n\n  function distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) {\n      destNode = createNode(null);\n    }\n\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k; i < p; i++) {\n      var child = node.children[i];\n      extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n  }\n\n  function extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n  }\n\n  function compareNodeMinX(a, b) {\n    return a.minX - b.minX;\n  }\n\n  function compareNodeMinY(a, b) {\n    return a.minY - b.minY;\n  }\n\n  function bboxArea(a) {\n    return (a.maxX - a.minX) * (a.maxY - a.minY);\n  }\n\n  function bboxMargin(a) {\n    return a.maxX - a.minX + (a.maxY - a.minY);\n  }\n\n  function enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n  }\n\n  function intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX);\n    var minY = Math.max(a.minY, b.minY);\n    var maxX = Math.min(a.maxX, b.maxX);\n    var maxY = Math.min(a.maxY, b.maxY);\n    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n  }\n\n  function contains(a, b) {\n    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n  }\n\n  function intersects(a, b) {\n    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n  }\n\n  function createNode(children) {\n    return {\n      children: children,\n      height: 1,\n      leaf: true,\n      minX: Infinity,\n      minY: Infinity,\n      maxX: -Infinity,\n      maxY: -Infinity\n    };\n  } // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n  // combines selection algorithm with binary divide & conquer approach\n\n\n  function multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right];\n\n    while (stack.length) {\n      right = stack.pop();\n      left = stack.pop();\n\n      if (right - left <= n) {\n        continue;\n      }\n\n      var mid = left + Math.ceil((right - left) / n / 2) * n;\n      quickselect(arr, mid, left, right, compare);\n      stack.push(left, mid, mid, right);\n    }\n  }\n\n  return RBush;\n});","map":{"version":3,"sources":["C:/Users/Tim/IdeaProjects/Adopt_A_Storm_Drain/src/main/frontend/node_modules/rbush/rbush.js"],"names":["global","factory","exports","module","define","amd","self","RBush","quickselect","arr","k","left","right","compare","quickselectStep","length","defaultCompare","n","m","z","Math","log","s","exp","sd","sqrt","newLeft","max","floor","newRight","min","t","i","j","swap","tmp","a","b","maxEntries","_maxEntries","_minEntries","ceil","clear","prototype","all","_all","data","search","bbox","node","result","intersects","toBBox","nodesToSearch","children","child","childBBox","leaf","push","contains","pop","collides","load","insert","_build","slice","height","_splitRoot","tmpNode","_insert","item","createNode","remove","equalsFn","path","indexes","parent","goingUp","index","findItem","splice","_condense","compareMinX","minX","compareMinY","minY","toJSON","fromJSON","apply","items","N","M","calcBBox","pow","N2","N1","multiSelect","right2","right3","_chooseSubtree","level","minArea","Infinity","minEnlargement","targetNode","area","bboxArea","enlargement","enlargedArea","isNode","insertPath","extend","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","compareNodeMinX","compareNodeMinY","xMargin","_allDistMargin","yMargin","sort","leftBBox","rightBBox","margin","bboxMargin","i$1","child$1","siblings","indexOf","p","destNode","maxX","maxY","stack","mid"],"mappings":"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","sourcesContent":["(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\ntypeof define === 'function' && define.amd ? define(factory) :\n(global = global || self, global.RBush = factory());\n}(this, function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) { swap(arr, left, right); }\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) { i++; }\n            while (compare(arr[j], t) > 0) { j--; }\n        }\n\n        if (compare(arr[left], t) === 0) { swap(arr, left, j); }\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) { left = j + 1; }\n        if (k <= j) { right = j - 1; }\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nvar RBush = function RBush(maxEntries) {\n    if ( maxEntries === void 0 ) maxEntries = 9;\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n    this.clear();\n};\n\nRBush.prototype.all = function all () {\n    return this._all(this.data, []);\n};\n\nRBush.prototype.search = function search (bbox) {\n    var node = this.data;\n    var result = [];\n\n    if (!intersects(bbox, node)) { return result; }\n\n    var toBBox = this.toBBox;\n    var nodesToSearch = [];\n\n    while (node) {\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n            var childBBox = node.leaf ? toBBox(child) : child;\n\n            if (intersects(bbox, childBBox)) {\n                if (node.leaf) { result.push(child); }\n                else if (contains(bbox, childBBox)) { this._all(child, result); }\n                else { nodesToSearch.push(child); }\n            }\n        }\n        node = nodesToSearch.pop();\n    }\n\n    return result;\n};\n\nRBush.prototype.collides = function collides (bbox) {\n    var node = this.data;\n\n    if (!intersects(bbox, node)) { return false; }\n\n    var nodesToSearch = [];\n    while (node) {\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n            var childBBox = node.leaf ? this.toBBox(child) : child;\n\n            if (intersects(bbox, childBBox)) {\n                if (node.leaf || contains(bbox, childBBox)) { return true; }\n                nodesToSearch.push(child);\n            }\n        }\n        node = nodesToSearch.pop();\n    }\n\n    return false;\n};\n\nRBush.prototype.load = function load (data) {\n    if (!(data && data.length)) { return this; }\n\n    if (data.length < this._minEntries) {\n        for (var i = 0; i < data.length; i++) {\n            this.insert(data[i]);\n        }\n        return this;\n    }\n\n    // recursively build the tree with the given data from scratch using OMT algorithm\n    var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n    if (!this.data.children.length) {\n        // save as is if tree is empty\n        this.data = node;\n\n    } else if (this.data.height === node.height) {\n        // split root if trees have the same height\n        this._splitRoot(this.data, node);\n\n    } else {\n        if (this.data.height < node.height) {\n            // swap trees if inserted one is bigger\n            var tmpNode = this.data;\n            this.data = node;\n            node = tmpNode;\n        }\n\n        // insert the small tree into the large tree at appropriate level\n        this._insert(node, this.data.height - node.height - 1, true);\n    }\n\n    return this;\n};\n\nRBush.prototype.insert = function insert (item) {\n    if (item) { this._insert(item, this.data.height - 1); }\n    return this;\n};\n\nRBush.prototype.clear = function clear () {\n    this.data = createNode([]);\n    return this;\n};\n\nRBush.prototype.remove = function remove (item, equalsFn) {\n    if (!item) { return this; }\n\n    var node = this.data;\n    var bbox = this.toBBox(item);\n    var path = [];\n    var indexes = [];\n    var i, parent, goingUp;\n\n    // depth-first iterative tree traversal\n    while (node || path.length) {\n\n        if (!node) { // go up\n            node = path.pop();\n            parent = path[path.length - 1];\n            i = indexes.pop();\n            goingUp = true;\n        }\n\n        if (node.leaf) { // check current node\n            var index = findItem(item, node.children, equalsFn);\n\n            if (index !== -1) {\n                // item found, remove the item and condense tree upwards\n                node.children.splice(index, 1);\n                path.push(node);\n                this._condense(path);\n                return this;\n            }\n        }\n\n        if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n            path.push(node);\n            indexes.push(i);\n            i = 0;\n            parent = node;\n            node = node.children[0];\n\n        } else if (parent) { // go right\n            i++;\n            node = parent.children[i];\n            goingUp = false;\n\n        } else { node = null; } // nothing found\n    }\n\n    return this;\n};\n\nRBush.prototype.toBBox = function toBBox (item) { return item; };\n\nRBush.prototype.compareMinX = function compareMinX (a, b) { return a.minX - b.minX; };\nRBush.prototype.compareMinY = function compareMinY (a, b) { return a.minY - b.minY; };\n\nRBush.prototype.toJSON = function toJSON () { return this.data; };\n\nRBush.prototype.fromJSON = function fromJSON (data) {\n    this.data = data;\n    return this;\n};\n\nRBush.prototype._all = function _all (node, result) {\n    var nodesToSearch = [];\n    while (node) {\n        if (node.leaf) { result.push.apply(result, node.children); }\n        else { nodesToSearch.push.apply(nodesToSearch, node.children); }\n\n        node = nodesToSearch.pop();\n    }\n    return result;\n};\n\nRBush.prototype._build = function _build (items, left, right, height) {\n\n    var N = right - left + 1;\n    var M = this._maxEntries;\n    var node;\n\n    if (N <= M) {\n        // reached leaf level; return leaf\n        node = createNode(items.slice(left, right + 1));\n        calcBBox(node, this.toBBox);\n        return node;\n    }\n\n    if (!height) {\n        // target height of the bulk-loaded tree\n        height = Math.ceil(Math.log(N) / Math.log(M));\n\n        // target number of root entries to maximize storage utilization\n        M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height;\n\n    // split the items into M mostly square tiles\n\n    var N2 = Math.ceil(N / M);\n    var N1 = N2 * Math.ceil(Math.sqrt(M));\n\n    multiSelect(items, left, right, N1, this.compareMinX);\n\n    for (var i = left; i <= right; i += N1) {\n\n        var right2 = Math.min(i + N1 - 1, right);\n\n        multiSelect(items, i, right2, N2, this.compareMinY);\n\n        for (var j = i; j <= right2; j += N2) {\n\n            var right3 = Math.min(j + N2 - 1, right2);\n\n            // pack each entry recursively\n            node.children.push(this._build(items, j, right3, height - 1));\n        }\n    }\n\n    calcBBox(node, this.toBBox);\n\n    return node;\n};\n\nRBush.prototype._chooseSubtree = function _chooseSubtree (bbox, node, level, path) {\n    while (true) {\n        path.push(node);\n\n        if (node.leaf || path.length - 1 === level) { break; }\n\n        var minArea = Infinity;\n        var minEnlargement = Infinity;\n        var targetNode = (void 0);\n\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n            var area = bboxArea(child);\n            var enlargement = enlargedArea(bbox, child) - area;\n\n            // choose entry with the least area enlargement\n            if (enlargement < minEnlargement) {\n                minEnlargement = enlargement;\n                minArea = area < minArea ? area : minArea;\n                targetNode = child;\n\n            } else if (enlargement === minEnlargement) {\n                // otherwise choose one with the smallest area\n                if (area < minArea) {\n                    minArea = area;\n                    targetNode = child;\n                }\n            }\n        }\n\n        node = targetNode || node.children[0];\n    }\n\n    return node;\n};\n\nRBush.prototype._insert = function _insert (item, level, isNode) {\n    var bbox = isNode ? item : this.toBBox(item);\n    var insertPath = [];\n\n    // find the best node for accommodating the item, saving all nodes along the path too\n    var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n    // put the item into the node\n    node.children.push(item);\n    extend(node, bbox);\n\n    // split on node overflow; propagate upwards if necessary\n    while (level >= 0) {\n        if (insertPath[level].children.length > this._maxEntries) {\n            this._split(insertPath, level);\n            level--;\n        } else { break; }\n    }\n\n    // adjust bboxes along the insertion path\n    this._adjustParentBBoxes(bbox, insertPath, level);\n};\n\n// split overflowed node into two\nRBush.prototype._split = function _split (insertPath, level) {\n    var node = insertPath[level];\n    var M = node.children.length;\n    var m = this._minEntries;\n\n    this._chooseSplitAxis(node, m, M);\n\n    var splitIndex = this._chooseSplitIndex(node, m, M);\n\n    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n\n    if (level) { insertPath[level - 1].children.push(newNode); }\n    else { this._splitRoot(node, newNode); }\n};\n\nRBush.prototype._splitRoot = function _splitRoot (node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n};\n\nRBush.prototype._chooseSplitIndex = function _chooseSplitIndex (node, m, M) {\n    var index;\n    var minOverlap = Infinity;\n    var minArea = Infinity;\n\n    for (var i = m; i <= M - m; i++) {\n        var bbox1 = distBBox(node, 0, i, this.toBBox);\n        var bbox2 = distBBox(node, i, M, this.toBBox);\n\n        var overlap = intersectionArea(bbox1, bbox2);\n        var area = bboxArea(bbox1) + bboxArea(bbox2);\n\n        // choose distribution with minimum overlap\n        if (overlap < minOverlap) {\n            minOverlap = overlap;\n            index = i;\n\n            minArea = area < minArea ? area : minArea;\n\n        } else if (overlap === minOverlap) {\n            // otherwise choose distribution with minimum area\n            if (area < minArea) {\n                minArea = area;\n                index = i;\n            }\n        }\n    }\n\n    return index || M - m;\n};\n\n// sorts node children by the best axis for split\nRBush.prototype._chooseSplitAxis = function _chooseSplitAxis (node, m, M) {\n    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n    var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n    var xMargin = this._allDistMargin(node, m, M, compareMinX);\n    var yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n    // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n    if (xMargin < yMargin) { node.children.sort(compareMinX); }\n};\n\n// total margin of all possible split distributions where each node is at least m full\nRBush.prototype._allDistMargin = function _allDistMargin (node, m, M, compare) {\n    node.children.sort(compare);\n\n    var toBBox = this.toBBox;\n    var leftBBox = distBBox(node, 0, m, toBBox);\n    var rightBBox = distBBox(node, M - m, M, toBBox);\n    var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n    for (var i = m; i < M - m; i++) {\n        var child = node.children[i];\n        extend(leftBBox, node.leaf ? toBBox(child) : child);\n        margin += bboxMargin(leftBBox);\n    }\n\n    for (var i$1 = M - m - 1; i$1 >= m; i$1--) {\n        var child$1 = node.children[i$1];\n        extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);\n        margin += bboxMargin(rightBBox);\n    }\n\n    return margin;\n};\n\nRBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes (bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (var i = level; i >= 0; i--) {\n        extend(path[i], bbox);\n    }\n};\n\nRBush.prototype._condense = function _condense (path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (var i = path.length - 1, siblings = (void 0); i >= 0; i--) {\n        if (path[i].children.length === 0) {\n            if (i > 0) {\n                siblings = path[i - 1].children;\n                siblings.splice(siblings.indexOf(path[i]), 1);\n\n            } else { this.clear(); }\n\n        } else { calcBBox(path[i], this.toBBox); }\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) { return items.indexOf(item); }\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) { return i; }\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) { destNode = createNode(null); }\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k; i < p; i++) {\n        var child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX);\n    var minY = Math.max(a.minY, b.minY);\n    var maxX = Math.min(a.maxX, b.maxX);\n    var maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) { continue; }\n\n        var mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nreturn RBush;\n\n}));\n"]},"metadata":{},"sourceType":"script"}