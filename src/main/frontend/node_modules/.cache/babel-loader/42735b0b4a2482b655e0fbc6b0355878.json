{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\n\n\nimport { extend } from '../array.js';\nimport Feature from '../Feature.js';\nimport { transformGeometryWithOptions, transformExtentWithOptions } from './Feature.js';\nimport XMLFeature from './XMLFeature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { assign } from '../obj.js';\nimport { get as getProjection } from '../proj.js';\nimport { getAllTextContent, getAttributeNS, makeArrayPusher, makeReplacer, parseNode, pushParseAndPop } from '../xml.js';\n/**\n * @const\n * @type {string}\n */\n\nexport var GMLNS = 'http://www.opengis.net/gml';\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc. The non-breaking\n * space (0xa0) is explicitly included as IE doesn't include it in its\n * definition of `\\s`.\n *\n * Information from `goog.string.isEmptyOrWhitespace`: https://github.com/google/closure-library/blob/e877b1e/closure/goog/string/string.js#L156-L160\n *\n * @const\n * @type {RegExp}\n */\n\nvar ONLY_WHITESPACE_RE = /^[\\s\\xa0]*$/;\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} srsName srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n */\n\nvar GMLBase =\n/** @class */\nfunction (_super) {\n  __extends(GMLBase, _super);\n  /**\n   * @param {Options=} opt_options Optional configuration object.\n   */\n\n\n  function GMLBase(opt_options) {\n    var _this = _super.call(this) || this;\n\n    var options =\n    /** @type {Options} */\n    opt_options ? opt_options : {};\n    /**\n     * @protected\n     * @type {Array<string>|string|undefined}\n     */\n\n    _this.featureType = options.featureType;\n    /**\n     * @protected\n     * @type {Object<string, string>|string|undefined}\n     */\n\n    _this.featureNS = options.featureNS;\n    /**\n     * @protected\n     * @type {string}\n     */\n\n    _this.srsName = options.srsName;\n    /**\n     * @protected\n     * @type {string}\n     */\n\n    _this.schemaLocation = '';\n    /**\n     * @type {Object<string, Object<string, Object>>}\n     */\n\n    _this.FEATURE_COLLECTION_PARSERS = {};\n    _this.FEATURE_COLLECTION_PARSERS[_this.namespace] = {\n      'featureMember': makeArrayPusher(_this.readFeaturesInternal),\n      'featureMembers': makeReplacer(_this.readFeaturesInternal)\n    };\n    return _this;\n  }\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<Feature> | undefined} Features.\n   */\n\n\n  GMLBase.prototype.readFeaturesInternal = function (node, objectStack) {\n    var localName = node.localName;\n    var features = null;\n\n    if (localName == 'FeatureCollection') {\n      features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);\n    } else if (localName == 'featureMembers' || localName == 'featureMember') {\n      var context = objectStack[0];\n      var featureType = context['featureType'];\n      var featureNS = context['featureNS'];\n      var prefix = 'p';\n      var defaultPrefix = 'p0';\n\n      if (!featureType && node.childNodes) {\n        featureType = [], featureNS = {};\n\n        for (var i = 0, ii = node.childNodes.length; i < ii; ++i) {\n          var child = node.childNodes[i];\n\n          if (child.nodeType === 1) {\n            var ft = child.nodeName.split(':').pop();\n\n            if (featureType.indexOf(ft) === -1) {\n              var key = '';\n              var count = 0;\n              var uri = child.namespaceURI;\n\n              for (var candidate in featureNS) {\n                if (featureNS[candidate] === uri) {\n                  key = candidate;\n                  break;\n                }\n\n                ++count;\n              }\n\n              if (!key) {\n                key = prefix + count;\n                featureNS[key] = uri;\n              }\n\n              featureType.push(key + ':' + ft);\n            }\n          }\n        }\n\n        if (localName != 'featureMember') {\n          // recheck featureType for each featureMember\n          context['featureType'] = featureType;\n          context['featureNS'] = featureNS;\n        }\n      }\n\n      if (typeof featureNS === 'string') {\n        var ns = featureNS;\n        featureNS = {};\n        featureNS[defaultPrefix] = ns;\n      }\n      /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n\n\n      var parsersNS = {};\n      var featureTypes = Array.isArray(featureType) ? featureType : [featureType];\n\n      for (var p in featureNS) {\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        var parsers = {};\n\n        for (var i = 0, ii = featureTypes.length; i < ii; ++i) {\n          var featurePrefix = featureTypes[i].indexOf(':') === -1 ? defaultPrefix : featureTypes[i].split(':')[0];\n\n          if (featurePrefix === p) {\n            parsers[featureTypes[i].split(':').pop()] = localName == 'featureMembers' ? makeArrayPusher(this.readFeatureElement, this) : makeReplacer(this.readFeatureElement, this);\n          }\n        }\n\n        parsersNS[featureNS[p]] = parsers;\n      }\n\n      if (localName == 'featureMember') {\n        features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n      } else {\n        features = pushParseAndPop([], parsersNS, node, objectStack);\n      }\n    }\n\n    if (features === null) {\n      features = [];\n    }\n\n    return features;\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n\n\n  GMLBase.prototype.readGeometryElement = function (node, objectStack) {\n    var context =\n    /** @type {Object} */\n    objectStack[0];\n    context['srsName'] = node.firstElementChild.getAttribute('srsName');\n    context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');\n    var geometry = pushParseAndPop(null, this.GEOMETRY_PARSERS, node, objectStack, this);\n\n    if (geometry) {\n      if (Array.isArray(geometry)) {\n        return transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */\n        geometry, context);\n      } else {\n        return transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */\n        geometry, false, context);\n      }\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {boolean} asFeature whether result should be wrapped as a feature.\n   * @return {Feature|Object} Feature\n   */\n\n\n  GMLBase.prototype.readFeatureElementInternal = function (node, objectStack, asFeature) {\n    var geometryName;\n    var values = {};\n\n    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {\n      var value = void 0;\n      var localName = n.localName; // first, check if it is simple attribute\n\n      if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {\n        value = getAllTextContent(n, false);\n\n        if (ONLY_WHITESPACE_RE.test(value)) {\n          value = undefined;\n        }\n      } else {\n        if (asFeature) {\n          //if feature, try it as a geometry\n          value = this.readGeometryElement(n, objectStack);\n        }\n\n        if (!value) {\n          //if not a geometry or not a feature, treat it as a complex attribute\n          value = this.readFeatureElementInternal(n, objectStack, false);\n        } else if (localName !== 'boundedBy') {\n          // boundedBy is an extent and must not be considered as a geometry\n          geometryName = localName;\n        }\n      }\n\n      if (values[localName]) {\n        if (!(values[localName] instanceof Array)) {\n          values[localName] = [values[localName]];\n        }\n\n        values[localName].push(value);\n      } else {\n        values[localName] = value;\n      }\n\n      var len = n.attributes.length;\n\n      if (len > 0) {\n        values[localName] = {\n          _content_: values[localName]\n        };\n\n        for (var i = 0; i < len; i++) {\n          var attName = n.attributes[i].name;\n          values[localName][attName] = n.attributes[i].value;\n        }\n      }\n    }\n\n    if (!asFeature) {\n      return values;\n    } else {\n      var feature = new Feature(values);\n\n      if (geometryName) {\n        feature.setGeometryName(geometryName);\n      }\n\n      var fid = node.getAttribute('fid') || getAttributeNS(node, this.namespace, 'id');\n\n      if (fid) {\n        feature.setId(fid);\n      }\n\n      return feature;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Feature} Feature.\n   */\n\n\n  GMLBase.prototype.readFeatureElement = function (node, objectStack) {\n    return this.readFeatureElementInternal(node, objectStack, true);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Point|undefined} Point.\n   */\n\n\n  GMLBase.prototype.readPoint = function (node, objectStack) {\n    var flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);\n\n    if (flatCoordinates) {\n      return new Point(flatCoordinates, GeometryLayout.XYZ);\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPoint|undefined} MultiPoint.\n   */\n\n\n  GMLBase.prototype.readMultiPoint = function (node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    var coordinates = pushParseAndPop([], this.MULTIPOINT_PARSERS_, node, objectStack, this);\n\n    if (coordinates) {\n      return new MultiPoint(coordinates);\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n\n\n  GMLBase.prototype.readMultiLineString = function (node, objectStack) {\n    /** @type {Array<LineString>} */\n    var lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS_, node, objectStack, this);\n\n    if (lineStrings) {\n      return new MultiLineString(lineStrings);\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n\n\n  GMLBase.prototype.readMultiPolygon = function (node, objectStack) {\n    /** @type {Array<Polygon>} */\n    var polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS_, node, objectStack, this);\n\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n\n\n  GMLBase.prototype.pointMemberParser_ = function (node, objectStack) {\n    parseNode(this.POINTMEMBER_PARSERS_, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n\n\n  GMLBase.prototype.lineStringMemberParser_ = function (node, objectStack) {\n    parseNode(this.LINESTRINGMEMBER_PARSERS_, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n\n\n  GMLBase.prototype.polygonMemberParser_ = function (node, objectStack) {\n    parseNode(this.POLYGONMEMBER_PARSERS_, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n\n\n  GMLBase.prototype.readLineString = function (node, objectStack) {\n    var flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);\n\n    if (flatCoordinates) {\n      var lineString = new LineString(flatCoordinates, GeometryLayout.XYZ);\n      return lineString;\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<number>|undefined} LinearRing flat coordinates.\n   */\n\n\n  GMLBase.prototype.readFlatLinearRing_ = function (node, objectStack) {\n    var ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n\n    if (ring) {\n      return ring;\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LinearRing|undefined} LinearRing.\n   */\n\n\n  GMLBase.prototype.readLinearRing = function (node, objectStack) {\n    var flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);\n\n    if (flatCoordinates) {\n      return new LinearRing(flatCoordinates, GeometryLayout.XYZ);\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n\n\n  GMLBase.prototype.readPolygon = function (node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    var flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);\n\n    if (flatLinearRings && flatLinearRings[0]) {\n      var flatCoordinates = flatLinearRings[0];\n      var ends = [flatCoordinates.length];\n      var i = void 0,\n          ii = void 0;\n\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n\n      return new Polygon(flatCoordinates, GeometryLayout.XYZ, ends);\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<number>} Flat coordinates.\n   */\n\n\n  GMLBase.prototype.readFlatCoordinatesFromNode_ = function (node, objectStack) {\n    return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n  };\n  /**\n   * @inheritDoc\n   */\n  //@ts-ignore\n\n\n  GMLBase.prototype.readGeometryFromNode = function (node, opt_options) {\n    var geometry = this.readGeometryElement(node, [this.getReadOptions(node, opt_options ? opt_options : {})]);\n    return geometry ? geometry : null;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  GMLBase.prototype.readFeaturesFromNode = function (node, opt_options) {\n    var options = {\n      featureType: this.featureType,\n      featureNS: this.featureNS\n    };\n\n    if (opt_options) {\n      assign(options, this.getReadOptions(node, opt_options));\n    }\n\n    var features = this.readFeaturesInternal(node, [options]);\n    return features || [];\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  GMLBase.prototype.readProjectionFromNode = function (node) {\n    return getProjection(this.srsName ? this.srsName : node.firstElementChild.getAttribute('srsName'));\n  };\n\n  return GMLBase;\n}(XMLFeature);\n\nGMLBase.prototype.namespace = GMLNS;\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\n\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {}\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\n\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {}\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\n\nGMLBase.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {}\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGMLBase.prototype.MULTIPOINT_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser_),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGMLBase.prototype.MULTILINESTRING_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeArrayPusher(GMLBase.prototype.lineStringMemberParser_),\n    'lineStringMembers': makeArrayPusher(GMLBase.prototype.lineStringMemberParser_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGMLBase.prototype.MULTIPOLYGON_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser_),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGMLBase.prototype.POINTMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGMLBase.prototype.POLYGONMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\n\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing_)\n  }\n};\nexport default GMLBase;","map":{"version":3,"sources":["../src/format/GMLBase.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\nimport { extend } from '../array.js';\nimport Feature from '../Feature.js';\nimport { transformGeometryWithOptions, transformExtentWithOptions } from './Feature.js';\nimport XMLFeature from './XMLFeature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { assign } from '../obj.js';\nimport { get as getProjection } from '../proj.js';\nimport { getAllTextContent, getAttributeNS, makeArrayPusher, makeReplacer, parseNode, pushParseAndPop } from '../xml.js';\n/**\n * @const\n * @type {string}\n */\nexport var GMLNS = 'http://www.opengis.net/gml';\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc. The non-breaking\n * space (0xa0) is explicitly included as IE doesn't include it in its\n * definition of `\\s`.\n *\n * Information from `goog.string.isEmptyOrWhitespace`: https://github.com/google/closure-library/blob/e877b1e/closure/goog/string/string.js#L156-L160\n *\n * @const\n * @type {RegExp}\n */\nvar ONLY_WHITESPACE_RE = /^[\\s\\xa0]*$/;\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} srsName srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n */\nvar GMLBase = /** @class */ (function (_super) {\n    __extends(GMLBase, _super);\n    /**\n     * @param {Options=} opt_options Optional configuration object.\n     */\n    function GMLBase(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = /** @type {Options} */ (opt_options ? opt_options : {});\n        /**\n         * @protected\n         * @type {Array<string>|string|undefined}\n         */\n        _this.featureType = options.featureType;\n        /**\n         * @protected\n         * @type {Object<string, string>|string|undefined}\n         */\n        _this.featureNS = options.featureNS;\n        /**\n         * @protected\n         * @type {string}\n         */\n        _this.srsName = options.srsName;\n        /**\n         * @protected\n         * @type {string}\n         */\n        _this.schemaLocation = '';\n        /**\n         * @type {Object<string, Object<string, Object>>}\n         */\n        _this.FEATURE_COLLECTION_PARSERS = {};\n        _this.FEATURE_COLLECTION_PARSERS[_this.namespace] = {\n            'featureMember': makeArrayPusher(_this.readFeaturesInternal),\n            'featureMembers': makeReplacer(_this.readFeaturesInternal)\n        };\n        return _this;\n    }\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<Feature> | undefined} Features.\n     */\n    GMLBase.prototype.readFeaturesInternal = function (node, objectStack) {\n        var localName = node.localName;\n        var features = null;\n        if (localName == 'FeatureCollection') {\n            features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);\n        }\n        else if (localName == 'featureMembers' || localName == 'featureMember') {\n            var context = objectStack[0];\n            var featureType = context['featureType'];\n            var featureNS = context['featureNS'];\n            var prefix = 'p';\n            var defaultPrefix = 'p0';\n            if (!featureType && node.childNodes) {\n                featureType = [], featureNS = {};\n                for (var i = 0, ii = node.childNodes.length; i < ii; ++i) {\n                    var child = node.childNodes[i];\n                    if (child.nodeType === 1) {\n                        var ft = child.nodeName.split(':').pop();\n                        if (featureType.indexOf(ft) === -1) {\n                            var key = '';\n                            var count = 0;\n                            var uri = child.namespaceURI;\n                            for (var candidate in featureNS) {\n                                if (featureNS[candidate] === uri) {\n                                    key = candidate;\n                                    break;\n                                }\n                                ++count;\n                            }\n                            if (!key) {\n                                key = prefix + count;\n                                featureNS[key] = uri;\n                            }\n                            featureType.push(key + ':' + ft);\n                        }\n                    }\n                }\n                if (localName != 'featureMember') {\n                    // recheck featureType for each featureMember\n                    context['featureType'] = featureType;\n                    context['featureNS'] = featureNS;\n                }\n            }\n            if (typeof featureNS === 'string') {\n                var ns = featureNS;\n                featureNS = {};\n                featureNS[defaultPrefix] = ns;\n            }\n            /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n            var parsersNS = {};\n            var featureTypes = Array.isArray(featureType) ? featureType : [featureType];\n            for (var p in featureNS) {\n                /** @type {Object<string, import(\"../xml.js\").Parser>} */\n                var parsers = {};\n                for (var i = 0, ii = featureTypes.length; i < ii; ++i) {\n                    var featurePrefix = featureTypes[i].indexOf(':') === -1 ?\n                        defaultPrefix : featureTypes[i].split(':')[0];\n                    if (featurePrefix === p) {\n                        parsers[featureTypes[i].split(':').pop()] =\n                            (localName == 'featureMembers') ?\n                                makeArrayPusher(this.readFeatureElement, this) :\n                                makeReplacer(this.readFeatureElement, this);\n                    }\n                }\n                parsersNS[featureNS[p]] = parsers;\n            }\n            if (localName == 'featureMember') {\n                features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n            }\n            else {\n                features = pushParseAndPop([], parsersNS, node, objectStack);\n            }\n        }\n        if (features === null) {\n            features = [];\n        }\n        return features;\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n     */\n    GMLBase.prototype.readGeometryElement = function (node, objectStack) {\n        var context = /** @type {Object} */ (objectStack[0]);\n        context['srsName'] = node.firstElementChild.getAttribute('srsName');\n        context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');\n        var geometry = pushParseAndPop(null, this.GEOMETRY_PARSERS, node, objectStack, this);\n        if (geometry) {\n            if (Array.isArray(geometry)) {\n                return transformExtentWithOptions(/** @type {import(\"../extent.js\").Extent} */ (geometry), context);\n            }\n            else {\n                return transformGeometryWithOptions(/** @type {import(\"../geom/Geometry.js\").default} */ (geometry), false, context);\n            }\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {boolean} asFeature whether result should be wrapped as a feature.\n     * @return {Feature|Object} Feature\n     */\n    GMLBase.prototype.readFeatureElementInternal = function (node, objectStack, asFeature) {\n        var geometryName;\n        var values = {};\n        for (var n = node.firstElementChild; n; n = n.nextElementSibling) {\n            var value = void 0;\n            var localName = n.localName;\n            // first, check if it is simple attribute\n            if (n.childNodes.length === 0\n                || (n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))) {\n                value = getAllTextContent(n, false);\n                if (ONLY_WHITESPACE_RE.test(value)) {\n                    value = undefined;\n                }\n            }\n            else {\n                if (asFeature) {\n                    //if feature, try it as a geometry\n                    value = this.readGeometryElement(n, objectStack);\n                }\n                if (!value) { //if not a geometry or not a feature, treat it as a complex attribute\n                    value = this.readFeatureElementInternal(n, objectStack, false);\n                }\n                else if (localName !== 'boundedBy') {\n                    // boundedBy is an extent and must not be considered as a geometry\n                    geometryName = localName;\n                }\n            }\n            if (values[localName]) {\n                if (!(values[localName] instanceof Array)) {\n                    values[localName] = [values[localName]];\n                }\n                values[localName].push(value);\n            }\n            else {\n                values[localName] = value;\n            }\n            var len = n.attributes.length;\n            if (len > 0) {\n                values[localName] = { _content_: values[localName] };\n                for (var i = 0; i < len; i++) {\n                    var attName = n.attributes[i].name;\n                    values[localName][attName] = n.attributes[i].value;\n                }\n            }\n        }\n        if (!asFeature) {\n            return values;\n        }\n        else {\n            var feature = new Feature(values);\n            if (geometryName) {\n                feature.setGeometryName(geometryName);\n            }\n            var fid = node.getAttribute('fid') ||\n                getAttributeNS(node, this.namespace, 'id');\n            if (fid) {\n                feature.setId(fid);\n            }\n            return feature;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Feature} Feature.\n     */\n    GMLBase.prototype.readFeatureElement = function (node, objectStack) {\n        return this.readFeatureElementInternal(node, objectStack, true);\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Point|undefined} Point.\n     */\n    GMLBase.prototype.readPoint = function (node, objectStack) {\n        var flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);\n        if (flatCoordinates) {\n            return new Point(flatCoordinates, GeometryLayout.XYZ);\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {MultiPoint|undefined} MultiPoint.\n     */\n    GMLBase.prototype.readMultiPoint = function (node, objectStack) {\n        /** @type {Array<Array<number>>} */\n        var coordinates = pushParseAndPop([], this.MULTIPOINT_PARSERS_, node, objectStack, this);\n        if (coordinates) {\n            return new MultiPoint(coordinates);\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {MultiLineString|undefined} MultiLineString.\n     */\n    GMLBase.prototype.readMultiLineString = function (node, objectStack) {\n        /** @type {Array<LineString>} */\n        var lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS_, node, objectStack, this);\n        if (lineStrings) {\n            return new MultiLineString(lineStrings);\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {MultiPolygon|undefined} MultiPolygon.\n     */\n    GMLBase.prototype.readMultiPolygon = function (node, objectStack) {\n        /** @type {Array<Polygon>} */\n        var polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS_, node, objectStack, this);\n        if (polygons) {\n            return new MultiPolygon(polygons);\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @private\n     */\n    GMLBase.prototype.pointMemberParser_ = function (node, objectStack) {\n        parseNode(this.POINTMEMBER_PARSERS_, node, objectStack, this);\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @private\n     */\n    GMLBase.prototype.lineStringMemberParser_ = function (node, objectStack) {\n        parseNode(this.LINESTRINGMEMBER_PARSERS_, node, objectStack, this);\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @private\n     */\n    GMLBase.prototype.polygonMemberParser_ = function (node, objectStack) {\n        parseNode(this.POLYGONMEMBER_PARSERS_, node, objectStack, this);\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {LineString|undefined} LineString.\n     */\n    GMLBase.prototype.readLineString = function (node, objectStack) {\n        var flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);\n        if (flatCoordinates) {\n            var lineString = new LineString(flatCoordinates, GeometryLayout.XYZ);\n            return lineString;\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @private\n     * @return {Array<number>|undefined} LinearRing flat coordinates.\n     */\n    GMLBase.prototype.readFlatLinearRing_ = function (node, objectStack) {\n        var ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n        if (ring) {\n            return ring;\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {LinearRing|undefined} LinearRing.\n     */\n    GMLBase.prototype.readLinearRing = function (node, objectStack) {\n        var flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);\n        if (flatCoordinates) {\n            return new LinearRing(flatCoordinates, GeometryLayout.XYZ);\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Polygon|undefined} Polygon.\n     */\n    GMLBase.prototype.readPolygon = function (node, objectStack) {\n        /** @type {Array<Array<number>>} */\n        var flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);\n        if (flatLinearRings && flatLinearRings[0]) {\n            var flatCoordinates = flatLinearRings[0];\n            var ends = [flatCoordinates.length];\n            var i = void 0, ii = void 0;\n            for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n                extend(flatCoordinates, flatLinearRings[i]);\n                ends.push(flatCoordinates.length);\n            }\n            return new Polygon(flatCoordinates, GeometryLayout.XYZ, ends);\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @private\n     * @return {Array<number>} Flat coordinates.\n     */\n    GMLBase.prototype.readFlatCoordinatesFromNode_ = function (node, objectStack) {\n        return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n    };\n    /**\n     * @inheritDoc\n     */\n    //@ts-ignore\n    GMLBase.prototype.readGeometryFromNode = function (node, opt_options) {\n        var geometry = this.readGeometryElement(node, [this.getReadOptions(node, opt_options ? opt_options : {})]);\n        return geometry ? geometry : null;\n    };\n    /**\n     * @inheritDoc\n     */\n    GMLBase.prototype.readFeaturesFromNode = function (node, opt_options) {\n        var options = {\n            featureType: this.featureType,\n            featureNS: this.featureNS\n        };\n        if (opt_options) {\n            assign(options, this.getReadOptions(node, opt_options));\n        }\n        var features = this.readFeaturesInternal(node, [options]);\n        return features || [];\n    };\n    /**\n     * @inheritDoc\n     */\n    GMLBase.prototype.readProjectionFromNode = function (node) {\n        return getProjection(this.srsName ? this.srsName : node.firstElementChild.getAttribute('srsName'));\n    };\n    return GMLBase;\n}(XMLFeature));\nGMLBase.prototype.namespace = GMLNS;\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n    'http://www.opengis.net/gml': {}\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n    'http://www.opengis.net/gml': {}\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\nGMLBase.prototype.GEOMETRY_PARSERS = {\n    'http://www.opengis.net/gml': {}\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGMLBase.prototype.MULTIPOINT_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n        'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser_),\n        'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser_)\n    }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGMLBase.prototype.MULTILINESTRING_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n        'lineStringMember': makeArrayPusher(GMLBase.prototype.lineStringMemberParser_),\n        'lineStringMembers': makeArrayPusher(GMLBase.prototype.lineStringMemberParser_)\n    }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGMLBase.prototype.MULTIPOLYGON_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n        'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser_),\n        'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser_)\n    }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGMLBase.prototype.POINTMEMBER_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n        'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode_)\n    }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n        'LineString': makeArrayPusher(GMLBase.prototype.readLineString)\n    }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGMLBase.prototype.POLYGONMEMBER_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n        'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon)\n    }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\nGMLBase.prototype.RING_PARSERS = {\n    'http://www.opengis.net/gml': {\n        'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing_)\n    }\n};\nexport default GMLBase;\n//# sourceMappingURL=GMLBase.js.map"]},"metadata":{},"sourceType":"module"}