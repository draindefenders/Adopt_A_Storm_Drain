{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/format/WMSGetFeatureInfo\n */\n\n\nimport { extend, includes } from '../array.js';\nimport GML2 from './GML2.js';\nimport XMLFeature from './XMLFeature.js';\nimport { assign } from '../obj.js';\nimport { makeArrayPusher, makeStructureNS, pushParseAndPop } from '../xml.js';\n/**\n * @typedef {Object} Options\n * @property {Array<string>} [layers] If set, only features of the given layers will be returned by the format when read.\n */\n\n/**\n * @const\n * @type {string}\n */\n\nvar featureIdentifier = '_feature';\n/**\n * @const\n * @type {string}\n */\n\nvar layerIdentifier = '_layer';\n/**\n * @classdesc\n * Format for reading WMSGetFeatureInfo format. It uses\n * {@link module:ol/format/GML2~GML2} to read features.\n *\n * @api\n */\n\nvar WMSGetFeatureInfo =\n/** @class */\nfunction (_super) {\n  __extends(WMSGetFeatureInfo, _super);\n  /**\n   * @param {Options=} opt_options Options.\n   */\n\n\n  function WMSGetFeatureInfo(opt_options) {\n    var _this = _super.call(this) || this;\n\n    var options = opt_options ? opt_options : {};\n    /**\n     * @private\n     * @type {string}\n     */\n\n    _this.featureNS_ = 'http://mapserver.gis.umn.edu/mapserver';\n    /**\n     * @private\n     * @type {GML2}\n     */\n\n    _this.gmlFormat_ = new GML2();\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n\n    _this.layers_ = options.layers ? options.layers : null;\n    return _this;\n  }\n  /**\n   * @return {Array<string>} layers\n   */\n\n\n  WMSGetFeatureInfo.prototype.getLayers = function () {\n    return this.layers_;\n  };\n  /**\n   * @param {Array<string>} layers Layers to parse.\n   */\n\n\n  WMSGetFeatureInfo.prototype.setLayers = function (layers) {\n    this.layers_ = layers;\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n\n\n  WMSGetFeatureInfo.prototype.readFeatures_ = function (node, objectStack) {\n    node.setAttribute('namespaceURI', this.featureNS_);\n    var localName = node.localName;\n    /** @type {Array<import(\"../Feature.js\").default>} */\n\n    var features = [];\n\n    if (node.childNodes.length === 0) {\n      return features;\n    }\n\n    if (localName == 'msGMLOutput') {\n      for (var i = 0, ii = node.childNodes.length; i < ii; i++) {\n        var layer = node.childNodes[i];\n\n        if (layer.nodeType !== Node.ELEMENT_NODE) {\n          continue;\n        }\n\n        var layerElement =\n        /** @type {Element} */\n        layer;\n        var context = objectStack[0];\n        var toRemove = layerIdentifier;\n        var layerName = layerElement.localName.replace(toRemove, '');\n\n        if (this.layers_ && !includes(this.layers_, layerName)) {\n          continue;\n        }\n\n        var featureType = layerName + featureIdentifier;\n        context['featureType'] = featureType;\n        context['featureNS'] = this.featureNS_;\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n\n        var parsers = {};\n        parsers[featureType] = makeArrayPusher(this.gmlFormat_.readFeatureElement, this.gmlFormat_);\n        var parsersNS = makeStructureNS([context['featureNS'], null], parsers);\n        layerElement.setAttribute('namespaceURI', this.featureNS_);\n        var layerFeatures = pushParseAndPop( // @ts-ignore\n        [], parsersNS, layerElement, objectStack, this.gmlFormat_);\n\n        if (layerFeatures) {\n          extend(features, layerFeatures);\n        }\n      }\n    }\n\n    if (localName == 'FeatureCollection') {\n      var gmlFeatures = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, [{}], this.gmlFormat_);\n\n      if (gmlFeatures) {\n        features = gmlFeatures;\n      }\n    }\n\n    return features;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WMSGetFeatureInfo.prototype.readFeaturesFromNode = function (node, opt_options) {\n    var options = {};\n\n    if (opt_options) {\n      assign(options, this.getReadOptions(node, opt_options));\n    }\n\n    return this.readFeatures_(node, [options]);\n  };\n\n  return WMSGetFeatureInfo;\n}(XMLFeature);\n\nexport default WMSGetFeatureInfo;","map":{"version":3,"sources":["../src/format/WMSGetFeatureInfo.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/WMSGetFeatureInfo\n */\nimport { extend, includes } from '../array.js';\nimport GML2 from './GML2.js';\nimport XMLFeature from './XMLFeature.js';\nimport { assign } from '../obj.js';\nimport { makeArrayPusher, makeStructureNS, pushParseAndPop } from '../xml.js';\n/**\n * @typedef {Object} Options\n * @property {Array<string>} [layers] If set, only features of the given layers will be returned by the format when read.\n */\n/**\n * @const\n * @type {string}\n */\nvar featureIdentifier = '_feature';\n/**\n * @const\n * @type {string}\n */\nvar layerIdentifier = '_layer';\n/**\n * @classdesc\n * Format for reading WMSGetFeatureInfo format. It uses\n * {@link module:ol/format/GML2~GML2} to read features.\n *\n * @api\n */\nvar WMSGetFeatureInfo = /** @class */ (function (_super) {\n    __extends(WMSGetFeatureInfo, _super);\n    /**\n     * @param {Options=} opt_options Options.\n     */\n    function WMSGetFeatureInfo(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.featureNS_ = 'http://mapserver.gis.umn.edu/mapserver';\n        /**\n         * @private\n         * @type {GML2}\n         */\n        _this.gmlFormat_ = new GML2();\n        /**\n         * @private\n         * @type {Array<string>}\n         */\n        _this.layers_ = options.layers ? options.layers : null;\n        return _this;\n    }\n    /**\n     * @return {Array<string>} layers\n     */\n    WMSGetFeatureInfo.prototype.getLayers = function () {\n        return this.layers_;\n    };\n    /**\n     * @param {Array<string>} layers Layers to parse.\n     */\n    WMSGetFeatureInfo.prototype.setLayers = function (layers) {\n        this.layers_ = layers;\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<import(\"../Feature.js\").default>} Features.\n     * @private\n     */\n    WMSGetFeatureInfo.prototype.readFeatures_ = function (node, objectStack) {\n        node.setAttribute('namespaceURI', this.featureNS_);\n        var localName = node.localName;\n        /** @type {Array<import(\"../Feature.js\").default>} */\n        var features = [];\n        if (node.childNodes.length === 0) {\n            return features;\n        }\n        if (localName == 'msGMLOutput') {\n            for (var i = 0, ii = node.childNodes.length; i < ii; i++) {\n                var layer = node.childNodes[i];\n                if (layer.nodeType !== Node.ELEMENT_NODE) {\n                    continue;\n                }\n                var layerElement = /** @type {Element} */ (layer);\n                var context = objectStack[0];\n                var toRemove = layerIdentifier;\n                var layerName = layerElement.localName.replace(toRemove, '');\n                if (this.layers_ && !includes(this.layers_, layerName)) {\n                    continue;\n                }\n                var featureType = layerName +\n                    featureIdentifier;\n                context['featureType'] = featureType;\n                context['featureNS'] = this.featureNS_;\n                /** @type {Object<string, import(\"../xml.js\").Parser>} */\n                var parsers = {};\n                parsers[featureType] = makeArrayPusher(this.gmlFormat_.readFeatureElement, this.gmlFormat_);\n                var parsersNS = makeStructureNS([context['featureNS'], null], parsers);\n                layerElement.setAttribute('namespaceURI', this.featureNS_);\n                var layerFeatures = pushParseAndPop(\n                // @ts-ignore\n                [], parsersNS, layerElement, objectStack, this.gmlFormat_);\n                if (layerFeatures) {\n                    extend(features, layerFeatures);\n                }\n            }\n        }\n        if (localName == 'FeatureCollection') {\n            var gmlFeatures = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, [{}], this.gmlFormat_);\n            if (gmlFeatures) {\n                features = gmlFeatures;\n            }\n        }\n        return features;\n    };\n    /**\n     * @inheritDoc\n     */\n    WMSGetFeatureInfo.prototype.readFeaturesFromNode = function (node, opt_options) {\n        var options = {};\n        if (opt_options) {\n            assign(options, this.getReadOptions(node, opt_options));\n        }\n        return this.readFeatures_(node, [options]);\n    };\n    return WMSGetFeatureInfo;\n}(XMLFeature));\nexport default WMSGetFeatureInfo;\n//# sourceMappingURL=WMSGetFeatureInfo.js.map"]},"metadata":{},"sourceType":"module"}