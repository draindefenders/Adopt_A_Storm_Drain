{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/reproj/Tile\n */\n\n\nimport { ERROR_THRESHOLD } from './common.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { getArea, getCenter, getIntersection } from '../extent.js';\nimport { clamp } from '../math.js';\nimport { calculateSourceResolution, render as renderReprojected } from '../reproj.js';\nimport Triangulation from './Triangulation.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\n\nvar ReprojTile =\n/** @class */\nfunction (_super) {\n  __extends(ReprojTile, _super);\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\n   * @param {boolean=} opt_renderEdges Render reprojection edges.\n   */\n\n\n  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {\n    var _this = _super.call(this, tileCoord, TileState.IDLE) || this;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n\n    _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.gutter_ = gutter;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    _this.canvas_ = null;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n\n    _this.sourceTileGrid_ = sourceTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n\n    _this.targetTileGrid_ = targetTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n\n    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n\n    _this.sourceTiles_ = [];\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n\n    _this.sourcesListenerKeys_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n\n    var maxTargetExtent = _this.targetTileGrid_.getExtent();\n\n    var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n\n    var sourceProjExtent = sourceProj.getExtent();\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n    var targetCenter = getCenter(limitedTargetExtent);\n    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n\n    _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);\n\n    if (_this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n\n    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n\n    var sourceExtent = _this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      _this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n\n          if (tile) {\n            _this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (_this.sourceTiles_.length === 0) {\n        _this.state = TileState.EMPTY;\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n\n\n  ReprojTile.prototype.getImage = function () {\n    return this.canvas_;\n  };\n  /**\n   * @private\n   */\n\n\n  ReprojTile.prototype.reproject_ = function () {\n    var sources = [];\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);\n      this.state = TileState.LOADED;\n    }\n\n    this.changed();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ReprojTile.prototype.load = function () {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      var leftToLoad_1 = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad_1++;\n          var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n            var state = tile.getState();\n\n            if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n              unlistenByKey(sourceListenKey_1);\n              leftToLoad_1--;\n\n              if (leftToLoad_1 === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey_1);\n        }\n      }.bind(this));\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n\n      if (leftToLoad_1 === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  ReprojTile.prototype.unlistenSources_ = function () {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n\n  return ReprojTile;\n}(Tile);\n\nexport default ReprojTile;","map":{"version":3,"sources":["../src/reproj/Tile.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { getArea, getCenter, getIntersection } from '../extent.js';\nimport { clamp } from '../math.js';\nimport { calculateSourceResolution, render as renderReprojected } from '../reproj.js';\nimport Triangulation from './Triangulation.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /** @class */ (function (_super) {\n    __extends(ReprojTile, _super);\n    /**\n     * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n     * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n     * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {number} gutter Gutter of the source tiles.\n     * @param {FunctionType} getTileFunction\n     *     Function returning source tiles (z, x, y, pixelRatio).\n     * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\n     * @param {boolean=} opt_renderEdges Render reprojection edges.\n     */\n    function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {\n        var _this = _super.call(this, tileCoord, TileState.IDLE) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.gutter_ = gutter;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.canvas_ = null;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.sourceTileGrid_ = sourceTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.targetTileGrid_ = targetTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilecoord.js\").TileCoord}\n         */\n        _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n        /**\n         * @private\n         * @type {!Array<import(\"../Tile.js\").default>}\n         */\n        _this.sourceTiles_ = [];\n        /**\n         * @private\n         * @type {?Array<import(\"../events.js\").EventsKey>}\n         */\n        _this.sourcesListenerKeys_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.sourceZ_ = 0;\n        var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n        var maxTargetExtent = _this.targetTileGrid_.getExtent();\n        var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n        var limitedTargetExtent = maxTargetExtent ?\n            getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n        if (getArea(limitedTargetExtent) === 0) {\n            // Tile is completely outside range -> EMPTY\n            // TODO: is it actually correct that the source even creates the tile ?\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var sourceProjExtent = sourceProj.getExtent();\n        if (sourceProjExtent) {\n            if (!maxSourceExtent) {\n                maxSourceExtent = sourceProjExtent;\n            }\n            else {\n                maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n            }\n        }\n        var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n        var targetCenter = getCenter(limitedTargetExtent);\n        var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n        if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n            // invalid sourceResolution -> EMPTY\n            // probably edges of the projections when no extent is defined\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var errorThresholdInPixels = opt_errorThreshold !== undefined ?\n            opt_errorThreshold : ERROR_THRESHOLD;\n        /**\n         * @private\n         * @type {!import(\"./Triangulation.js\").default}\n         */\n        _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);\n        if (_this.triangulation_.getTriangles().length === 0) {\n            // no valid triangles -> EMPTY\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n        var sourceExtent = _this.triangulation_.calculateSourceExtent();\n        if (maxSourceExtent) {\n            if (sourceProj.canWrapX()) {\n                sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n                sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n            }\n            else {\n                sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n            }\n        }\n        if (!getArea(sourceExtent)) {\n            _this.state = TileState.EMPTY;\n        }\n        else {\n            var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n            for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n                for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n                    var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n                    if (tile) {\n                        _this.sourceTiles_.push(tile);\n                    }\n                }\n            }\n            if (_this.sourceTiles_.length === 0) {\n                _this.state = TileState.EMPTY;\n            }\n        }\n        return _this;\n    }\n    /**\n     * Get the HTML Canvas element for this tile.\n     * @return {HTMLCanvasElement} Canvas.\n     */\n    ReprojTile.prototype.getImage = function () {\n        return this.canvas_;\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.reproject_ = function () {\n        var sources = [];\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n            if (tile && tile.getState() == TileState.LOADED) {\n                sources.push({\n                    extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n                    image: tile.getImage()\n                });\n            }\n        }.bind(this));\n        this.sourceTiles_.length = 0;\n        if (sources.length === 0) {\n            this.state = TileState.ERROR;\n        }\n        else {\n            var z = this.wrappedTileCoord_[0];\n            var size = this.targetTileGrid_.getTileSize(z);\n            var width = typeof size === 'number' ? size : size[0];\n            var height = typeof size === 'number' ? size : size[1];\n            var targetResolution = this.targetTileGrid_.getResolution(z);\n            var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n            var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n            this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);\n            this.state = TileState.LOADED;\n        }\n        this.changed();\n    };\n    /**\n     * @inheritDoc\n     */\n    ReprojTile.prototype.load = function () {\n        if (this.state == TileState.IDLE) {\n            this.state = TileState.LOADING;\n            this.changed();\n            var leftToLoad_1 = 0;\n            this.sourcesListenerKeys_ = [];\n            this.sourceTiles_.forEach(function (tile, i, arr) {\n                var state = tile.getState();\n                if (state == TileState.IDLE || state == TileState.LOADING) {\n                    leftToLoad_1++;\n                    var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n                        var state = tile.getState();\n                        if (state == TileState.LOADED ||\n                            state == TileState.ERROR ||\n                            state == TileState.EMPTY) {\n                            unlistenByKey(sourceListenKey_1);\n                            leftToLoad_1--;\n                            if (leftToLoad_1 === 0) {\n                                this.unlistenSources_();\n                                this.reproject_();\n                            }\n                        }\n                    }, this);\n                    this.sourcesListenerKeys_.push(sourceListenKey_1);\n                }\n            }.bind(this));\n            this.sourceTiles_.forEach(function (tile, i, arr) {\n                var state = tile.getState();\n                if (state == TileState.IDLE) {\n                    tile.load();\n                }\n            });\n            if (leftToLoad_1 === 0) {\n                setTimeout(this.reproject_.bind(this), 0);\n            }\n        }\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.unlistenSources_ = function () {\n        this.sourcesListenerKeys_.forEach(unlistenByKey);\n        this.sourcesListenerKeys_ = null;\n    };\n    return ReprojTile;\n}(Tile));\nexport default ReprojTile;\n//# sourceMappingURL=Tile.js.map"]},"metadata":{},"sourceType":"module"}