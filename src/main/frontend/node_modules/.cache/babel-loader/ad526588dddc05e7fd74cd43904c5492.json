{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/format/Polyline\n */\n\n\nimport { assert } from '../asserts.js';\nimport Feature from '../Feature.js';\nimport { transformGeometryWithOptions } from './Feature.js';\nimport TextFeature from './TextFeature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport { getStrideForLayout } from '../geom/SimpleGeometry.js';\nimport { flipXY } from '../geom/flat/flip.js';\nimport { inflateCoordinates } from '../geom/flat/inflate.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * @typedef {Object} Options\n * @property {number} [factor=1e5] The factor by which the coordinates values will be scaled.\n * @property {GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the format reader.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the Encoded\n * Polyline Algorithm Format.\n *\n * When reading features, the coordinates are assumed to be in two dimensions\n * and in [latitude, longitude] order.\n *\n * As Polyline sources contain a single feature,\n * {@link module:ol/format/Polyline~Polyline#readFeatures} will return the\n * feature in an array.\n *\n * @api\n */\n\nvar Polyline =\n/** @class */\nfunction (_super) {\n  __extends(Polyline, _super);\n  /**\n   * @param {Options=} opt_options Optional configuration object.\n   */\n\n\n  function Polyline(opt_options) {\n    var _this = _super.call(this) || this;\n\n    var options = opt_options ? opt_options : {};\n    /**\n     * @inheritDoc\n     */\n\n    _this.dataProjection = getProjection('EPSG:4326');\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.factor_ = options.factor ? options.factor : 1e5;\n    /**\n     * @private\n     * @type {GeometryLayout}\n     */\n\n    _this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : GeometryLayout.XY;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  Polyline.prototype.readFeatureFromText = function (text, opt_options) {\n    var geometry = this.readGeometryFromText(text, opt_options);\n    return new Feature(geometry);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Polyline.prototype.readFeaturesFromText = function (text, opt_options) {\n    var feature = this.readFeatureFromText(text, opt_options);\n    return [feature];\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Polyline.prototype.readGeometryFromText = function (text, opt_options) {\n    var stride = getStrideForLayout(this.geometryLayout_);\n    var flatCoordinates = decodeDeltas(text, stride, this.factor_);\n    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n    var coordinates = inflateCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);\n    var lineString = new LineString(coordinates, this.geometryLayout_);\n    return transformGeometryWithOptions(lineString, false, this.adaptOptions(opt_options));\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Polyline.prototype.writeFeatureText = function (feature, opt_options) {\n    var geometry = feature.getGeometry();\n\n    if (geometry) {\n      return this.writeGeometryText(geometry, opt_options);\n    } else {\n      assert(false, 40); // Expected `feature` to have a geometry\n\n      return '';\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Polyline.prototype.writeFeaturesText = function (features, opt_options) {\n    return this.writeFeatureText(features[0], opt_options);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Polyline.prototype.writeGeometryText = function (geometry, opt_options) {\n    geometry =\n    /** @type {LineString} */\n    transformGeometryWithOptions(geometry, true, this.adaptOptions(opt_options));\n    var flatCoordinates = geometry.getFlatCoordinates();\n    var stride = geometry.getStride();\n    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n    return encodeDeltas(flatCoordinates, stride, this.factor_);\n  };\n\n  return Polyline;\n}(TextFeature);\n/**\n * Encode a list of n-dimensional points and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of n-dimensional points.\n * @param {number} stride The number of dimension of the points in the list.\n * @param {number=} opt_factor The factor by which the numbers will be\n *     multiplied. The remaining decimal places will get rounded away.\n *     Default is `1e5`.\n * @return {string} The encoded string.\n * @api\n */\n\n\nexport function encodeDeltas(numbers, stride, opt_factor) {\n  var factor = opt_factor ? opt_factor : 1e5;\n  var d;\n  var lastNumbers = new Array(stride);\n\n  for (d = 0; d < stride; ++d) {\n    lastNumbers[d] = 0;\n  }\n\n  for (var i = 0, ii = numbers.length; i < ii;) {\n    for (d = 0; d < stride; ++d, ++i) {\n      var num = numbers[i];\n      var delta = num - lastNumbers[d];\n      lastNumbers[d] = num;\n      numbers[i] = delta;\n    }\n  }\n\n  return encodeFloats(numbers, factor);\n}\n/**\n * Decode a list of n-dimensional points from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @param {number} stride The number of dimension of the points in the\n *     encoded string.\n * @param {number=} opt_factor The factor by which the resulting numbers will\n *     be divided. Default is `1e5`.\n * @return {Array<number>} A list of n-dimensional points.\n * @api\n */\n\nexport function decodeDeltas(encoded, stride, opt_factor) {\n  var factor = opt_factor ? opt_factor : 1e5;\n  var d;\n  /** @type {Array<number>} */\n\n  var lastNumbers = new Array(stride);\n\n  for (d = 0; d < stride; ++d) {\n    lastNumbers[d] = 0;\n  }\n\n  var numbers = decodeFloats(encoded, factor);\n\n  for (var i = 0, ii = numbers.length; i < ii;) {\n    for (d = 0; d < stride; ++d, ++i) {\n      lastNumbers[d] += numbers[i];\n      numbers[i] = lastNumbers[d];\n    }\n  }\n\n  return numbers;\n}\n/**\n * Encode a list of floating point numbers and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of floating point numbers.\n * @param {number=} opt_factor The factor by which the numbers will be\n *     multiplied. The remaining decimal places will get rounded away.\n *     Default is `1e5`.\n * @return {string} The encoded string.\n * @api\n */\n\nexport function encodeFloats(numbers, opt_factor) {\n  var factor = opt_factor ? opt_factor : 1e5;\n\n  for (var i = 0, ii = numbers.length; i < ii; ++i) {\n    numbers[i] = Math.round(numbers[i] * factor);\n  }\n\n  return encodeSignedIntegers(numbers);\n}\n/**\n * Decode a list of floating point numbers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @param {number=} opt_factor The factor by which the result will be divided.\n *     Default is `1e5`.\n * @return {Array<number>} A list of floating point numbers.\n * @api\n */\n\nexport function decodeFloats(encoded, opt_factor) {\n  var factor = opt_factor ? opt_factor : 1e5;\n  var numbers = decodeSignedIntegers(encoded);\n\n  for (var i = 0, ii = numbers.length; i < ii; ++i) {\n    numbers[i] /= factor;\n  }\n\n  return numbers;\n}\n/**\n * Encode a list of signed integers and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of signed integers.\n * @return {string} The encoded string.\n */\n\nexport function encodeSignedIntegers(numbers) {\n  for (var i = 0, ii = numbers.length; i < ii; ++i) {\n    var num = numbers[i];\n    numbers[i] = num < 0 ? ~(num << 1) : num << 1;\n  }\n\n  return encodeUnsignedIntegers(numbers);\n}\n/**\n * Decode a list of signed integers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @return {Array<number>} A list of signed integers.\n */\n\nexport function decodeSignedIntegers(encoded) {\n  var numbers = decodeUnsignedIntegers(encoded);\n\n  for (var i = 0, ii = numbers.length; i < ii; ++i) {\n    var num = numbers[i];\n    numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;\n  }\n\n  return numbers;\n}\n/**\n * Encode a list of unsigned integers and return an encoded string\n *\n * @param {Array<number>} numbers A list of unsigned integers.\n * @return {string} The encoded string.\n */\n\nexport function encodeUnsignedIntegers(numbers) {\n  var encoded = '';\n\n  for (var i = 0, ii = numbers.length; i < ii; ++i) {\n    encoded += encodeUnsignedInteger(numbers[i]);\n  }\n\n  return encoded;\n}\n/**\n * Decode a list of unsigned integers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @return {Array<number>} A list of unsigned integers.\n */\n\nexport function decodeUnsignedIntegers(encoded) {\n  var numbers = [];\n  var current = 0;\n  var shift = 0;\n\n  for (var i = 0, ii = encoded.length; i < ii; ++i) {\n    var b = encoded.charCodeAt(i) - 63;\n    current |= (b & 0x1f) << shift;\n\n    if (b < 0x20) {\n      numbers.push(current);\n      current = 0;\n      shift = 0;\n    } else {\n      shift += 5;\n    }\n  }\n\n  return numbers;\n}\n/**\n * Encode one single unsigned integer and return an encoded string\n *\n * @param {number} num Unsigned integer that should be encoded.\n * @return {string} The encoded string.\n */\n\nexport function encodeUnsignedInteger(num) {\n  var value,\n      encoded = '';\n\n  while (num >= 0x20) {\n    value = (0x20 | num & 0x1f) + 63;\n    encoded += String.fromCharCode(value);\n    num >>= 5;\n  }\n\n  value = num + 63;\n  encoded += String.fromCharCode(value);\n  return encoded;\n}\nexport default Polyline;","map":{"version":3,"sources":["../src/format/Polyline.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/Polyline\n */\nimport { assert } from '../asserts.js';\nimport Feature from '../Feature.js';\nimport { transformGeometryWithOptions } from './Feature.js';\nimport TextFeature from './TextFeature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport { getStrideForLayout } from '../geom/SimpleGeometry.js';\nimport { flipXY } from '../geom/flat/flip.js';\nimport { inflateCoordinates } from '../geom/flat/inflate.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * @typedef {Object} Options\n * @property {number} [factor=1e5] The factor by which the coordinates values will be scaled.\n * @property {GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the format reader.\n */\n/**\n * @classdesc\n * Feature format for reading and writing data in the Encoded\n * Polyline Algorithm Format.\n *\n * When reading features, the coordinates are assumed to be in two dimensions\n * and in [latitude, longitude] order.\n *\n * As Polyline sources contain a single feature,\n * {@link module:ol/format/Polyline~Polyline#readFeatures} will return the\n * feature in an array.\n *\n * @api\n */\nvar Polyline = /** @class */ (function (_super) {\n    __extends(Polyline, _super);\n    /**\n     * @param {Options=} opt_options Optional configuration object.\n     */\n    function Polyline(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * @inheritDoc\n         */\n        _this.dataProjection = getProjection('EPSG:4326');\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.factor_ = options.factor ? options.factor : 1e5;\n        /**\n         * @private\n         * @type {GeometryLayout}\n         */\n        _this.geometryLayout_ = options.geometryLayout ?\n            options.geometryLayout : GeometryLayout.XY;\n        return _this;\n    }\n    /**\n     * @inheritDoc\n     */\n    Polyline.prototype.readFeatureFromText = function (text, opt_options) {\n        var geometry = this.readGeometryFromText(text, opt_options);\n        return new Feature(geometry);\n    };\n    /**\n     * @inheritDoc\n     */\n    Polyline.prototype.readFeaturesFromText = function (text, opt_options) {\n        var feature = this.readFeatureFromText(text, opt_options);\n        return [feature];\n    };\n    /**\n     * @inheritDoc\n     */\n    Polyline.prototype.readGeometryFromText = function (text, opt_options) {\n        var stride = getStrideForLayout(this.geometryLayout_);\n        var flatCoordinates = decodeDeltas(text, stride, this.factor_);\n        flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n        var coordinates = inflateCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);\n        var lineString = new LineString(coordinates, this.geometryLayout_);\n        return transformGeometryWithOptions(lineString, false, this.adaptOptions(opt_options));\n    };\n    /**\n     * @inheritDoc\n     */\n    Polyline.prototype.writeFeatureText = function (feature, opt_options) {\n        var geometry = feature.getGeometry();\n        if (geometry) {\n            return this.writeGeometryText(geometry, opt_options);\n        }\n        else {\n            assert(false, 40); // Expected `feature` to have a geometry\n            return '';\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    Polyline.prototype.writeFeaturesText = function (features, opt_options) {\n        return this.writeFeatureText(features[0], opt_options);\n    };\n    /**\n     * @inheritDoc\n     */\n    Polyline.prototype.writeGeometryText = function (geometry, opt_options) {\n        geometry = /** @type {LineString} */\n            (transformGeometryWithOptions(geometry, true, this.adaptOptions(opt_options)));\n        var flatCoordinates = geometry.getFlatCoordinates();\n        var stride = geometry.getStride();\n        flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n        return encodeDeltas(flatCoordinates, stride, this.factor_);\n    };\n    return Polyline;\n}(TextFeature));\n/**\n * Encode a list of n-dimensional points and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of n-dimensional points.\n * @param {number} stride The number of dimension of the points in the list.\n * @param {number=} opt_factor The factor by which the numbers will be\n *     multiplied. The remaining decimal places will get rounded away.\n *     Default is `1e5`.\n * @return {string} The encoded string.\n * @api\n */\nexport function encodeDeltas(numbers, stride, opt_factor) {\n    var factor = opt_factor ? opt_factor : 1e5;\n    var d;\n    var lastNumbers = new Array(stride);\n    for (d = 0; d < stride; ++d) {\n        lastNumbers[d] = 0;\n    }\n    for (var i = 0, ii = numbers.length; i < ii;) {\n        for (d = 0; d < stride; ++d, ++i) {\n            var num = numbers[i];\n            var delta = num - lastNumbers[d];\n            lastNumbers[d] = num;\n            numbers[i] = delta;\n        }\n    }\n    return encodeFloats(numbers, factor);\n}\n/**\n * Decode a list of n-dimensional points from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @param {number} stride The number of dimension of the points in the\n *     encoded string.\n * @param {number=} opt_factor The factor by which the resulting numbers will\n *     be divided. Default is `1e5`.\n * @return {Array<number>} A list of n-dimensional points.\n * @api\n */\nexport function decodeDeltas(encoded, stride, opt_factor) {\n    var factor = opt_factor ? opt_factor : 1e5;\n    var d;\n    /** @type {Array<number>} */\n    var lastNumbers = new Array(stride);\n    for (d = 0; d < stride; ++d) {\n        lastNumbers[d] = 0;\n    }\n    var numbers = decodeFloats(encoded, factor);\n    for (var i = 0, ii = numbers.length; i < ii;) {\n        for (d = 0; d < stride; ++d, ++i) {\n            lastNumbers[d] += numbers[i];\n            numbers[i] = lastNumbers[d];\n        }\n    }\n    return numbers;\n}\n/**\n * Encode a list of floating point numbers and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of floating point numbers.\n * @param {number=} opt_factor The factor by which the numbers will be\n *     multiplied. The remaining decimal places will get rounded away.\n *     Default is `1e5`.\n * @return {string} The encoded string.\n * @api\n */\nexport function encodeFloats(numbers, opt_factor) {\n    var factor = opt_factor ? opt_factor : 1e5;\n    for (var i = 0, ii = numbers.length; i < ii; ++i) {\n        numbers[i] = Math.round(numbers[i] * factor);\n    }\n    return encodeSignedIntegers(numbers);\n}\n/**\n * Decode a list of floating point numbers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @param {number=} opt_factor The factor by which the result will be divided.\n *     Default is `1e5`.\n * @return {Array<number>} A list of floating point numbers.\n * @api\n */\nexport function decodeFloats(encoded, opt_factor) {\n    var factor = opt_factor ? opt_factor : 1e5;\n    var numbers = decodeSignedIntegers(encoded);\n    for (var i = 0, ii = numbers.length; i < ii; ++i) {\n        numbers[i] /= factor;\n    }\n    return numbers;\n}\n/**\n * Encode a list of signed integers and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of signed integers.\n * @return {string} The encoded string.\n */\nexport function encodeSignedIntegers(numbers) {\n    for (var i = 0, ii = numbers.length; i < ii; ++i) {\n        var num = numbers[i];\n        numbers[i] = (num < 0) ? ~(num << 1) : (num << 1);\n    }\n    return encodeUnsignedIntegers(numbers);\n}\n/**\n * Decode a list of signed integers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @return {Array<number>} A list of signed integers.\n */\nexport function decodeSignedIntegers(encoded) {\n    var numbers = decodeUnsignedIntegers(encoded);\n    for (var i = 0, ii = numbers.length; i < ii; ++i) {\n        var num = numbers[i];\n        numbers[i] = (num & 1) ? ~(num >> 1) : (num >> 1);\n    }\n    return numbers;\n}\n/**\n * Encode a list of unsigned integers and return an encoded string\n *\n * @param {Array<number>} numbers A list of unsigned integers.\n * @return {string} The encoded string.\n */\nexport function encodeUnsignedIntegers(numbers) {\n    var encoded = '';\n    for (var i = 0, ii = numbers.length; i < ii; ++i) {\n        encoded += encodeUnsignedInteger(numbers[i]);\n    }\n    return encoded;\n}\n/**\n * Decode a list of unsigned integers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @return {Array<number>} A list of unsigned integers.\n */\nexport function decodeUnsignedIntegers(encoded) {\n    var numbers = [];\n    var current = 0;\n    var shift = 0;\n    for (var i = 0, ii = encoded.length; i < ii; ++i) {\n        var b = encoded.charCodeAt(i) - 63;\n        current |= (b & 0x1f) << shift;\n        if (b < 0x20) {\n            numbers.push(current);\n            current = 0;\n            shift = 0;\n        }\n        else {\n            shift += 5;\n        }\n    }\n    return numbers;\n}\n/**\n * Encode one single unsigned integer and return an encoded string\n *\n * @param {number} num Unsigned integer that should be encoded.\n * @return {string} The encoded string.\n */\nexport function encodeUnsignedInteger(num) {\n    var value, encoded = '';\n    while (num >= 0x20) {\n        value = (0x20 | (num & 0x1f)) + 63;\n        encoded += String.fromCharCode(value);\n        num >>= 5;\n    }\n    value = num + 63;\n    encoded += String.fromCharCode(value);\n    return encoded;\n}\nexport default Polyline;\n//# sourceMappingURL=Polyline.js.map"]},"metadata":{},"sourceType":"module"}