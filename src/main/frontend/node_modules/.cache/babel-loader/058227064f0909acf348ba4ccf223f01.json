{"ast":null,"code":"/**\n * @module ol/format/MVT\n */\n//FIXME Implement projection handling\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { assert } from '../asserts.js';\nimport PBF from 'pbf';\nimport FeatureFormat, { transformGeometryWithOptions } from './Feature.js';\nimport FormatType from './FormatType.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { linearRingIsClockwise } from '../geom/flat/orient.js';\nimport Projection from '../proj/Projection.js';\nimport Units from '../proj/Units.js';\nimport RenderFeature from '../render/Feature.js';\nimport { get } from '../proj.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../Feature.js\").FeatureClass} [featureClass] Class for features returned by\n * {@link module:ol/format/MVT#readFeatures}. Set to {@link module:ol/Feature~Feature} to get full editing and geometry\n * support at the cost of decreased rendering performance. The default is\n * {@link module:ol/render/Feature~RenderFeature}, which is optimized for rendering and hit detection.\n * @property {string} [geometryName='geometry'] Geometry name to use when creating features.\n * @property {string} [layerName='layer'] Name of the feature attribute that holds the layer name.\n * @property {Array<string>} [layers] Layers to read features from. If not provided, features will be read from all\n * @property {string} [idProperty] Optional property that will be assigned as the feature id and removed from the properties.\n * layers.\n */\n\n/**\n * @classdesc\n * Feature format for reading data in the Mapbox MVT format.\n *\n * @param {Options=} opt_options Options.\n * @api\n */\n\nvar MVT =\n/** @class */\nfunction (_super) {\n  __extends(MVT, _super);\n  /**\n   * @param {Options=} opt_options Options.\n   */\n\n\n  function MVT(opt_options) {\n    var _this = _super.call(this) || this;\n\n    var options = opt_options ? opt_options : {};\n    /**\n     * @type {Projection}\n     */\n\n    _this.dataProjection = new Projection({\n      code: '',\n      units: Units.TILE_PIXELS\n    });\n    /**\n     * @private\n     * @type {import(\"../Feature.js\").FeatureClass}\n     */\n\n    _this.featureClass_ = options.featureClass ? options.featureClass : RenderFeature;\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n\n    _this.geometryName_ = options.geometryName;\n    /**\n     * @private\n     * @type {string}\n     */\n\n    _this.layerName_ = options.layerName ? options.layerName : 'layer';\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n\n    _this.layers_ = options.layers ? options.layers : null;\n    /**\n     * @private\n     * @type {string}\n     */\n\n    _this.idProperty_ = options.idProperty;\n    return _this;\n  }\n  /**\n   * Read the raw geometry from the pbf offset stored in a raw feature's geometry\n   * property.\n   * @param {PBF} pbf PBF.\n   * @param {Object} feature Raw feature.\n   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.\n   * @param {Array<number>} ends Array to store ends in.\n   * @private\n   */\n\n\n  MVT.prototype.readRawGeometry_ = function (pbf, feature, flatCoordinates, ends) {\n    pbf.pos = feature.geometry;\n    var end = pbf.readVarint() + pbf.pos;\n    var cmd = 1;\n    var length = 0;\n    var x = 0;\n    var y = 0;\n    var coordsLen = 0;\n    var currentEnd = 0;\n\n    while (pbf.pos < end) {\n      if (!length) {\n        var cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) {\n          // moveTo\n          if (coordsLen > currentEnd) {\n            ends.push(coordsLen);\n            currentEnd = coordsLen;\n          }\n        }\n\n        flatCoordinates.push(x, y);\n        coordsLen += 2;\n      } else if (cmd === 7) {\n        if (coordsLen > currentEnd) {\n          // close polygon\n          flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);\n          coordsLen += 2;\n        }\n      } else {\n        assert(false, 59); // Invalid command found in the PBF\n      }\n    }\n\n    if (coordsLen > currentEnd) {\n      ends.push(coordsLen);\n      currentEnd = coordsLen;\n    }\n  };\n  /**\n   * @private\n   * @param {PBF} pbf PBF\n   * @param {Object} rawFeature Raw Mapbox feature.\n   * @param {import(\"./Feature.js\").ReadOptions} options Read options.\n   * @return {import(\"../Feature.js\").FeatureLike} Feature.\n   */\n\n\n  MVT.prototype.createFeature_ = function (pbf, rawFeature, options) {\n    var type = rawFeature.type;\n\n    if (type === 0) {\n      return null;\n    }\n\n    var feature;\n    var values = rawFeature.properties;\n    var id;\n\n    if (!this.idProperty_) {\n      id = rawFeature.id;\n    } else {\n      id = values[this.idProperty_];\n      delete values[this.idProperty_];\n    }\n\n    values[this.layerName_] = rawFeature.layer.name;\n    var flatCoordinates = [];\n    var ends = [];\n    this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);\n    var geometryType = getGeometryType(type, ends.length);\n\n    if (this.featureClass_ === RenderFeature) {\n      feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);\n      feature.transform(options.dataProjection, options.featureProjection);\n    } else {\n      var geom = void 0;\n\n      if (geometryType == GeometryType.POLYGON) {\n        var endss = [];\n        var offset = 0;\n        var prevEndIndex = 0;\n\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          var end = ends[i];\n\n          if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n            endss.push(ends.slice(prevEndIndex, i));\n            prevEndIndex = i;\n          }\n\n          offset = end;\n        }\n\n        if (endss.length > 1) {\n          geom = new MultiPolygon(flatCoordinates, GeometryLayout.XY, endss);\n        } else {\n          geom = new Polygon(flatCoordinates, GeometryLayout.XY, ends);\n        }\n      } else {\n        geom = geometryType === GeometryType.POINT ? new Point(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.LINE_STRING ? new LineString(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.POLYGON ? new Polygon(flatCoordinates, GeometryLayout.XY, ends) : geometryType === GeometryType.MULTI_POINT ? new MultiPoint(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.MULTI_LINE_STRING ? new MultiLineString(flatCoordinates, GeometryLayout.XY, ends) : null;\n      }\n\n      var ctor =\n      /** @type {typeof import(\"../Feature.js\").default} */\n      this.featureClass_;\n      feature = new ctor();\n\n      if (this.geometryName_) {\n        feature.setGeometryName(this.geometryName_);\n      }\n\n      var geometry = transformGeometryWithOptions(geom, false, options);\n      feature.setGeometry(geometry);\n      feature.setId(id);\n      feature.setProperties(values, true);\n    }\n\n    return feature;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  MVT.prototype.getType = function () {\n    return FormatType.ARRAY_BUFFER;\n  };\n  /**\n   * Read all features.\n   *\n   * @param {ArrayBuffer} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n\n\n  MVT.prototype.readFeatures = function (source, opt_options) {\n    var layers = this.layers_;\n    var options =\n    /** @type {import(\"./Feature.js\").ReadOptions} */\n    this.adaptOptions(opt_options);\n    var dataProjection = get(options.dataProjection);\n    dataProjection.setWorldExtent(options.extent);\n    options.dataProjection = dataProjection;\n    var pbf = new PBF(\n    /** @type {ArrayBuffer} */\n    source);\n    var pbfLayers = pbf.readFields(layersPBFReader, {});\n    var features = [];\n\n    for (var name_1 in pbfLayers) {\n      if (layers && layers.indexOf(name_1) == -1) {\n        continue;\n      }\n\n      var pbfLayer = pbfLayers[name_1];\n      var extent = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;\n      dataProjection.setExtent(extent);\n\n      for (var i = 0, ii = pbfLayer.length; i < ii; ++i) {\n        var rawFeature = readRawFeature(pbf, pbfLayer, i);\n        features.push(this.createFeature_(pbf, rawFeature, options));\n      }\n    }\n\n    return features;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  MVT.prototype.readProjection = function (source) {\n    return this.dataProjection;\n  };\n  /**\n   * Sets the layers that features will be read from.\n   * @param {Array<string>} layers Layers.\n   * @api\n   */\n\n\n  MVT.prototype.setLayers = function (layers) {\n    this.layers_ = layers;\n  };\n\n  return MVT;\n}(FeatureFormat);\n/**\n * Reader callback for parsing layers.\n * @param {number} tag The tag.\n * @param {Object} layers The layers object.\n * @param {PBF} pbf The PBF.\n */\n\n\nfunction layersPBFReader(tag, layers, pbf) {\n  if (tag === 3) {\n    var layer = {\n      keys: [],\n      values: [],\n      features: []\n    };\n    var end = pbf.readVarint() + pbf.pos;\n    pbf.readFields(layerPBFReader, layer, end);\n    layer.length = layer.features.length;\n\n    if (layer.length) {\n      layers[layer.name] = layer;\n    }\n  }\n}\n/**\n * Reader callback for parsing layer.\n * @param {number} tag The tag.\n * @param {Object} layer The layer object.\n * @param {PBF} pbf The PBF.\n */\n\n\nfunction layerPBFReader(tag, layer, pbf) {\n  if (tag === 15) {\n    layer.version = pbf.readVarint();\n  } else if (tag === 1) {\n    layer.name = pbf.readString();\n  } else if (tag === 5) {\n    layer.extent = pbf.readVarint();\n  } else if (tag === 2) {\n    layer.features.push(pbf.pos);\n  } else if (tag === 3) {\n    layer.keys.push(pbf.readString());\n  } else if (tag === 4) {\n    var value = null;\n    var end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n      tag = pbf.readVarint() >> 3;\n      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;\n    }\n\n    layer.values.push(value);\n  }\n}\n/**\n * Reader callback for parsing feature.\n * @param {number} tag The tag.\n * @param {Object} feature The feature object.\n * @param {PBF} pbf The PBF.\n */\n\n\nfunction featurePBFReader(tag, feature, pbf) {\n  if (tag == 1) {\n    feature.id = pbf.readVarint();\n  } else if (tag == 2) {\n    var end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n      var key = feature.layer.keys[pbf.readVarint()];\n      var value = feature.layer.values[pbf.readVarint()];\n      feature.properties[key] = value;\n    }\n  } else if (tag == 3) {\n    feature.type = pbf.readVarint();\n  } else if (tag == 4) {\n    feature.geometry = pbf.pos;\n  }\n}\n/**\n * Read a raw feature from the pbf offset stored at index `i` in the raw layer.\n * @param {PBF} pbf PBF.\n * @param {Object} layer Raw layer.\n * @param {number} i Index of the feature in the raw layer's `features` array.\n * @return {Object} Raw feature.\n */\n\n\nfunction readRawFeature(pbf, layer, i) {\n  pbf.pos = layer.features[i];\n  var end = pbf.readVarint() + pbf.pos;\n  var feature = {\n    layer: layer,\n    type: 0,\n    properties: {}\n  };\n  pbf.readFields(featurePBFReader, feature, end);\n  return feature;\n}\n/**\n * @param {number} type The raw feature's geometry type\n * @param {number} numEnds Number of ends of the flat coordinates of the\n * geometry.\n * @return {GeometryType} The geometry type.\n */\n\n\nfunction getGeometryType(type, numEnds) {\n  /** @type {GeometryType} */\n  var geometryType;\n\n  if (type === 1) {\n    geometryType = numEnds === 1 ? GeometryType.POINT : GeometryType.MULTI_POINT;\n  } else if (type === 2) {\n    geometryType = numEnds === 1 ? GeometryType.LINE_STRING : GeometryType.MULTI_LINE_STRING;\n  } else if (type === 3) {\n    geometryType = GeometryType.POLYGON; // MultiPolygon not relevant for rendering - winding order determines\n    // outer rings of polygons.\n  }\n\n  return geometryType;\n}\n\nexport default MVT;","map":{"version":3,"sources":["../src/format/MVT.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/format/MVT\n */\n//FIXME Implement projection handling\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { assert } from '../asserts.js';\nimport PBF from 'pbf';\nimport FeatureFormat, { transformGeometryWithOptions } from './Feature.js';\nimport FormatType from './FormatType.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { linearRingIsClockwise } from '../geom/flat/orient.js';\nimport Projection from '../proj/Projection.js';\nimport Units from '../proj/Units.js';\nimport RenderFeature from '../render/Feature.js';\nimport { get } from '../proj.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../Feature.js\").FeatureClass} [featureClass] Class for features returned by\n * {@link module:ol/format/MVT#readFeatures}. Set to {@link module:ol/Feature~Feature} to get full editing and geometry\n * support at the cost of decreased rendering performance. The default is\n * {@link module:ol/render/Feature~RenderFeature}, which is optimized for rendering and hit detection.\n * @property {string} [geometryName='geometry'] Geometry name to use when creating features.\n * @property {string} [layerName='layer'] Name of the feature attribute that holds the layer name.\n * @property {Array<string>} [layers] Layers to read features from. If not provided, features will be read from all\n * @property {string} [idProperty] Optional property that will be assigned as the feature id and removed from the properties.\n * layers.\n */\n/**\n * @classdesc\n * Feature format for reading data in the Mapbox MVT format.\n *\n * @param {Options=} opt_options Options.\n * @api\n */\nvar MVT = /** @class */ (function (_super) {\n    __extends(MVT, _super);\n    /**\n     * @param {Options=} opt_options Options.\n     */\n    function MVT(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * @type {Projection}\n         */\n        _this.dataProjection = new Projection({\n            code: '',\n            units: Units.TILE_PIXELS\n        });\n        /**\n         * @private\n         * @type {import(\"../Feature.js\").FeatureClass}\n         */\n        _this.featureClass_ = options.featureClass ? options.featureClass : RenderFeature;\n        /**\n         * @private\n         * @type {string|undefined}\n         */\n        _this.geometryName_ = options.geometryName;\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.layerName_ = options.layerName ? options.layerName : 'layer';\n        /**\n         * @private\n         * @type {Array<string>}\n         */\n        _this.layers_ = options.layers ? options.layers : null;\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.idProperty_ = options.idProperty;\n        return _this;\n    }\n    /**\n     * Read the raw geometry from the pbf offset stored in a raw feature's geometry\n     * property.\n     * @param {PBF} pbf PBF.\n     * @param {Object} feature Raw feature.\n     * @param {Array<number>} flatCoordinates Array to store flat coordinates in.\n     * @param {Array<number>} ends Array to store ends in.\n     * @private\n     */\n    MVT.prototype.readRawGeometry_ = function (pbf, feature, flatCoordinates, ends) {\n        pbf.pos = feature.geometry;\n        var end = pbf.readVarint() + pbf.pos;\n        var cmd = 1;\n        var length = 0;\n        var x = 0;\n        var y = 0;\n        var coordsLen = 0;\n        var currentEnd = 0;\n        while (pbf.pos < end) {\n            if (!length) {\n                var cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n            length--;\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (cmd === 1) { // moveTo\n                    if (coordsLen > currentEnd) {\n                        ends.push(coordsLen);\n                        currentEnd = coordsLen;\n                    }\n                }\n                flatCoordinates.push(x, y);\n                coordsLen += 2;\n            }\n            else if (cmd === 7) {\n                if (coordsLen > currentEnd) {\n                    // close polygon\n                    flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);\n                    coordsLen += 2;\n                }\n            }\n            else {\n                assert(false, 59); // Invalid command found in the PBF\n            }\n        }\n        if (coordsLen > currentEnd) {\n            ends.push(coordsLen);\n            currentEnd = coordsLen;\n        }\n    };\n    /**\n     * @private\n     * @param {PBF} pbf PBF\n     * @param {Object} rawFeature Raw Mapbox feature.\n     * @param {import(\"./Feature.js\").ReadOptions} options Read options.\n     * @return {import(\"../Feature.js\").FeatureLike} Feature.\n     */\n    MVT.prototype.createFeature_ = function (pbf, rawFeature, options) {\n        var type = rawFeature.type;\n        if (type === 0) {\n            return null;\n        }\n        var feature;\n        var values = rawFeature.properties;\n        var id;\n        if (!this.idProperty_) {\n            id = rawFeature.id;\n        }\n        else {\n            id = values[this.idProperty_];\n            delete values[this.idProperty_];\n        }\n        values[this.layerName_] = rawFeature.layer.name;\n        var flatCoordinates = [];\n        var ends = [];\n        this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);\n        var geometryType = getGeometryType(type, ends.length);\n        if (this.featureClass_ === RenderFeature) {\n            feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);\n            feature.transform(options.dataProjection, options.featureProjection);\n        }\n        else {\n            var geom = void 0;\n            if (geometryType == GeometryType.POLYGON) {\n                var endss = [];\n                var offset = 0;\n                var prevEndIndex = 0;\n                for (var i = 0, ii = ends.length; i < ii; ++i) {\n                    var end = ends[i];\n                    if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n                        endss.push(ends.slice(prevEndIndex, i));\n                        prevEndIndex = i;\n                    }\n                    offset = end;\n                }\n                if (endss.length > 1) {\n                    geom = new MultiPolygon(flatCoordinates, GeometryLayout.XY, endss);\n                }\n                else {\n                    geom = new Polygon(flatCoordinates, GeometryLayout.XY, ends);\n                }\n            }\n            else {\n                geom = geometryType === GeometryType.POINT ? new Point(flatCoordinates, GeometryLayout.XY) :\n                    geometryType === GeometryType.LINE_STRING ? new LineString(flatCoordinates, GeometryLayout.XY) :\n                        geometryType === GeometryType.POLYGON ? new Polygon(flatCoordinates, GeometryLayout.XY, ends) :\n                            geometryType === GeometryType.MULTI_POINT ? new MultiPoint(flatCoordinates, GeometryLayout.XY) :\n                                geometryType === GeometryType.MULTI_LINE_STRING ? new MultiLineString(flatCoordinates, GeometryLayout.XY, ends) :\n                                    null;\n            }\n            var ctor = /** @type {typeof import(\"../Feature.js\").default} */ (this.featureClass_);\n            feature = new ctor();\n            if (this.geometryName_) {\n                feature.setGeometryName(this.geometryName_);\n            }\n            var geometry = transformGeometryWithOptions(geom, false, options);\n            feature.setGeometry(geometry);\n            feature.setId(id);\n            feature.setProperties(values, true);\n        }\n        return feature;\n    };\n    /**\n     * @inheritDoc\n     */\n    MVT.prototype.getType = function () {\n        return FormatType.ARRAY_BUFFER;\n    };\n    /**\n     * Read all features.\n     *\n     * @param {ArrayBuffer} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\n     * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n     * @api\n     */\n    MVT.prototype.readFeatures = function (source, opt_options) {\n        var layers = this.layers_;\n        var options = /** @type {import(\"./Feature.js\").ReadOptions} */ (this.adaptOptions(opt_options));\n        var dataProjection = get(options.dataProjection);\n        dataProjection.setWorldExtent(options.extent);\n        options.dataProjection = dataProjection;\n        var pbf = new PBF(/** @type {ArrayBuffer} */ (source));\n        var pbfLayers = pbf.readFields(layersPBFReader, {});\n        var features = [];\n        for (var name_1 in pbfLayers) {\n            if (layers && layers.indexOf(name_1) == -1) {\n                continue;\n            }\n            var pbfLayer = pbfLayers[name_1];\n            var extent = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;\n            dataProjection.setExtent(extent);\n            for (var i = 0, ii = pbfLayer.length; i < ii; ++i) {\n                var rawFeature = readRawFeature(pbf, pbfLayer, i);\n                features.push(this.createFeature_(pbf, rawFeature, options));\n            }\n        }\n        return features;\n    };\n    /**\n     * @inheritDoc\n     * @api\n     */\n    MVT.prototype.readProjection = function (source) {\n        return this.dataProjection;\n    };\n    /**\n     * Sets the layers that features will be read from.\n     * @param {Array<string>} layers Layers.\n     * @api\n     */\n    MVT.prototype.setLayers = function (layers) {\n        this.layers_ = layers;\n    };\n    return MVT;\n}(FeatureFormat));\n/**\n * Reader callback for parsing layers.\n * @param {number} tag The tag.\n * @param {Object} layers The layers object.\n * @param {PBF} pbf The PBF.\n */\nfunction layersPBFReader(tag, layers, pbf) {\n    if (tag === 3) {\n        var layer = {\n            keys: [],\n            values: [],\n            features: []\n        };\n        var end = pbf.readVarint() + pbf.pos;\n        pbf.readFields(layerPBFReader, layer, end);\n        layer.length = layer.features.length;\n        if (layer.length) {\n            layers[layer.name] = layer;\n        }\n    }\n}\n/**\n * Reader callback for parsing layer.\n * @param {number} tag The tag.\n * @param {Object} layer The layer object.\n * @param {PBF} pbf The PBF.\n */\nfunction layerPBFReader(tag, layer, pbf) {\n    if (tag === 15) {\n        layer.version = pbf.readVarint();\n    }\n    else if (tag === 1) {\n        layer.name = pbf.readString();\n    }\n    else if (tag === 5) {\n        layer.extent = pbf.readVarint();\n    }\n    else if (tag === 2) {\n        layer.features.push(pbf.pos);\n    }\n    else if (tag === 3) {\n        layer.keys.push(pbf.readString());\n    }\n    else if (tag === 4) {\n        var value = null;\n        var end = pbf.readVarint() + pbf.pos;\n        while (pbf.pos < end) {\n            tag = pbf.readVarint() >> 3;\n            value = tag === 1 ? pbf.readString() :\n                tag === 2 ? pbf.readFloat() :\n                    tag === 3 ? pbf.readDouble() :\n                        tag === 4 ? pbf.readVarint64() :\n                            tag === 5 ? pbf.readVarint() :\n                                tag === 6 ? pbf.readSVarint() :\n                                    tag === 7 ? pbf.readBoolean() : null;\n        }\n        layer.values.push(value);\n    }\n}\n/**\n * Reader callback for parsing feature.\n * @param {number} tag The tag.\n * @param {Object} feature The feature object.\n * @param {PBF} pbf The PBF.\n */\nfunction featurePBFReader(tag, feature, pbf) {\n    if (tag == 1) {\n        feature.id = pbf.readVarint();\n    }\n    else if (tag == 2) {\n        var end = pbf.readVarint() + pbf.pos;\n        while (pbf.pos < end) {\n            var key = feature.layer.keys[pbf.readVarint()];\n            var value = feature.layer.values[pbf.readVarint()];\n            feature.properties[key] = value;\n        }\n    }\n    else if (tag == 3) {\n        feature.type = pbf.readVarint();\n    }\n    else if (tag == 4) {\n        feature.geometry = pbf.pos;\n    }\n}\n/**\n * Read a raw feature from the pbf offset stored at index `i` in the raw layer.\n * @param {PBF} pbf PBF.\n * @param {Object} layer Raw layer.\n * @param {number} i Index of the feature in the raw layer's `features` array.\n * @return {Object} Raw feature.\n */\nfunction readRawFeature(pbf, layer, i) {\n    pbf.pos = layer.features[i];\n    var end = pbf.readVarint() + pbf.pos;\n    var feature = {\n        layer: layer,\n        type: 0,\n        properties: {}\n    };\n    pbf.readFields(featurePBFReader, feature, end);\n    return feature;\n}\n/**\n * @param {number} type The raw feature's geometry type\n * @param {number} numEnds Number of ends of the flat coordinates of the\n * geometry.\n * @return {GeometryType} The geometry type.\n */\nfunction getGeometryType(type, numEnds) {\n    /** @type {GeometryType} */\n    var geometryType;\n    if (type === 1) {\n        geometryType = numEnds === 1 ?\n            GeometryType.POINT : GeometryType.MULTI_POINT;\n    }\n    else if (type === 2) {\n        geometryType = numEnds === 1 ?\n            GeometryType.LINE_STRING :\n            GeometryType.MULTI_LINE_STRING;\n    }\n    else if (type === 3) {\n        geometryType = GeometryType.POLYGON;\n        // MultiPolygon not relevant for rendering - winding order determines\n        // outer rings of polygons.\n    }\n    return geometryType;\n}\nexport default MVT;\n//# sourceMappingURL=MVT.js.map"]},"metadata":{},"sourceType":"module"}