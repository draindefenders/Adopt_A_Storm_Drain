{"ast":null,"code":"/**\n * @module ol/source/UTFGrid\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport { createFromTemplates, nullTileUrlFunction } from '../tileurlfunction.js';\nimport { assert } from '../asserts.js';\nimport { listenOnce } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { applyTransform, intersects } from '../extent.js';\nimport { jsonp as requestJSONP } from '../net.js';\nimport { get as getProjection, getTransformFromProjections } from '../proj.js';\nimport SourceState from './State.js';\nimport TileSource from './Tile.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\n/**\n * @typedef {Object} UTFGridJSON\n * @property {Array<string>} grid The grid.\n * @property {Array<string>} keys The keys.\n * @property {Object<string, Object>} [data] Optional data.\n */\n\nvar CustomTile =\n/** @class */\nfunction (_super) {\n  __extends(CustomTile, _super);\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {TileState} state State.\n   * @param {string} src Image source URI.\n   * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\n   * @param {boolean} preemptive Load the tile when visible (before it's needed).\n   * @param {boolean} jsonp Load the tile as a script.\n   */\n\n\n  function CustomTile(tileCoord, state, src, extent, preemptive, jsonp) {\n    var _this = _super.call(this, tileCoord, state) || this;\n    /**\n     * @private\n     * @type {string}\n     */\n\n\n    _this.src_ = src;\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    _this.extent_ = extent;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.preemptive_ = preemptive;\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n\n    _this.grid_ = null;\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n\n    _this.keys_ = null;\n    /**\n     * @private\n     * @type {Object<string, Object>|undefined}\n     */\n\n    _this.data_ = null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.jsonp_ = jsonp;\n    return _this;\n  }\n  /**\n   * Get the image element for this tile.\n   * @return {HTMLImageElement} Image.\n   */\n\n\n  CustomTile.prototype.getImage = function () {\n    return null;\n  };\n  /**\n   * Synchronously returns data at given coordinate (if available).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {*} The data.\n   */\n\n\n  CustomTile.prototype.getData = function (coordinate) {\n    if (!this.grid_ || !this.keys_) {\n      return null;\n    }\n\n    var xRelative = (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);\n    var yRelative = (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);\n    var row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n\n    if (typeof row !== 'string') {\n      return null;\n    }\n\n    var code = row.charCodeAt(Math.floor(xRelative * row.length));\n\n    if (code >= 93) {\n      code--;\n    }\n\n    if (code >= 35) {\n      code--;\n    }\n\n    code -= 32;\n    var data = null;\n\n    if (code in this.keys_) {\n      var id = this.keys_[code];\n\n      if (this.data_ && id in this.data_) {\n        data = this.data_[id];\n      } else {\n        data = id;\n      }\n    }\n\n    return data;\n  };\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate (or `null` if not yet loaded).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean=} opt_request If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   */\n\n\n  CustomTile.prototype.forDataAtCoordinate = function (coordinate, callback, opt_request) {\n    if (this.state == TileState.EMPTY && opt_request === true) {\n      this.state = TileState.IDLE;\n      listenOnce(this, EventType.CHANGE, function (e) {\n        callback(this.getData(coordinate));\n      }, this);\n      this.loadInternal_();\n    } else {\n      if (opt_request === true) {\n        setTimeout(function () {\n          callback(this.getData(coordinate));\n        }.bind(this), 0);\n      } else {\n        callback(this.getData(coordinate));\n      }\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CustomTile.prototype.getKey = function () {\n    return this.src_;\n  };\n  /**\n   * @private\n   */\n\n\n  CustomTile.prototype.handleError_ = function () {\n    this.state = TileState.ERROR;\n    this.changed();\n  };\n  /**\n   * @param {!UTFGridJSON} json UTFGrid data.\n   * @private\n   */\n\n\n  CustomTile.prototype.handleLoad_ = function (json) {\n    this.grid_ = json['grid'];\n    this.keys_ = json['keys'];\n    this.data_ = json['data'];\n    this.state = TileState.LOADED;\n    this.changed();\n  };\n  /**\n   * @private\n   */\n\n\n  CustomTile.prototype.loadInternal_ = function () {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n\n      if (this.jsonp_) {\n        requestJSONP(this.src_, this.handleLoad_.bind(this), this.handleError_.bind(this));\n      } else {\n        var client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', this.src_);\n        client.send();\n      }\n    }\n  };\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n\n\n  CustomTile.prototype.onXHRLoad_ = function (event) {\n    var client =\n    /** @type {XMLHttpRequest} */\n    event.target; // status will be 0 for file:// urls\n\n    if (!client.status || client.status >= 200 && client.status < 300) {\n      var response = void 0;\n\n      try {\n        response =\n        /** @type {!UTFGridJSON} */\n        JSON.parse(client.responseText);\n      } catch (err) {\n        this.handleError_();\n        return;\n      }\n\n      this.handleLoad_(response);\n    } else {\n      this.handleError_();\n    }\n  };\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n\n\n  CustomTile.prototype.onXHRError_ = function (event) {\n    this.handleError_();\n  };\n  /**\n   * @override\n   */\n\n\n  CustomTile.prototype.load = function () {\n    if (this.preemptive_) {\n      this.loadInternal_();\n    } else {\n      this.setState(TileState.EMPTY);\n    }\n  };\n\n  return CustomTile;\n}(Tile);\n\nexport { CustomTile };\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false` (lazy loading), you need to pass `true` as\n * `opt_request` to the `forDataAtCoordinateAndResolution` method otherwise no\n * data will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n */\n\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n * @api\n */\n\nvar UTFGrid =\n/** @class */\nfunction (_super) {\n  __extends(UTFGrid, _super);\n  /**\n   * @param {Options} options Source options.\n   */\n\n\n  function UTFGrid(options) {\n    var _this = _super.call(this, {\n      projection: getProjection('EPSG:3857'),\n      state: SourceState.LOADING\n    }) || this;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n\n    _this.preemptive_ = options.preemptive !== undefined ? options.preemptive : true;\n    /**\n     * @private\n     * @type {!import(\"../Tile.js\").UrlFunction}\n     */\n\n    _this.tileUrlFunction_ = nullTileUrlFunction;\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n\n    _this.template_ = undefined;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.jsonp_ = options.jsonp || false;\n\n    if (options.url) {\n      if (_this.jsonp_) {\n        requestJSONP(options.url, _this.handleTileJSONResponse.bind(_this), _this.handleTileJSONError.bind(_this));\n      } else {\n        var client = new XMLHttpRequest();\n        client.addEventListener('load', _this.onXHRLoad_.bind(_this));\n        client.addEventListener('error', _this.onXHRError_.bind(_this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      _this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      assert(false, 51); // Either `url` or `tileJSON` options must be provided\n    }\n\n    return _this;\n  }\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n\n\n  UTFGrid.prototype.onXHRLoad_ = function (event) {\n    var client =\n    /** @type {XMLHttpRequest} */\n    event.target; // status will be 0 for file:// urls\n\n    if (!client.status || client.status >= 200 && client.status < 300) {\n      var response = void 0;\n\n      try {\n        response =\n        /** @type {import(\"./TileJSON.js\").Config} */\n        JSON.parse(client.responseText);\n      } catch (err) {\n        this.handleTileJSONError();\n        return;\n      }\n\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  };\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n\n\n  UTFGrid.prototype.onXHRError_ = function (event) {\n    this.handleTileJSONError();\n  };\n  /**\n   * Return the template from TileJSON.\n   * @return {string|undefined} The template from TileJSON.\n   * @api\n   */\n\n\n  UTFGrid.prototype.getTemplate = function () {\n    return this.template_;\n  };\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate and resolution (or `null` if not yet loaded or\n   * in case of an error).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean=} opt_request If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @api\n   */\n\n\n  UTFGrid.prototype.forDataAtCoordinateAndResolution = function (coordinate, resolution, callback, opt_request) {\n    if (this.tileGrid) {\n      var z = this.tileGrid.getZForResolution(resolution, this.zDirection);\n      var tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      var tile =\n      /** @type {!CustomTile} */\n      this.getTile(tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection());\n      tile.forDataAtCoordinate(coordinate, callback, opt_request);\n    } else {\n      if (opt_request === true) {\n        setTimeout(function () {\n          callback(null);\n        }, 0);\n      } else {\n        callback(null);\n      }\n    }\n  };\n  /**\n   * @protected\n   */\n\n\n  UTFGrid.prototype.handleTileJSONError = function () {\n    this.setState(SourceState.ERROR);\n  };\n  /**\n   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n   * @protected\n   * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\n   */\n\n\n  UTFGrid.prototype.handleTileJSONResponse = function (tileJSON) {\n    var epsg4326Projection = getProjection('EPSG:4326');\n    var sourceProjection = this.getProjection();\n    var extent;\n\n    if (tileJSON['bounds'] !== undefined) {\n      var transform = getTransformFromProjections(epsg4326Projection, sourceProjection);\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    var minZoom = tileJSON['minzoom'] || 0;\n    var maxZoom = tileJSON['maxzoom'] || 22;\n    var tileGrid = createXYZ({\n      extent: extentFromProjection(sourceProjection),\n      maxZoom: maxZoom,\n      minZoom: minZoom\n    });\n    this.tileGrid = tileGrid;\n    this.template_ = tileJSON['template'];\n    var grids = tileJSON['grids'];\n\n    if (!grids) {\n      this.setState(SourceState.ERROR);\n      return;\n    }\n\n    this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n\n    if (tileJSON['attribution'] !== undefined) {\n      var attributionExtent_1 = extent !== undefined ? extent : epsg4326Projection.getExtent();\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent_1, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n\n        return null;\n      });\n    }\n\n    this.setState(SourceState.READY);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  UTFGrid.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n    var tileCoordKey = getKeyZXY(z, x, y);\n\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return (\n        /** @type {!import(\"../Tile.js\").default} */\n        this.tileCache.get(tileCoordKey)\n      );\n    } else {\n      var tileCoord = [z, x, y];\n      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n      var tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);\n      var tile = new CustomTile(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.tileGrid.getTileCoordExtent(tileCoord), this.preemptive_, this.jsonp_);\n      this.tileCache.set(tileCoordKey, tile);\n      return tile;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  UTFGrid.prototype.useTile = function (z, x, y) {\n    var tileCoordKey = getKeyZXY(z, x, y);\n\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  };\n\n  return UTFGrid;\n}(TileSource);\n\nexport default UTFGrid;","map":{"version":3,"sources":["../src/source/UTFGrid.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/source/UTFGrid\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport { createFromTemplates, nullTileUrlFunction } from '../tileurlfunction.js';\nimport { assert } from '../asserts.js';\nimport { listenOnce } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { applyTransform, intersects } from '../extent.js';\nimport { jsonp as requestJSONP } from '../net.js';\nimport { get as getProjection, getTransformFromProjections } from '../proj.js';\nimport SourceState from './State.js';\nimport TileSource from './Tile.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\n/**\n * @typedef {Object} UTFGridJSON\n * @property {Array<string>} grid The grid.\n * @property {Array<string>} keys The keys.\n * @property {Object<string, Object>} [data] Optional data.\n */\nvar CustomTile = /** @class */ (function (_super) {\n    __extends(CustomTile, _super);\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {TileState} state State.\n     * @param {string} src Image source URI.\n     * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\n     * @param {boolean} preemptive Load the tile when visible (before it's needed).\n     * @param {boolean} jsonp Load the tile as a script.\n     */\n    function CustomTile(tileCoord, state, src, extent, preemptive, jsonp) {\n        var _this = _super.call(this, tileCoord, state) || this;\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.src_ = src;\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        _this.extent_ = extent;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.preemptive_ = preemptive;\n        /**\n         * @private\n         * @type {Array<string>}\n         */\n        _this.grid_ = null;\n        /**\n         * @private\n         * @type {Array<string>}\n         */\n        _this.keys_ = null;\n        /**\n         * @private\n         * @type {Object<string, Object>|undefined}\n         */\n        _this.data_ = null;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.jsonp_ = jsonp;\n        return _this;\n    }\n    /**\n     * Get the image element for this tile.\n     * @return {HTMLImageElement} Image.\n     */\n    CustomTile.prototype.getImage = function () {\n        return null;\n    };\n    /**\n     * Synchronously returns data at given coordinate (if available).\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {*} The data.\n     */\n    CustomTile.prototype.getData = function (coordinate) {\n        if (!this.grid_ || !this.keys_) {\n            return null;\n        }\n        var xRelative = (coordinate[0] - this.extent_[0]) /\n            (this.extent_[2] - this.extent_[0]);\n        var yRelative = (coordinate[1] - this.extent_[1]) /\n            (this.extent_[3] - this.extent_[1]);\n        var row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n        if (typeof row !== 'string') {\n            return null;\n        }\n        var code = row.charCodeAt(Math.floor(xRelative * row.length));\n        if (code >= 93) {\n            code--;\n        }\n        if (code >= 35) {\n            code--;\n        }\n        code -= 32;\n        var data = null;\n        if (code in this.keys_) {\n            var id = this.keys_[code];\n            if (this.data_ && id in this.data_) {\n                data = this.data_[id];\n            }\n            else {\n                data = id;\n            }\n        }\n        return data;\n    };\n    /**\n     * Calls the callback (synchronously by default) with the available data\n     * for given coordinate (or `null` if not yet loaded).\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {function(*): void} callback Callback.\n     * @param {boolean=} opt_request If `true` the callback is always async.\n     *                               The tile data is requested if not yet loaded.\n     */\n    CustomTile.prototype.forDataAtCoordinate = function (coordinate, callback, opt_request) {\n        if (this.state == TileState.EMPTY && opt_request === true) {\n            this.state = TileState.IDLE;\n            listenOnce(this, EventType.CHANGE, function (e) {\n                callback(this.getData(coordinate));\n            }, this);\n            this.loadInternal_();\n        }\n        else {\n            if (opt_request === true) {\n                setTimeout(function () {\n                    callback(this.getData(coordinate));\n                }.bind(this), 0);\n            }\n            else {\n                callback(this.getData(coordinate));\n            }\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    CustomTile.prototype.getKey = function () {\n        return this.src_;\n    };\n    /**\n     * @private\n     */\n    CustomTile.prototype.handleError_ = function () {\n        this.state = TileState.ERROR;\n        this.changed();\n    };\n    /**\n     * @param {!UTFGridJSON} json UTFGrid data.\n     * @private\n     */\n    CustomTile.prototype.handleLoad_ = function (json) {\n        this.grid_ = json['grid'];\n        this.keys_ = json['keys'];\n        this.data_ = json['data'];\n        this.state = TileState.LOADED;\n        this.changed();\n    };\n    /**\n     * @private\n     */\n    CustomTile.prototype.loadInternal_ = function () {\n        if (this.state == TileState.IDLE) {\n            this.state = TileState.LOADING;\n            if (this.jsonp_) {\n                requestJSONP(this.src_, this.handleLoad_.bind(this), this.handleError_.bind(this));\n            }\n            else {\n                var client = new XMLHttpRequest();\n                client.addEventListener('load', this.onXHRLoad_.bind(this));\n                client.addEventListener('error', this.onXHRError_.bind(this));\n                client.open('GET', this.src_);\n                client.send();\n            }\n        }\n    };\n    /**\n     * @private\n     * @param {Event} event The load event.\n     */\n    CustomTile.prototype.onXHRLoad_ = function (event) {\n        var client = /** @type {XMLHttpRequest} */ (event.target);\n        // status will be 0 for file:// urls\n        if (!client.status || client.status >= 200 && client.status < 300) {\n            var response = void 0;\n            try {\n                response = /** @type {!UTFGridJSON} */ (JSON.parse(client.responseText));\n            }\n            catch (err) {\n                this.handleError_();\n                return;\n            }\n            this.handleLoad_(response);\n        }\n        else {\n            this.handleError_();\n        }\n    };\n    /**\n     * @private\n     * @param {Event} event The error event.\n     */\n    CustomTile.prototype.onXHRError_ = function (event) {\n        this.handleError_();\n    };\n    /**\n     * @override\n     */\n    CustomTile.prototype.load = function () {\n        if (this.preemptive_) {\n            this.loadInternal_();\n        }\n        else {\n            this.setState(TileState.EMPTY);\n        }\n    };\n    return CustomTile;\n}(Tile));\nexport { CustomTile };\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false` (lazy loading), you need to pass `true` as\n * `opt_request` to the `forDataAtCoordinateAndResolution` method otherwise no\n * data will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n */\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n * @api\n */\nvar UTFGrid = /** @class */ (function (_super) {\n    __extends(UTFGrid, _super);\n    /**\n     * @param {Options} options Source options.\n     */\n    function UTFGrid(options) {\n        var _this = _super.call(this, {\n            projection: getProjection('EPSG:3857'),\n            state: SourceState.LOADING\n        }) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.preemptive_ = options.preemptive !== undefined ?\n            options.preemptive : true;\n        /**\n         * @private\n         * @type {!import(\"../Tile.js\").UrlFunction}\n         */\n        _this.tileUrlFunction_ = nullTileUrlFunction;\n        /**\n         * @private\n         * @type {string|undefined}\n         */\n        _this.template_ = undefined;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.jsonp_ = options.jsonp || false;\n        if (options.url) {\n            if (_this.jsonp_) {\n                requestJSONP(options.url, _this.handleTileJSONResponse.bind(_this), _this.handleTileJSONError.bind(_this));\n            }\n            else {\n                var client = new XMLHttpRequest();\n                client.addEventListener('load', _this.onXHRLoad_.bind(_this));\n                client.addEventListener('error', _this.onXHRError_.bind(_this));\n                client.open('GET', options.url);\n                client.send();\n            }\n        }\n        else if (options.tileJSON) {\n            _this.handleTileJSONResponse(options.tileJSON);\n        }\n        else {\n            assert(false, 51); // Either `url` or `tileJSON` options must be provided\n        }\n        return _this;\n    }\n    /**\n     * @private\n     * @param {Event} event The load event.\n     */\n    UTFGrid.prototype.onXHRLoad_ = function (event) {\n        var client = /** @type {XMLHttpRequest} */ (event.target);\n        // status will be 0 for file:// urls\n        if (!client.status || client.status >= 200 && client.status < 300) {\n            var response = void 0;\n            try {\n                response = /** @type {import(\"./TileJSON.js\").Config} */ (JSON.parse(client.responseText));\n            }\n            catch (err) {\n                this.handleTileJSONError();\n                return;\n            }\n            this.handleTileJSONResponse(response);\n        }\n        else {\n            this.handleTileJSONError();\n        }\n    };\n    /**\n     * @private\n     * @param {Event} event The error event.\n     */\n    UTFGrid.prototype.onXHRError_ = function (event) {\n        this.handleTileJSONError();\n    };\n    /**\n     * Return the template from TileJSON.\n     * @return {string|undefined} The template from TileJSON.\n     * @api\n     */\n    UTFGrid.prototype.getTemplate = function () {\n        return this.template_;\n    };\n    /**\n     * Calls the callback (synchronously by default) with the available data\n     * for given coordinate and resolution (or `null` if not yet loaded or\n     * in case of an error).\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {function(*): void} callback Callback.\n     * @param {boolean=} opt_request If `true` the callback is always async.\n     *                               The tile data is requested if not yet loaded.\n     * @api\n     */\n    UTFGrid.prototype.forDataAtCoordinateAndResolution = function (coordinate, resolution, callback, opt_request) {\n        if (this.tileGrid) {\n            var z = this.tileGrid.getZForResolution(resolution, this.zDirection);\n            var tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n            var tile = /** @type {!CustomTile} */ (this.getTile(tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection()));\n            tile.forDataAtCoordinate(coordinate, callback, opt_request);\n        }\n        else {\n            if (opt_request === true) {\n                setTimeout(function () {\n                    callback(null);\n                }, 0);\n            }\n            else {\n                callback(null);\n            }\n        }\n    };\n    /**\n     * @protected\n     */\n    UTFGrid.prototype.handleTileJSONError = function () {\n        this.setState(SourceState.ERROR);\n    };\n    /**\n     * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n     * @protected\n     * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\n     */\n    UTFGrid.prototype.handleTileJSONResponse = function (tileJSON) {\n        var epsg4326Projection = getProjection('EPSG:4326');\n        var sourceProjection = this.getProjection();\n        var extent;\n        if (tileJSON['bounds'] !== undefined) {\n            var transform = getTransformFromProjections(epsg4326Projection, sourceProjection);\n            extent = applyTransform(tileJSON['bounds'], transform);\n        }\n        var minZoom = tileJSON['minzoom'] || 0;\n        var maxZoom = tileJSON['maxzoom'] || 22;\n        var tileGrid = createXYZ({\n            extent: extentFromProjection(sourceProjection),\n            maxZoom: maxZoom,\n            minZoom: minZoom\n        });\n        this.tileGrid = tileGrid;\n        this.template_ = tileJSON['template'];\n        var grids = tileJSON['grids'];\n        if (!grids) {\n            this.setState(SourceState.ERROR);\n            return;\n        }\n        this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n        if (tileJSON['attribution'] !== undefined) {\n            var attributionExtent_1 = extent !== undefined ?\n                extent : epsg4326Projection.getExtent();\n            this.setAttributions(function (frameState) {\n                if (intersects(attributionExtent_1, frameState.extent)) {\n                    return [tileJSON['attribution']];\n                }\n                return null;\n            });\n        }\n        this.setState(SourceState.READY);\n    };\n    /**\n     * @inheritDoc\n     */\n    UTFGrid.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        var tileCoordKey = getKeyZXY(z, x, y);\n        if (this.tileCache.containsKey(tileCoordKey)) {\n            return (\n            /** @type {!import(\"../Tile.js\").default} */ (this.tileCache.get(tileCoordKey)));\n        }\n        else {\n            var tileCoord = [z, x, y];\n            var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n            var tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);\n            var tile = new CustomTile(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.tileGrid.getTileCoordExtent(tileCoord), this.preemptive_, this.jsonp_);\n            this.tileCache.set(tileCoordKey, tile);\n            return tile;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    UTFGrid.prototype.useTile = function (z, x, y) {\n        var tileCoordKey = getKeyZXY(z, x, y);\n        if (this.tileCache.containsKey(tileCoordKey)) {\n            this.tileCache.get(tileCoordKey);\n        }\n    };\n    return UTFGrid;\n}(TileSource));\nexport default UTFGrid;\n//# sourceMappingURL=UTFGrid.js.map"]},"metadata":{},"sourceType":"module"}