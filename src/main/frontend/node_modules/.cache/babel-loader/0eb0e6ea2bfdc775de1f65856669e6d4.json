{"ast":null,"code":"/**\n * @module ol/webgl/PostProcessingPass\n */\nvar DEFAULT_VERTEX_SHADER = \"\\n  precision mediump float;\\n  \\n  attribute vec2 a_position;\\n  varying vec2 v_texCoord;\\n  varying vec2 v_screenCoord;\\n  \\n  uniform vec2 u_screenSize;\\n   \\n  void main() {\\n    v_texCoord = a_position * 0.5 + 0.5;\\n    v_screenCoord = v_texCoord * u_screenSize;\\n    gl_Position = vec4(a_position, 0.0, 1.0);\\n  }\\n\";\nvar DEFAULT_FRAGMENT_SHADER = \"\\n  precision mediump float;\\n   \\n  uniform sampler2D u_image;\\n   \\n  varying vec2 v_texCoord;\\n   \\n  void main() {\\n    gl_FragColor = texture2D(u_image, v_texCoord);\\n  }\\n\";\n/**\n * @typedef {Object} Options\n * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object.<string,import(\"./Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {import(\"./Helper\").UniformValue} value Value\n * @property {number} location Location\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n\n/**\n * @classdesc\n * This class is used to define Post Processing passes with custom shaders and uniforms.\n * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.\n *\n * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that\n * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).\n * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.\n *\n * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be\n * premultiplied.\n *\n * Default shaders are shown hereafter:\n *\n * * Vertex shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   attribute vec2 a_position;\n *   varying vec2 v_texCoord;\n *   varying vec2 v_screenCoord;\n *\n *   uniform vec2 u_screenSize;\n *\n *   void main() {\n *     v_texCoord = a_position * 0.5 + 0.5;\n *     v_screenCoord = v_texCoord * u_screenSize;\n *     gl_Position = vec4(a_position, 0.0, 1.0);\n *   }\n *   ```\n *\n * * Fragment shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   uniform sampler2D u_image;\n *\n *   varying vec2 v_texCoord;\n *\n *   void main() {\n *     gl_FragColor = texture2D(u_image, v_texCoord);\n *   }\n *   ```\n *\n * @api\n */\n\nvar WebGLPostProcessingPass =\n/** @class */\nfunction () {\n  /**\n   * @param {Options} options Options.\n   */\n  function WebGLPostProcessingPass(options) {\n    this.gl_ = options.webGlContext;\n    var gl = this.gl_;\n    this.scaleRatio_ = options.scaleRatio || 1;\n    this.renderTargetTexture_ = gl.createTexture();\n    this.renderTargetTextureSize_ = null;\n    this.frameBuffer_ = gl.createFramebuffer(); // compile the program for the frame buffer\n    // TODO: make compilation errors show up\n\n    var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);\n    gl.compileShader(vertexShader);\n    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);\n    gl.compileShader(fragmentShader);\n    this.renderTargetProgram_ = gl.createProgram();\n    gl.attachShader(this.renderTargetProgram_, vertexShader);\n    gl.attachShader(this.renderTargetProgram_, fragmentShader);\n    gl.linkProgram(this.renderTargetProgram_); // bind the vertices buffer for the frame buffer\n\n    this.renderTargetVerticesBuffer_ = gl.createBuffer();\n    var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);\n    this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');\n    this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');\n    this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');\n    /**\n     * Holds info about custom uniforms used in the post processing pass\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n\n    this.uniforms_ = [];\n    options.uniforms && Object.keys(options.uniforms).forEach(function (name) {\n      this.uniforms_.push({\n        value: options.uniforms[name],\n        location: gl.getUniformLocation(this.renderTargetProgram_, name)\n      });\n    }.bind(this));\n  }\n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   * @api\n   */\n\n\n  WebGLPostProcessingPass.prototype.getGL = function () {\n    return this.gl_;\n  };\n  /**\n   * Initialize the render target texture of the post process, make sure it is at the\n   * right size and bind it as a render target for the next draw calls.\n   * The last step to be initialized will be the one where the primitives are rendered.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @api\n   */\n\n\n  WebGLPostProcessingPass.prototype.init = function (frameState) {\n    var gl = this.getGL();\n    var textureSize = [gl.drawingBufferWidth * this.scaleRatio_, gl.drawingBufferHeight * this.scaleRatio_]; // rendering goes to my buffer\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());\n    gl.viewport(0, 0, textureSize[0], textureSize[1]); // if size has changed: adjust canvas & render target texture\n\n    if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {\n      this.renderTargetTextureSize_ = textureSize; // create a new texture\n\n      var level = 0;\n      var internalFormat = gl.RGBA;\n      var border = 0;\n      var format = gl.RGBA;\n      var type = gl.UNSIGNED_BYTE;\n      var data = null;\n      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); // bind the texture to the framebuffer\n\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);\n    }\n  };\n  /**\n   * Render to the next postprocessing pass (or to the canvas if final pass).\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional\n   * @api\n   */\n\n\n  WebGLPostProcessingPass.prototype.apply = function (frameState, nextPass) {\n    var gl = this.getGL();\n    var size = frameState.size;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_); // render the frame buffer to the canvas\n\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n    gl.useProgram(this.renderTargetProgram_);\n    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);\n    gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);\n    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);\n    gl.uniform1i(this.renderTargetTextureLocation_, 0);\n    this.applyUniforms(frameState);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  };\n  /**\n   * @returns {WebGLFramebuffer} Frame buffer\n   * @api\n   */\n\n\n  WebGLPostProcessingPass.prototype.getFrameBuffer = function () {\n    return this.frameBuffer_;\n  };\n  /**\n   * Sets the custom uniforms based on what was given in the constructor.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @private\n   */\n\n\n  WebGLPostProcessingPass.prototype.applyUniforms = function (frameState) {\n    var gl = this.getGL();\n    var value;\n    var textureSlot = 1;\n    this.uniforms_.forEach(function (uniform) {\n      value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value; // apply value based on type\n\n      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {\n        // create a texture & put data\n        if (!uniform.texture) {\n          uniform.texture = gl.createTexture();\n        }\n\n        gl.activeTexture(gl[\"TEXTURE\" + textureSlot]);\n        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n        if (value instanceof ImageData) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));\n        } else {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n        } // fill texture slots\n\n\n        gl.uniform1i(uniform.location, textureSlot++);\n      } else if (Array.isArray(value)) {\n        switch (value.length) {\n          case 2:\n            gl.uniform2f(uniform.location, value[0], value[1]);\n            return;\n\n          case 3:\n            gl.uniform3f(uniform.location, value[0], value[1], value[2]);\n            return;\n\n          case 4:\n            gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);\n            return;\n\n          default:\n            return;\n        }\n      } else if (typeof value === 'number') {\n        gl.uniform1f(uniform.location, value);\n      }\n    });\n  };\n\n  return WebGLPostProcessingPass;\n}();\n\nexport default WebGLPostProcessingPass;","map":{"version":3,"sources":["../src/webgl/PostProcessingPass.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/webgl/PostProcessingPass\n */\nvar DEFAULT_VERTEX_SHADER = \"\\n  precision mediump float;\\n  \\n  attribute vec2 a_position;\\n  varying vec2 v_texCoord;\\n  varying vec2 v_screenCoord;\\n  \\n  uniform vec2 u_screenSize;\\n   \\n  void main() {\\n    v_texCoord = a_position * 0.5 + 0.5;\\n    v_screenCoord = v_texCoord * u_screenSize;\\n    gl_Position = vec4(a_position, 0.0, 1.0);\\n  }\\n\";\nvar DEFAULT_FRAGMENT_SHADER = \"\\n  precision mediump float;\\n   \\n  uniform sampler2D u_image;\\n   \\n  varying vec2 v_texCoord;\\n   \\n  void main() {\\n    gl_FragColor = texture2D(u_image, v_texCoord);\\n  }\\n\";\n/**\n * @typedef {Object} Options\n * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object.<string,import(\"./Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {import(\"./Helper\").UniformValue} value Value\n * @property {number} location Location\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n/**\n * @classdesc\n * This class is used to define Post Processing passes with custom shaders and uniforms.\n * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.\n *\n * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that\n * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).\n * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.\n *\n * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be\n * premultiplied.\n *\n * Default shaders are shown hereafter:\n *\n * * Vertex shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   attribute vec2 a_position;\n *   varying vec2 v_texCoord;\n *   varying vec2 v_screenCoord;\n *\n *   uniform vec2 u_screenSize;\n *\n *   void main() {\n *     v_texCoord = a_position * 0.5 + 0.5;\n *     v_screenCoord = v_texCoord * u_screenSize;\n *     gl_Position = vec4(a_position, 0.0, 1.0);\n *   }\n *   ```\n *\n * * Fragment shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   uniform sampler2D u_image;\n *\n *   varying vec2 v_texCoord;\n *\n *   void main() {\n *     gl_FragColor = texture2D(u_image, v_texCoord);\n *   }\n *   ```\n *\n * @api\n */\nvar WebGLPostProcessingPass = /** @class */ (function () {\n    /**\n     * @param {Options} options Options.\n     */\n    function WebGLPostProcessingPass(options) {\n        this.gl_ = options.webGlContext;\n        var gl = this.gl_;\n        this.scaleRatio_ = options.scaleRatio || 1;\n        this.renderTargetTexture_ = gl.createTexture();\n        this.renderTargetTextureSize_ = null;\n        this.frameBuffer_ = gl.createFramebuffer();\n        // compile the program for the frame buffer\n        // TODO: make compilation errors show up\n        var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);\n        gl.compileShader(vertexShader);\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);\n        gl.compileShader(fragmentShader);\n        this.renderTargetProgram_ = gl.createProgram();\n        gl.attachShader(this.renderTargetProgram_, vertexShader);\n        gl.attachShader(this.renderTargetProgram_, fragmentShader);\n        gl.linkProgram(this.renderTargetProgram_);\n        // bind the vertices buffer for the frame buffer\n        this.renderTargetVerticesBuffer_ = gl.createBuffer();\n        var verticesArray = [\n            -1, -1,\n            1, -1,\n            -1, 1,\n            1, -1,\n            1, 1,\n            -1, 1\n        ];\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);\n        this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');\n        this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');\n        this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');\n        /**\n         * Holds info about custom uniforms used in the post processing pass\n         * @type {Array<UniformInternalDescription>}\n         * @private\n         */\n        this.uniforms_ = [];\n        options.uniforms && Object.keys(options.uniforms).forEach(function (name) {\n            this.uniforms_.push({\n                value: options.uniforms[name],\n                location: gl.getUniformLocation(this.renderTargetProgram_, name)\n            });\n        }.bind(this));\n    }\n    /**\n     * Get the WebGL rendering context\n     * @return {WebGLRenderingContext} The rendering context.\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.getGL = function () {\n        return this.gl_;\n    };\n    /**\n     * Initialize the render target texture of the post process, make sure it is at the\n     * right size and bind it as a render target for the next draw calls.\n     * The last step to be initialized will be the one where the primitives are rendered.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.init = function (frameState) {\n        var gl = this.getGL();\n        var textureSize = [\n            gl.drawingBufferWidth * this.scaleRatio_,\n            gl.drawingBufferHeight * this.scaleRatio_\n        ];\n        // rendering goes to my buffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());\n        gl.viewport(0, 0, textureSize[0], textureSize[1]);\n        // if size has changed: adjust canvas & render target texture\n        if (!this.renderTargetTextureSize_ ||\n            this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {\n            this.renderTargetTextureSize_ = textureSize;\n            // create a new texture\n            var level = 0;\n            var internalFormat = gl.RGBA;\n            var border = 0;\n            var format = gl.RGBA;\n            var type = gl.UNSIGNED_BYTE;\n            var data = null;\n            gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            // bind the texture to the framebuffer\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);\n        }\n    };\n    /**\n     * Render to the next postprocessing pass (or to the canvas if final pass).\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.apply = function (frameState, nextPass) {\n        var gl = this.getGL();\n        var size = frameState.size;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n        // render the frame buffer to the canvas\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n        gl.useProgram(this.renderTargetProgram_);\n        gl.enableVertexAttribArray(this.renderTargetAttribLocation_);\n        gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);\n        gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);\n        gl.uniform1i(this.renderTargetTextureLocation_, 0);\n        this.applyUniforms(frameState);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n    };\n    /**\n     * @returns {WebGLFramebuffer} Frame buffer\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.getFrameBuffer = function () {\n        return this.frameBuffer_;\n    };\n    /**\n     * Sets the custom uniforms based on what was given in the constructor.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPostProcessingPass.prototype.applyUniforms = function (frameState) {\n        var gl = this.getGL();\n        var value;\n        var textureSlot = 1;\n        this.uniforms_.forEach(function (uniform) {\n            value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value;\n            // apply value based on type\n            if (value instanceof HTMLCanvasElement || value instanceof ImageData) {\n                // create a texture & put data\n                if (!uniform.texture) {\n                    uniform.texture = gl.createTexture();\n                }\n                gl.activeTexture(gl[\"TEXTURE\" + textureSlot]);\n                gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                if (value instanceof ImageData) {\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));\n                }\n                else {\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n                }\n                // fill texture slots\n                gl.uniform1i(uniform.location, textureSlot++);\n            }\n            else if (Array.isArray(value)) {\n                switch (value.length) {\n                    case 2:\n                        gl.uniform2f(uniform.location, value[0], value[1]);\n                        return;\n                    case 3:\n                        gl.uniform3f(uniform.location, value[0], value[1], value[2]);\n                        return;\n                    case 4:\n                        gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);\n                        return;\n                    default: return;\n                }\n            }\n            else if (typeof value === 'number') {\n                gl.uniform1f(uniform.location, value);\n            }\n        });\n    };\n    return WebGLPostProcessingPass;\n}());\nexport default WebGLPostProcessingPass;\n//# sourceMappingURL=PostProcessingPass.js.map"]},"metadata":{},"sourceType":"module"}