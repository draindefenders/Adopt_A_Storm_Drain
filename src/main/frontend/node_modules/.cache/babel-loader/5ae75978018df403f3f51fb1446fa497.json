{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/layer/Heatmap\n */\n\n\nimport { getChangeEventType } from '../Object.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport VectorLayer from './Vector.js';\nimport { clamp } from '../math.js';\nimport { assign } from '../obj.js';\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient\n * of the heatmap, specified as an array of CSS color strings.\n * @property {number} [radius=8] Radius size in pixels.\n * @property {number} [blur=15] Blur size in pixels.\n * @property {string|function(import(\"../Feature.js\").default):number} [weight='weight'] The feature\n * attribute to use for the weight or a function that returns a weight from a feature. Weight values\n * should range from 0 to 1 (and values outside will be clamped to that range).\n * @property {import(\"../source/Vector.js\").default} [source] Source.\n */\n\n/**\n * @enum {string}\n * @private\n */\n\nvar Property = {\n  BLUR: 'blur',\n  GRADIENT: 'gradient',\n  RADIUS: 'radius'\n};\n/**\n * @const\n * @type {Array<string>}\n */\n\nvar DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];\n/**\n * @classdesc\n * Layer for rendering vector data as a heatmap.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @api\n */\n\nvar Heatmap =\n/** @class */\nfunction (_super) {\n  __extends(Heatmap, _super);\n  /**\n   * @param {Options=} opt_options Options.\n   */\n\n\n  function Heatmap(opt_options) {\n    var _this = this;\n\n    var options = opt_options ? opt_options : {};\n    var baseOptions = assign({}, options);\n    delete baseOptions.gradient;\n    delete baseOptions.radius;\n    delete baseOptions.blur;\n    delete baseOptions.weight;\n    _this = _super.call(this, baseOptions) || this;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    _this.gradient_ = null;\n\n    _this.addEventListener(getChangeEventType(Property.GRADIENT), _this.handleGradientChanged_);\n\n    _this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);\n\n    _this.setBlur(options.blur !== undefined ? options.blur : 15);\n\n    _this.setRadius(options.radius !== undefined ? options.radius : 8);\n\n    var weight = options.weight ? options.weight : 'weight';\n\n    if (typeof weight === 'string') {\n      _this.weightFunction_ = function (feature) {\n        return feature.get(weight);\n      };\n    } else {\n      _this.weightFunction_ = weight;\n    } // For performance reasons, don't sort the features before rendering.\n    // The render order is not relevant for a heatmap representation.\n\n\n    _this.setRenderOrder(null);\n\n    return _this;\n  }\n  /**\n   * Return the blur size in pixels.\n   * @return {number} Blur size in pixels.\n   * @api\n   * @observable\n   */\n\n\n  Heatmap.prototype.getBlur = function () {\n    return (\n      /** @type {number} */\n      this.get(Property.BLUR)\n    );\n  };\n  /**\n   * Return the gradient colors as array of strings.\n   * @return {Array<string>} Colors.\n   * @api\n   * @observable\n   */\n\n\n  Heatmap.prototype.getGradient = function () {\n    return (\n      /** @type {Array<string>} */\n      this.get(Property.GRADIENT)\n    );\n  };\n  /**\n   * Return the size of the radius in pixels.\n   * @return {number} Radius size in pixel.\n   * @api\n   * @observable\n   */\n\n\n  Heatmap.prototype.getRadius = function () {\n    return (\n      /** @type {number} */\n      this.get(Property.RADIUS)\n    );\n  };\n  /**\n   * @private\n   */\n\n\n  Heatmap.prototype.handleGradientChanged_ = function () {\n    this.gradient_ = createGradient(this.getGradient());\n  };\n  /**\n   * Set the blur size in pixels.\n   * @param {number} blur Blur size in pixels.\n   * @api\n   * @observable\n   */\n\n\n  Heatmap.prototype.setBlur = function (blur) {\n    this.set(Property.BLUR, blur);\n  };\n  /**\n   * Set the gradient colors as array of strings.\n   * @param {Array<string>} colors Gradient.\n   * @api\n   * @observable\n   */\n\n\n  Heatmap.prototype.setGradient = function (colors) {\n    this.set(Property.GRADIENT, colors);\n  };\n  /**\n   * Set the size of the radius in pixels.\n   * @param {number} radius Radius size in pixel.\n   * @api\n   * @observable\n   */\n\n\n  Heatmap.prototype.setRadius = function (radius) {\n    this.set(Property.RADIUS, radius);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Heatmap.prototype.createRenderer = function () {\n    return new WebGLPointsLayerRenderer(this, {\n      attributes: [{\n        name: 'weight',\n        callback: function (feature) {\n          var weight = this.weightFunction_(feature);\n          return weight !== undefined ? clamp(weight, 0, 1) : 1;\n        }.bind(this)\n      }],\n      vertexShader: \"\\n        precision mediump float;\\n        uniform mat4 u_projectionMatrix;\\n        uniform mat4 u_offsetScaleMatrix;\\n        uniform float u_size;\\n        attribute vec2 a_position;\\n        attribute float a_index;\\n        attribute float a_weight;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n\\n        void main(void) {\\n          mat4 offsetMatrix = u_offsetScaleMatrix;\\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\\n          v_texCoord = vec2(u, v);\\n          v_weight = a_weight;\\n        }\",\n      fragmentShader: \"\\n        precision mediump float;\\n        uniform float u_blurSlope;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n\\n        void main(void) {\\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\\n        }\",\n      hitVertexShader: \"\\n        precision mediump float;\\n        uniform mat4 u_projectionMatrix;\\n        uniform mat4 u_offsetScaleMatrix;\\n        uniform float u_size;\\n        attribute vec2 a_position;\\n        attribute float a_index;\\n        attribute float a_weight;\\n        attribute vec4 a_hitColor;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n        varying vec4 v_hitColor;\\n\\n        void main(void) {\\n          mat4 offsetMatrix = u_offsetScaleMatrix;\\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\\n          v_texCoord = vec2(u, v);\\n          v_hitColor = a_hitColor;\\n          v_weight = a_weight;\\n        }\",\n      hitFragmentShader: \"\\n        precision mediump float;\\n        uniform float u_blurSlope;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n        varying vec4 v_hitColor;\\n\\n        void main(void) {\\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\\n          if (alpha < 0.05) {\\n            discard;\\n          }\\n\\n          gl_FragColor = v_hitColor;\\n        }\",\n      uniforms: {\n        u_size: function () {\n          return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;\n        }.bind(this),\n        u_blurSlope: function () {\n          return this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR));\n        }.bind(this)\n      },\n      postProcesses: [{\n        fragmentShader: \"\\n            precision mediump float;\\n\\n            uniform sampler2D u_image;\\n            uniform sampler2D u_gradientTexture;\\n\\n            varying vec2 v_texCoord;\\n\\n            void main() {\\n              vec4 color = texture2D(u_image, v_texCoord);\\n              gl_FragColor.a = color.a;\\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\\n              gl_FragColor.rgb *= gl_FragColor.a;\\n            }\",\n        uniforms: {\n          u_gradientTexture: function () {\n            return this.gradient_;\n          }.bind(this)\n        }\n      }]\n    });\n  };\n\n  return Heatmap;\n}(VectorLayer);\n/**\n * @param {Array<string>} colors A list of colored.\n * @return {HTMLCanvasElement} canvas with gradient texture.\n */\n\n\nfunction createGradient(colors) {\n  var width = 1;\n  var height = 256;\n  var context = createCanvasContext2D(width, height);\n  var gradient = context.createLinearGradient(0, 0, width, height);\n  var step = 1 / (colors.length - 1);\n\n  for (var i = 0, ii = colors.length; i < ii; ++i) {\n    gradient.addColorStop(i * step, colors[i]);\n  }\n\n  context.fillStyle = gradient;\n  context.fillRect(0, 0, width, height);\n  return context.canvas;\n}\n\nexport default Heatmap;","map":{"version":3,"sources":["../src/layer/Heatmap.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/layer/Heatmap\n */\nimport { getChangeEventType } from '../Object.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport VectorLayer from './Vector.js';\nimport { clamp } from '../math.js';\nimport { assign } from '../obj.js';\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient\n * of the heatmap, specified as an array of CSS color strings.\n * @property {number} [radius=8] Radius size in pixels.\n * @property {number} [blur=15] Blur size in pixels.\n * @property {string|function(import(\"../Feature.js\").default):number} [weight='weight'] The feature\n * attribute to use for the weight or a function that returns a weight from a feature. Weight values\n * should range from 0 to 1 (and values outside will be clamped to that range).\n * @property {import(\"../source/Vector.js\").default} [source] Source.\n */\n/**\n * @enum {string}\n * @private\n */\nvar Property = {\n    BLUR: 'blur',\n    GRADIENT: 'gradient',\n    RADIUS: 'radius'\n};\n/**\n * @const\n * @type {Array<string>}\n */\nvar DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];\n/**\n * @classdesc\n * Layer for rendering vector data as a heatmap.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @api\n */\nvar Heatmap = /** @class */ (function (_super) {\n    __extends(Heatmap, _super);\n    /**\n     * @param {Options=} opt_options Options.\n     */\n    function Heatmap(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        var baseOptions = assign({}, options);\n        delete baseOptions.gradient;\n        delete baseOptions.radius;\n        delete baseOptions.blur;\n        delete baseOptions.weight;\n        _this = _super.call(this, baseOptions) || this;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.gradient_ = null;\n        _this.addEventListener(getChangeEventType(Property.GRADIENT), _this.handleGradientChanged_);\n        _this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);\n        _this.setBlur(options.blur !== undefined ? options.blur : 15);\n        _this.setRadius(options.radius !== undefined ? options.radius : 8);\n        var weight = options.weight ? options.weight : 'weight';\n        if (typeof weight === 'string') {\n            _this.weightFunction_ = function (feature) {\n                return feature.get(weight);\n            };\n        }\n        else {\n            _this.weightFunction_ = weight;\n        }\n        // For performance reasons, don't sort the features before rendering.\n        // The render order is not relevant for a heatmap representation.\n        _this.setRenderOrder(null);\n        return _this;\n    }\n    /**\n     * Return the blur size in pixels.\n     * @return {number} Blur size in pixels.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.getBlur = function () {\n        return /** @type {number} */ (this.get(Property.BLUR));\n    };\n    /**\n     * Return the gradient colors as array of strings.\n     * @return {Array<string>} Colors.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.getGradient = function () {\n        return /** @type {Array<string>} */ (this.get(Property.GRADIENT));\n    };\n    /**\n     * Return the size of the radius in pixels.\n     * @return {number} Radius size in pixel.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.getRadius = function () {\n        return /** @type {number} */ (this.get(Property.RADIUS));\n    };\n    /**\n     * @private\n     */\n    Heatmap.prototype.handleGradientChanged_ = function () {\n        this.gradient_ = createGradient(this.getGradient());\n    };\n    /**\n     * Set the blur size in pixels.\n     * @param {number} blur Blur size in pixels.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.setBlur = function (blur) {\n        this.set(Property.BLUR, blur);\n    };\n    /**\n     * Set the gradient colors as array of strings.\n     * @param {Array<string>} colors Gradient.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.setGradient = function (colors) {\n        this.set(Property.GRADIENT, colors);\n    };\n    /**\n     * Set the size of the radius in pixels.\n     * @param {number} radius Radius size in pixel.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.setRadius = function (radius) {\n        this.set(Property.RADIUS, radius);\n    };\n    /**\n     * @inheritDoc\n     */\n    Heatmap.prototype.createRenderer = function () {\n        return new WebGLPointsLayerRenderer(this, {\n            attributes: [\n                {\n                    name: 'weight',\n                    callback: function (feature) {\n                        var weight = this.weightFunction_(feature);\n                        return weight !== undefined ? clamp(weight, 0, 1) : 1;\n                    }.bind(this)\n                }\n            ],\n            vertexShader: \"\\n        precision mediump float;\\n        uniform mat4 u_projectionMatrix;\\n        uniform mat4 u_offsetScaleMatrix;\\n        uniform float u_size;\\n        attribute vec2 a_position;\\n        attribute float a_index;\\n        attribute float a_weight;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n\\n        void main(void) {\\n          mat4 offsetMatrix = u_offsetScaleMatrix;\\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\\n          v_texCoord = vec2(u, v);\\n          v_weight = a_weight;\\n        }\",\n            fragmentShader: \"\\n        precision mediump float;\\n        uniform float u_blurSlope;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n\\n        void main(void) {\\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\\n        }\",\n            hitVertexShader: \"\\n        precision mediump float;\\n        uniform mat4 u_projectionMatrix;\\n        uniform mat4 u_offsetScaleMatrix;\\n        uniform float u_size;\\n        attribute vec2 a_position;\\n        attribute float a_index;\\n        attribute float a_weight;\\n        attribute vec4 a_hitColor;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n        varying vec4 v_hitColor;\\n\\n        void main(void) {\\n          mat4 offsetMatrix = u_offsetScaleMatrix;\\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\\n          v_texCoord = vec2(u, v);\\n          v_hitColor = a_hitColor;\\n          v_weight = a_weight;\\n        }\",\n            hitFragmentShader: \"\\n        precision mediump float;\\n        uniform float u_blurSlope;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n        varying vec4 v_hitColor;\\n\\n        void main(void) {\\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\\n          if (alpha < 0.05) {\\n            discard;\\n          }\\n\\n          gl_FragColor = v_hitColor;\\n        }\",\n            uniforms: {\n                u_size: function () {\n                    return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;\n                }.bind(this),\n                u_blurSlope: function () {\n                    return this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR));\n                }.bind(this)\n            },\n            postProcesses: [\n                {\n                    fragmentShader: \"\\n            precision mediump float;\\n\\n            uniform sampler2D u_image;\\n            uniform sampler2D u_gradientTexture;\\n\\n            varying vec2 v_texCoord;\\n\\n            void main() {\\n              vec4 color = texture2D(u_image, v_texCoord);\\n              gl_FragColor.a = color.a;\\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\\n              gl_FragColor.rgb *= gl_FragColor.a;\\n            }\",\n                    uniforms: {\n                        u_gradientTexture: function () {\n                            return this.gradient_;\n                        }.bind(this)\n                    }\n                }\n            ]\n        });\n    };\n    return Heatmap;\n}(VectorLayer));\n/**\n * @param {Array<string>} colors A list of colored.\n * @return {HTMLCanvasElement} canvas with gradient texture.\n */\nfunction createGradient(colors) {\n    var width = 1;\n    var height = 256;\n    var context = createCanvasContext2D(width, height);\n    var gradient = context.createLinearGradient(0, 0, width, height);\n    var step = 1 / (colors.length - 1);\n    for (var i = 0, ii = colors.length; i < ii; ++i) {\n        gradient.addColorStop(i * step, colors[i]);\n    }\n    context.fillStyle = gradient;\n    context.fillRect(0, 0, width, height);\n    return context.canvas;\n}\nexport default Heatmap;\n//# sourceMappingURL=Heatmap.js.map"]},"metadata":{},"sourceType":"module"}