{"ast":null,"code":"/**\n * @module ol/reproj\n */\nimport { createCanvasContext2D } from './dom.js';\nimport { containsCoordinate, createEmpty, extend, getHeight, getTopLeft, getWidth } from './extent.js';\nimport { solveLinearSystem } from './math.js';\nimport { getPointResolution, transform } from './proj.js';\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\n\nexport function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {\n  var sourceCenter = transform(targetCenter, targetProj, sourceProj); // calculate the ideal resolution of the source data\n\n  var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n  var targetMetersPerUnit = targetProj.getMetersPerUnit();\n\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n\n  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  } // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n\n  var sourceExtent = sourceProj.getExtent();\n\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;\n\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n/**\n * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n * in order to mask gaps caused by antialiasing.\n *\n * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n * @param {number} x X coordinate of the point (in pixels).\n * @param {number} y Y coordinate of the point (in pixels).\n * @return {import(\"./coordinate.js\").Coordinate} New point 1 px farther from the centroid.\n */\n\nfunction enlargeClipPoint(centroidX, centroidY, x, y) {\n  var dX = x - centroidX;\n  var dY = y - centroidY;\n  var distance = Math.sqrt(dX * dX + dY * dY);\n  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n}\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation\n * Calculated triangulation.\n * @param {Array<{extent: import(\"./extent.js\").Extent,\n *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources\n * Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\n\n\nexport function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {\n  var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n  var sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n  var canvasWidthInUnits = getWidth(sourceDataExtent);\n  var canvasHeightInUnits = getHeight(sourceDataExtent);\n  var stitchContext = createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n  var stitchScale = pixelRatio / sourceResolution;\n  sources.forEach(function (src, i, arr) {\n    var xPos = src.extent[0] - sourceDataExtent[0];\n    var yPos = -(src.extent[3] - sourceDataExtent[3]);\n    var srcWidth = getWidth(src.extent);\n    var srcHeight = getHeight(src.extent);\n    stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);\n  });\n  var targetTopLeft = getTopLeft(targetExtent);\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    var source = triangle.source;\n    var target = triangle.target;\n    var x0 = source[0][0],\n        y0 = source[0][1];\n    var x1 = source[1][0],\n        y1 = source[1][1];\n    var x2 = source[2][0],\n        y2 = source[2][1];\n    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution; // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n\n    var sourceNumericalShiftX = x0;\n    var sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];\n    var affineCoefs = solveLinearSystem(augmentedMatrix);\n\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n    var centroidX = (u0 + u1 + u2) / 3;\n    var centroidY = (v0 + v1 + v2) / 3;\n    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);\n    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);\n    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);\n    context.moveTo(p1[0], p1[1]);\n    context.lineTo(p0[0], p0[1]);\n    context.lineTo(p2[0], p2[1]);\n    context.clip();\n    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  if (opt_renderEdges) {\n    context.save();\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      var target = triangle.target;\n      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n    context.restore();\n  }\n\n  return context.canvas;\n}","map":{"version":3,"sources":["src/reproj.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/reproj\n */\nimport { createCanvasContext2D } from './dom.js';\nimport { containsCoordinate, createEmpty, extend, getHeight, getTopLeft, getWidth } from './extent.js';\nimport { solveLinearSystem } from './math.js';\nimport { getPointResolution, transform } from './proj.js';\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {\n    var sourceCenter = transform(targetCenter, targetProj, sourceProj);\n    // calculate the ideal resolution of the source data\n    var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n    var targetMetersPerUnit = targetProj.getMetersPerUnit();\n    if (targetMetersPerUnit !== undefined) {\n        sourceResolution *= targetMetersPerUnit;\n    }\n    var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n    if (sourceMetersPerUnit !== undefined) {\n        sourceResolution /= sourceMetersPerUnit;\n    }\n    // Based on the projection properties, the point resolution at the specified\n    // coordinates may be slightly different. We need to reverse-compensate this\n    // in order to achieve optimal results.\n    var sourceExtent = sourceProj.getExtent();\n    if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n        var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n            sourceResolution;\n        if (isFinite(compensationFactor) && compensationFactor > 0) {\n            sourceResolution /= compensationFactor;\n        }\n    }\n    return sourceResolution;\n}\n/**\n * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n * in order to mask gaps caused by antialiasing.\n *\n * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n * @param {number} x X coordinate of the point (in pixels).\n * @param {number} y Y coordinate of the point (in pixels).\n * @return {import(\"./coordinate.js\").Coordinate} New point 1 px farther from the centroid.\n */\nfunction enlargeClipPoint(centroidX, centroidY, x, y) {\n    var dX = x - centroidX;\n    var dY = y - centroidY;\n    var distance = Math.sqrt(dX * dX + dY * dY);\n    return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n}\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation\n * Calculated triangulation.\n * @param {Array<{extent: import(\"./extent.js\").Extent,\n *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources\n * Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {\n    var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));\n    if (sources.length === 0) {\n        return context.canvas;\n    }\n    context.scale(pixelRatio, pixelRatio);\n    var sourceDataExtent = createEmpty();\n    sources.forEach(function (src, i, arr) {\n        extend(sourceDataExtent, src.extent);\n    });\n    var canvasWidthInUnits = getWidth(sourceDataExtent);\n    var canvasHeightInUnits = getHeight(sourceDataExtent);\n    var stitchContext = createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n    var stitchScale = pixelRatio / sourceResolution;\n    sources.forEach(function (src, i, arr) {\n        var xPos = src.extent[0] - sourceDataExtent[0];\n        var yPos = -(src.extent[3] - sourceDataExtent[3]);\n        var srcWidth = getWidth(src.extent);\n        var srcHeight = getHeight(src.extent);\n        stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);\n    });\n    var targetTopLeft = getTopLeft(targetExtent);\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n        /* Calculate affine transform (src -> dst)\n         * Resulting matrix can be used to transform coordinate\n         * from `sourceProjection` to destination pixels.\n         *\n         * To optimize number of context calls and increase numerical stability,\n         * we also do the following operations:\n         * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n         * here before solving the linear system so [ui, vi] are pixel coordinates.\n         *\n         * Src points: xi, yi\n         * Dst points: ui, vi\n         * Affine coefficients: aij\n         *\n         * | x0 y0 1  0  0 0 |   |a00|   |u0|\n         * | x1 y1 1  0  0 0 |   |a01|   |u1|\n         * | x2 y2 1  0  0 0 | x |a02| = |u2|\n         * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n         * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n         * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n         */\n        var source = triangle.source;\n        var target = triangle.target;\n        var x0 = source[0][0], y0 = source[0][1];\n        var x1 = source[1][0], y1 = source[1][1];\n        var x2 = source[2][0], y2 = source[2][1];\n        var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n        var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n        var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n        var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n        var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n        var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n        // Shift all the source points to improve numerical stability\n        // of all the subsequent calculations. The [x0, y0] is used here.\n        // This is also used to simplify the linear system.\n        var sourceNumericalShiftX = x0;\n        var sourceNumericalShiftY = y0;\n        x0 = 0;\n        y0 = 0;\n        x1 -= sourceNumericalShiftX;\n        y1 -= sourceNumericalShiftY;\n        x2 -= sourceNumericalShiftX;\n        y2 -= sourceNumericalShiftY;\n        var augmentedMatrix = [\n            [x1, y1, 0, 0, u1 - u0],\n            [x2, y2, 0, 0, u2 - u0],\n            [0, 0, x1, y1, v1 - v0],\n            [0, 0, x2, y2, v2 - v0]\n        ];\n        var affineCoefs = solveLinearSystem(augmentedMatrix);\n        if (!affineCoefs) {\n            return;\n        }\n        context.save();\n        context.beginPath();\n        var centroidX = (u0 + u1 + u2) / 3;\n        var centroidY = (v0 + v1 + v2) / 3;\n        var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);\n        var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);\n        var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);\n        context.moveTo(p1[0], p1[1]);\n        context.lineTo(p0[0], p0[1]);\n        context.lineTo(p2[0], p2[1]);\n        context.clip();\n        context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n        context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n        context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);\n        context.drawImage(stitchContext.canvas, 0, 0);\n        context.restore();\n    });\n    if (opt_renderEdges) {\n        context.save();\n        context.strokeStyle = 'black';\n        context.lineWidth = 1;\n        triangulation.getTriangles().forEach(function (triangle, i, arr) {\n            var target = triangle.target;\n            var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n            var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n            var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n            var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n            var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n            var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n            context.beginPath();\n            context.moveTo(u1, v1);\n            context.lineTo(u0, v0);\n            context.lineTo(u2, v2);\n            context.closePath();\n            context.stroke();\n        });\n        context.restore();\n    }\n    return context.canvas;\n}\n//# sourceMappingURL=reproj.js.map"]},"metadata":{},"sourceType":"module"}