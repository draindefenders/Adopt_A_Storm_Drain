{"ast":null,"code":"/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @return {Array<Array<*>>} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\n\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache) {\n  var result = []; // Keep text upright\n\n  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\n  var numChars = text.length;\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  offset += stride;\n  var x2 = flatCoordinates[offset];\n  var y2 = flatCoordinates[offset + 1];\n  var segmentM = 0;\n  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n  var angleChanged = false;\n  var index, previousAngle;\n\n  for (var i = 0; i < numChars; ++i) {\n    index = reverse ? numChars - i - 1 : i;\n    var char = text[index];\n    var charLength = scale * measureAndCacheTextWidth(font, char, cache);\n    var charM = startM + charLength / 2;\n\n    while (offset < end - stride && segmentM + segmentLength < charM) {\n      x1 = x2;\n      y1 = y2;\n      offset += stride;\n      x2 = flatCoordinates[offset];\n      y2 = flatCoordinates[offset + 1];\n      segmentM += segmentLength;\n      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n\n    var segmentPos = charM - segmentM;\n    var angle = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      angle += angle > 0 ? -Math.PI : Math.PI;\n    }\n\n    if (previousAngle !== undefined) {\n      var delta = angle - previousAngle;\n      angleChanged = angleChanged || delta !== 0;\n      delta += delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;\n\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n\n    previousAngle = angle;\n    var interpolate = segmentPos / segmentLength;\n    var x = lerp(x1, x2, interpolate);\n    var y = lerp(y1, y2, interpolate);\n    result[index] = [x, y, charLength / 2, angle, char];\n    startM += charLength;\n  }\n\n  return angleChanged ? result : [[result[0][0], result[0][1], result[0][2], result[0][3], text]];\n}","map":{"version":3,"sources":["../../src/geom/flat/textpath.js"],"names":[],"mappings":"AAAA;;;AAGA,SAAQ,IAAR,QAAmB,eAAnB;AAGA;;;;;;;;;;;;;;;;AAeA,OAAM,SAAU,cAAV,CACJ,eADI,EACa,MADb,EACqB,GADrB,EAC0B,MAD1B,EACkC,IADlC,EACwC,MADxC,EACgD,QADhD,EAC0D,KAD1D,EACiE,wBADjE,EAC2F,IAD3F,EACiG,KADjG,EACsG;AAC1G,MAAM,MAAM,GAAG,EAAf,CAD0G,CAG1G;;AACA,MAAM,OAAO,GAAG,eAAe,CAAC,MAAD,CAAf,GAA0B,eAAe,CAAC,GAAG,GAAG,MAAP,CAAzD;AAEA,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAtB;AAEA,MAAI,EAAE,GAAG,eAAe,CAAC,MAAD,CAAxB;AACA,MAAI,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,CAAV,CAAxB;AACA,EAAA,MAAM,IAAI,MAAV;AACA,MAAI,EAAE,GAAG,eAAe,CAAC,MAAD,CAAxB;AACA,MAAI,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,CAAV,CAAxB;AACA,MAAI,QAAQ,GAAG,CAAf;AACA,MAAI,aAAa,GAAG,IAAI,CAAC,IAAL,CAAU,IAAI,CAAC,GAAL,CAAS,EAAE,GAAG,EAAd,EAAkB,CAAlB,IAAuB,IAAI,CAAC,GAAL,CAAS,EAAE,GAAG,EAAd,EAAkB,CAAlB,CAAjC,CAApB;AACA,MAAI,YAAY,GAAG,KAAnB;AAEA,MAAI,KAAJ,EAAW,aAAX;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAApB,EAA8B,EAAE,CAAhC,EAAmC;AACjC,IAAA,KAAK,GAAG,OAAO,GAAG,QAAQ,GAAG,CAAX,GAAe,CAAlB,GAAsB,CAArC;AACA,QAAM,IAAI,GAAG,IAAI,CAAC,KAAD,CAAjB;AACA,QAAM,UAAU,GAAG,KAAK,GAAG,wBAAwB,CAAC,IAAD,EAAO,IAAP,EAAa,KAAb,CAAnD;AACA,QAAM,KAAK,GAAG,MAAM,GAAG,UAAU,GAAG,CAApC;;AACA,WAAO,MAAM,GAAG,GAAG,GAAG,MAAf,IAAyB,QAAQ,GAAG,aAAX,GAA2B,KAA3D,EAAkE;AAChE,MAAA,EAAE,GAAG,EAAL;AACA,MAAA,EAAE,GAAG,EAAL;AACA,MAAA,MAAM,IAAI,MAAV;AACA,MAAA,EAAE,GAAG,eAAe,CAAC,MAAD,CAApB;AACA,MAAA,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,CAAV,CAApB;AACA,MAAA,QAAQ,IAAI,aAAZ;AACA,MAAA,aAAa,GAAG,IAAI,CAAC,IAAL,CAAU,IAAI,CAAC,GAAL,CAAS,EAAE,GAAG,EAAd,EAAkB,CAAlB,IAAuB,IAAI,CAAC,GAAL,CAAS,EAAE,GAAG,EAAd,EAAkB,CAAlB,CAAjC,CAAhB;AACD;;AACD,QAAM,UAAU,GAAG,KAAK,GAAG,QAA3B;AACA,QAAI,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,EAAE,GAAG,EAAhB,EAAoB,EAAE,GAAG,EAAzB,CAAZ;;AACA,QAAI,OAAJ,EAAa;AACX,MAAA,KAAK,IAAI,KAAK,GAAG,CAAR,GAAY,CAAC,IAAI,CAAC,EAAlB,GAAuB,IAAI,CAAC,EAArC;AACD;;AACD,QAAI,aAAa,KAAK,SAAtB,EAAiC;AAC/B,UAAI,KAAK,GAAG,KAAK,GAAG,aAApB;AACA,MAAA,YAAY,GAAG,YAAY,IAAI,KAAK,KAAK,CAAzC;AACA,MAAA,KAAK,IAAK,KAAK,GAAG,IAAI,CAAC,EAAd,GAAoB,CAAC,CAAD,GAAK,IAAI,CAAC,EAA9B,GAAoC,KAAK,GAAG,CAAC,IAAI,CAAC,EAAf,GAAqB,IAAI,IAAI,CAAC,EAA9B,GAAmC,CAA/E;;AACA,UAAI,IAAI,CAAC,GAAL,CAAS,KAAT,IAAkB,QAAtB,EAAgC;AAC9B,eAAO,IAAP;AACD;AACF;;AACD,IAAA,aAAa,GAAG,KAAhB;AACA,QAAM,WAAW,GAAG,UAAU,GAAG,aAAjC;AACA,QAAM,CAAC,GAAG,IAAI,CAAC,EAAD,EAAK,EAAL,EAAS,WAAT,CAAd;AACA,QAAM,CAAC,GAAG,IAAI,CAAC,EAAD,EAAK,EAAL,EAAS,WAAT,CAAd;AACA,IAAA,MAAM,CAAC,KAAD,CAAN,GAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,UAAU,GAAG,CAApB,EAAuB,KAAvB,EAA8B,IAA9B,CAAhB;AACA,IAAA,MAAM,IAAI,UAAV;AACD;;AACD,SAAO,YAAY,GAAG,MAAH,GAAY,CAAC,CAAC,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,CAAD,EAAe,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,CAAf,EAA6B,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,CAA7B,EAA2C,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,CAA3C,EAAyD,IAAzD,CAAD,CAA/B;AACD","sourceRoot":"","sourcesContent":["/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @return {Array<Array<*>>} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache) {\n    var result = [];\n    // Keep text upright\n    var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\n    var numChars = text.length;\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    offset += stride;\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var segmentM = 0;\n    var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    var angleChanged = false;\n    var index, previousAngle;\n    for (var i = 0; i < numChars; ++i) {\n        index = reverse ? numChars - i - 1 : i;\n        var char = text[index];\n        var charLength = scale * measureAndCacheTextWidth(font, char, cache);\n        var charM = startM + charLength / 2;\n        while (offset < end - stride && segmentM + segmentLength < charM) {\n            x1 = x2;\n            y1 = y2;\n            offset += stride;\n            x2 = flatCoordinates[offset];\n            y2 = flatCoordinates[offset + 1];\n            segmentM += segmentLength;\n            segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n        }\n        var segmentPos = charM - segmentM;\n        var angle = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            angle += angle > 0 ? -Math.PI : Math.PI;\n        }\n        if (previousAngle !== undefined) {\n            var delta = angle - previousAngle;\n            angleChanged = angleChanged || delta !== 0;\n            delta += (delta > Math.PI) ? -2 * Math.PI : (delta < -Math.PI) ? 2 * Math.PI : 0;\n            if (Math.abs(delta) > maxAngle) {\n                return null;\n            }\n        }\n        previousAngle = angle;\n        var interpolate = segmentPos / segmentLength;\n        var x = lerp(x1, x2, interpolate);\n        var y = lerp(y1, y2, interpolate);\n        result[index] = [x, y, charLength / 2, angle, char];\n        startM += charLength;\n    }\n    return angleChanged ? result : [[result[0][0], result[0][1], result[0][2], result[0][3], text]];\n}\n//# sourceMappingURL=textpath.js.map"]},"metadata":{},"sourceType":"module"}